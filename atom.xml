<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>We</title>
  
  
  <link href="http://blog.wangeyi.ink/atom.xml" rel="self"/>
  
  <link href="http://blog.wangeyi.ink/"/>
  <updated>2022-08-25T12:52:57.864Z</updated>
  <id>http://blog.wangeyi.ink/</id>
  
  <author>
    <name>We_</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网笔记</title>
    <link href="http://blog.wangeyi.ink/2022/08/25/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.wangeyi.ink/2022/08/25/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/</id>
    <published>2022-08-25T12:47:37.000Z</published>
    <updated>2022-08-25T12:52:57.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><a href="http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0.pdf">概述</a></h3><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><a href="http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82.pdf">物理层</a></h3><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><a href="http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.pdf">数据链路层</a></h3><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><a href="http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82.pdf">网络层</a></h3><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><a href="http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82.pdf">传输层</a></h3><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><a href="http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82.pdf">应用层</a></h3><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0.pdf&quot;&gt;概述&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;物理层&quot;&gt;&lt;a href=&quot;#物理层&quot; class=&quot;headerlink&quot; title=&quot;物理层&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82.pdf&quot;&gt;物理层&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.pdf&quot;&gt;数据链路层&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;网络层&quot;&gt;&lt;a href=&quot;#网络层&quot; class=&quot;headerlink&quot; title=&quot;网络层&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82.pdf&quot;&gt;网络层&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://picgo.wangeyi.ink/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82.pdf&quot;&gt;传输层&lt;/a&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计网" scheme="http://blog.wangeyi.ink/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之性能指标</title>
    <link href="http://blog.wangeyi.ink/2022/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    <id>http://blog.wangeyi.ink/2022/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</id>
    <published>2022-08-25T12:11:03.000Z</published>
    <updated>2022-08-25T12:39:04.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><blockquote><p><code>数据率</code> 或称<code>数据传输率</code>或<code>比特率</code></p><p>: 连接在计算机网络上的<code>主机</code>在数字信道上传送数据位数的速率</p><p>每秒传送比特位的位数</p></blockquote><ul><li>单位 ：<code>b/s、kb/s、Mb/s、Gb/s、 Tb/s</code></li></ul><h5 id="另外：-单位的换算"><a href="#另外：-单位的换算" class="headerlink" title="另外： 单位的换算"></a>另外： 单位的换算</h5><p><img src="http://picgo.wangeyi.ink/image-20220825201731552.png" alt="image-20220825201731552"></p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><blockquote><p>原指信号具有的频带宽度：最高频率与最低频率之差</p></blockquote><blockquote><p><code>计网中</code> ： 表示网络的通信线路传送数据的能力： </p><p><img src="http://picgo.wangeyi.ink/image-20220825202343670.png" alt="image-20220825202343670"></p></blockquote><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><blockquote><p><img src="http://picgo.wangeyi.ink/image-20220825202753038.png" alt="image-20220825202753038"></p></blockquote><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><blockquote><p><img src="http://picgo.wangeyi.ink/image-20220825203413118.png" alt="image-20220825203413118"></p></blockquote><ul><li><p>发送时延（传输时延）： 发送分组的第一个比特到最后一个比特</p><p><code>高速链路取决于发送时延</code></p><p><img src="http://picgo.wangeyi.ink/image-20220825203052137.png" alt="image-20220825203052137"></p></li><li><p>传播时延：取决于电磁波传播速度和链路长度</p><p><img src="http://picgo.wangeyi.ink/image-20220825203221938.png" alt="image-20220825203221938"></p></li><li><p>排队时延： 等待输出&#x2F;入链路可用</p></li><li><p>处理时延：检错&#x2F;找出口</p></li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><blockquote><p><img src="http://picgo.wangeyi.ink/image-20220825203651134.png" alt="image-20220825203651134"></p></blockquote><h3 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h3><blockquote><p>从发送方发送数据开始，到发送方收到接收方的确认的时延</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220825203816367.png" alt="image-20220825203816367"></p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><ul><li>信道利用率</li><li><img src="http://picgo.wangeyi.ink/image-20220825203857660.png" alt="image-20220825203857660"></li><li>网络利用率</li><li><img src="http://picgo.wangeyi.ink/image-20220825203904370.png" alt="image-20220825203904370"></li></ul>]]></content>
    
    
    <summary type="html">计网</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计网" scheme="http://blog.wangeyi.ink/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>文件管理</title>
    <link href="http://blog.wangeyi.ink/2022/08/22/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.wangeyi.ink/2022/08/22/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2022-08-22T08:02:10.000Z</published>
    <updated>2022-08-22T08:04:14.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><blockquote><p>文件的属性</p><ul><li>文件名：同一目录下不允许有重名文件</li><li>标识符：系统内的各文件标识唯一</li><li>类型：指明文件的类型</li><li>位置：文件的存放的路径、在外存中存放的地址</li><li>大小：文件的大小</li><li>创建时间、上次修改时间</li><li>保护信息：对文件进行保护的访问控制信息</li></ul><p><code>“无结构文件”、“结构文件”</code>  ：文件内部的数据的组织形式</p><p>z</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220818144710478.png" alt="image-20220818144710478"></p><p><img src="http://picgo.wangeyi.ink/image-20220818145100392.png" alt="image-20220818145100392"></p><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><blockquote><ul><li><p>无结构文件</p><p>文件内部是一系列二进制流或着字符流组成，“流式文件”， txt文件</p></li><li><p>结构文件 “记录式文件”，由一组相似的记录组成，每条记录由若干数据项组成</p><ul><li>顺序结构</li><li>索引结构</li><li>索引顺序结构</li></ul></li></ul></blockquote><h5 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h5><p><code>文件中的记录一个接一个顺序排列</code>，在物理上可以是顺序存储或链式存储</p><ul><li><p>链式存储： 无法实现随机存储、每次只能从第一个记录开始依次往后查找</p></li><li><p>顺序存储：</p><p>​<code>可变长的记录</code>： 无法实现随机存储</p><p>​<code>定长记录</code>  ： 可实现随机存储、</p></li></ul><h5 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h5><p><img src="http://picgo.wangeyi.ink/image-20220818151353171.png" alt="image-20220818151353171"></p><h5 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h5><blockquote><p>索引文件的索引表可能会很大</p><p>“一组记录对应一个索引表项”</p></blockquote><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><p><img src="http://picgo.wangeyi.ink/image-20220818152334192.png" alt="image-20220818152334192"></p><ul><li>文件控制块</li></ul><blockquote><p>目录文件 ： 本身是一种有结构文件，由一条条记录组成，每一条记录对应存放在该目录下的文件</p><p>目录文件中的 <code>一条记录</code> 就是一个 文件控制块（FCB）</p></blockquote><p><code>FCB 实现文件名到文件之间的映射</code> ， 名字到物理存放地址之间的映射</p><ul><li>树形目录结构  ： 多级目录结构</li></ul><h4 id="文件分配方式"><a href="#文件分配方式" class="headerlink" title="文件分配方式"></a>文件分配方式</h4><blockquote><p>文件的逻辑地址空间也被分为一个一个的<code>文件块</code></p><p>— &gt;  文件的逻辑地址也可以表示为 逻辑块号  + 块内地址</p></blockquote><ul><li>连续分配： <code>每个文件在磁盘上占有一组连续的块</code> ,</li></ul><p>​文件的目录中记录存放的<code>起始块号</code>和<code>长度 （占用了几个块）</code></p><p>​<img src="http://picgo.wangeyi.ink/image-20220818155329356.png" alt="image-20220818155329356"></p><p>​ <code>顺序读写时的速度最快</code> 、 <code>不方便扩展</code> 、<code>存储利用率低，会产生难以利用的磁盘碎片</code> </p><ul><li><p>链接分配 ： <code>采取离散链接的方式</code></p><p><code>隐式链接</code>： <img src="http://picgo.wangeyi.ink/image-20220818155858826.png" alt="image-20220818155858826" style="zoom:67%;" /></p><p><code>只支持顺序访问、不支持随机访问，查找效率很低</code>、<code>方便拓展文件</code></p><p><code>显示链接</code> ： 链接文件各物理块的指针显示地存放在一张表中， (文件分配表)</p><img src="http://picgo.wangeyi.ink/image-20220818160238497.png" alt="image-20220818160238497" style="zoom:67%;" /><p><img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220818160545735.png" alt="image-20220818160545735"></p><p><code>链接分配总结</code></p><p><img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220818160650319.png" alt="image-20220818160650319"></p></li><li><p>索引分配： 允许文件离散地分配在各个磁盘块中 （<code>索引表，记录了文件各个逻辑块对应的物理块</code>）</p><blockquote><p>索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块</p></blockquote><p><img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220818160932364.png" alt="image-20220818160932364"></p><p><code>支持随机访问、文件拓展也容易实现</code></p><p><img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220818162130176.png" alt="image-20220818162130176"></p></li></ul><h4 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h4><p><img src="http://picgo.wangeyi.ink/image-20220822143817801.png" alt="image-20220822143817801"></p><ul><li><p><code>空闲表法</code> ： 适用于连续分配方式</p><p><img src="http://picgo.wangeyi.ink/image-20220822144235357.png" alt="image-20220822144235357"></p></li><li><p><code>空闲链表法</code>：离散分配和连续分配都适用</p><img src="http://picgo.wangeyi.ink/image-20220822144254035.png" alt="image-20220822144254035" style="zoom:50%;" /></li><li><p><code>位示图法</code>：离散分配和连续分配都适用</p><img src="http://picgo.wangeyi.ink/image-20220822144627197.png" alt="image-20220822144627197" style="zoom:50%;" /></li><li><p><code>成组链接法</code> ：</p></li></ul><blockquote><p>空闲表法、空闲链表法都不适用于大型文件系统，“空闲表和空闲链表可能会很大”</p></blockquote><p>  <img src="http://picgo.wangeyi.ink/image-20220822145114144.png" alt="image-20220822145114144"></p>  <img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220822145523458.png" alt="image-20220822145523458" style="zoom:50%;" /><h4 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h4><blockquote><p>系统调用实现</p></blockquote><ul><li><p>创建文件： <code>create系统调用</code>：</p><p>提供的参数:</p><ul><li>所需的外存空间大小</li><li>文件的存放路径</li><li>文件名</li></ul><p>操作系统处理create系统调用的两件事情：</p><ul><li>在外存中找到文件所需的空间</li><li>创建该文件对应的目录项</li></ul></li></ul><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p><img src="http://picgo.wangeyi.ink/image-20220822150159172.png" alt="image-20220822150159172"></p><p><img src="http://picgo.wangeyi.ink/image-20220822150253868.png" alt="image-20220822150253868"></p><h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><blockquote><p>口令保护、加密保护、访问控制</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220822150616801.png" alt="image-20220822150616801"></p><p><img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220822150752697.png" alt="image-20220822150752697"></p><p><img src="http://picgo.wangeyi.ink/image-20220822150947870.png" alt="image-20220822150947870"></p><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><h4 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h4><ul><li><p>磁盘、磁道和扇区</p><p><img src="http://picgo.wangeyi.ink/image-20220822151656208.png" alt="image-20220822151656208"></p></li><li><p>盘面、柱面</p><p><img src="http://picgo.wangeyi.ink/image-20220822151810139.png" alt="image-20220822151810139"></p></li></ul><blockquote><p>可用（柱面号、盘面号、扇区号）定义任意的“磁盘块”</p></blockquote><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><ul><li><p>磁盘读&#x2F;写操作的时间</p><p><code>寻道时间TS</code> ：  启动磁头臂的时间、移动磁头的时间</p><p><code>延迟时间TR</code>:  通过旋转磁盘，使磁头定位到目标扇区的时间</p><p><code>传输时间Tt</code> ： 读出&#x2F;写入数据所经历的时间</p></li></ul><blockquote><p>操作系统的磁盘调度算法会直接影响寻道时间</p></blockquote><ul><li><p>先来先服务算法（FCFS）</p><p>优点：<code>公平： 如果请求访问的磁道比较集中的话，算法性能还算过的去</code> </p><p>缺点：<code>如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</code></p></li><li><p>最短寻找时间优先（sstf）</p><p><code>优先处理的磁道时与当前磁头最近的磁道</code>，保证每次的寻道时间最短</p><p>优点： 性能较好、平均寻道时间短</p><p>缺点：<code>可能产生饥饿现象</code></p></li><li><p>扫描算法（SCAN）</p><p><img src="http://picgo.wangeyi.ink/image-20220822153305264.png" alt="image-20220822153305264"></p></li><li><p>LOOK算法</p><p><img src="http://picgo.wangeyi.ink/image-20220822153521836.png" alt="image-20220822153521836"></p></li><li><p>循环扫描算法（C-SCAN）</p><p><img src="http://picgo.wangeyi.ink/image-20220822153731724.png" alt="image-20220822153731724"></p></li><li><p>C-LOOK 算法</p><p><img src="http://picgo.wangeyi.ink/image-20220822153834768.png" alt="image-20220822153834768"></p></li></ul><h5 id="减少磁盘延迟时间的"><a href="#减少磁盘延迟时间的" class="headerlink" title="减少磁盘延迟时间的"></a>减少磁盘延迟时间的</h5><ul><li><p>交替编号 ： 让逻辑上相邻的扇区在物理上有一定的间隔</p><blockquote><p> 读入扇区后需要一小段时间处理，无法连续不断地读入相邻扇区，需要很长的”延迟时间“</p></blockquote></li></ul><blockquote><p>为什么柱面号要在盘面号之前？</p><p>读取地址连续的磁盘块时，采用（柱面号、盘面号、扇区号）可以减少磁头移动的时间</p></blockquote><ul><li><p>错位命名： 盘面的扇区编号是错开的</p><p><img src="http://picgo.wangeyi.ink/image-20220822155405903.png" alt="image-20220822155405903"></p></li></ul><h4 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h4><ul><li><code>磁盘初始化</code>： 进行低级格式化（物理格式化）： 将磁道划分位扇区</li><li><code>磁盘分区</code>： 每个分区由若干个柱面组成（C\D\F盘）</li><li><code>逻辑格式化</code>，创建文件系统、根目录、初始化存储空间管理所用的数据结构</li></ul><h5 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h5><p><img src="http://picgo.wangeyi.ink/image-20220822155928895.png" alt="image-20220822155928895"></p><p><img src="http://picgo.wangeyi.ink/image-20220822160038438.png" alt="image-20220822160038438"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;文件管理&quot;&gt;&lt;a href=&quot;#文件管理&quot; class=&quot;headerlink&quot; title=&quot;文件管理&quot;&gt;&lt;/a&gt;文件管理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;文件的属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件名：同一目录下不允许有重名文件&lt;/li&gt;
&lt;li&gt;标识符：系统内的各文件标识唯一&lt;/li&gt;
&lt;li&gt;类型：指明文件的类型&lt;/li&gt;
&lt;li&gt;位置：文件的存放的路径、在外存中存放的地址&lt;/li&gt;
&lt;li&gt;大小：文件的大小&lt;/li&gt;
&lt;li&gt;创建时间、上次修改时间&lt;/li&gt;
&lt;li&gt;保护信息：对文件进行保护的访问控制信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;“无结构文件”、“结构文件”&lt;/code&gt;  ：文件内部的数据的组织形式&lt;/p&gt;
&lt;p&gt;z&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://picgo.wangeyi.ink/image-20220818144710478.png&quot; alt=&quot;image-20220818144710478&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://picgo.wangeyi.ink/image-20220818145100392.png&quot; alt=&quot;image-20220818145100392&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;文件的逻辑结构&quot;&gt;&lt;a href=&quot;#文件的逻辑结构&quot; class=&quot;headerlink&quot; title=&quot;文件的逻辑结构&quot;&gt;&lt;/a&gt;文件的逻辑结构&lt;/h4&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="os" scheme="http://blog.wangeyi.ink/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="http://blog.wangeyi.ink/2022/08/21/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://blog.wangeyi.ink/2022/08/21/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2022-08-21T12:11:27.000Z</published>
    <updated>2022-08-21T13:38:02.163Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>总结一下智能指针的知识</p></blockquote><ul><li>内存资源管理不当：<ul><li>内存已被释放，但指针的指向没有改变。–&gt;野指针</li><li>试图释放已经被释放的内存资源</li><li>没有及时释放不再使用的内存资源。–&gt;内存泄漏</li></ul></li></ul><h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><code>shared_ptr</code></h5><blockquote><p>C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br></pre></td></tr></table></figure><ul><li><p>构造空智能指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">//传入空指针 nullptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空智能指针 的引用计数 为 0  </span></span><br></pre></td></tr></table></figure></li><li><p>初始化智能指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">p3</span><span class="params">(new <span class="type">int</span>(<span class="number">10</span>))</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">std</span>::make_shared&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配一个对象并初始化，返回指向这个对象的shared_ptr</span></span><br><span class="line">template&lt; class T, class... Args &gt;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title function_">make_shared</span><span class="params">( Args&amp;&amp;... args )</span>;</span><br></pre></td></tr></table></figure></li><li><p>拷贝和赋值</p><p>进行拷贝和赋值操作时，<code>每个shared_ptr 会记录有多少其他shared_ptr 指向相同的对象</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"><span class="comment">// 若p3 为空智能指针，则引用计数初始值为0， 否则引用计数会加1</span></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; <span class="comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></span><br><span class="line"><span class="comment">//p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一个普通指针不能同时为多个智能指针对象赋值，会导致程序发生异常</span></span><br><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li><li><p>自定义释放规则</p><p>堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line"><span class="comment">//自定义释放规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteInt</span><span class="params">(<span class="type">int</span>*p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化智能指针，并自定义释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], deleteInt)</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>成员方法</p><table><thead><tr><th>成员方法名</th><th>功 能</th></tr></thead><tbody><tr><td>operator&#x3D;()</td><td>重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。</td></tr><tr><td>operator*()</td><td>重载 * 号，获取当前 shared_ptr 智能指针对象指向的数据。</td></tr><tr><td>operator-&gt;()</td><td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td></tr><tr><td>swap()</td><td>交换 2 个相同类型 shared_ptr 智能指针的内容。</td></tr><tr><td>reset()</td><td>当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</td></tr><tr><td>get()</td><td>获得 shared_ptr 对象内部包含的普通指针。</td></tr><tr><td>use_count()</td><td>返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。</td></tr><tr><td>unique()</td><td>判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。</td></tr><tr><td>operator bool()</td><td>判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td></tr></tbody></table></li></ul><p>​</p><h5 id="shared-ptr-简单实现"><a href="#shared-ptr-简单实现" class="headerlink" title="shared_ptr 简单实现"></a><code>shared_ptr</code> 简单实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shared_Ptr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Shared_Ptr</span>(T* ptr = <span class="literal">nullptr</span>) <span class="comment">// 默认构造函数</span></span><br><span class="line">:_pPtr(ptr)</span><br><span class="line">, _pRefCount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) <span class="comment">//引用计数为1 </span></span><br><span class="line">, _pMutex(<span class="keyword">new</span> mutex)</span><br><span class="line">&#123;&#125;</span><br><span class="line">~<span class="built_in">Shared_Ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Shared_Ptr</span>(<span class="type">const</span> Shared_Ptr&lt;T&gt;&amp; sp) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">:_pPtr(sp._pPtr)</span><br><span class="line">, _pRefCount(sp._pRefCount)</span><br><span class="line">, _pMutex(sp._pMutex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AddRefCount</span>(); <span class="comment">// 引用计数加1</span></span><br><span class="line">&#125;</span><br><span class="line">Shared_Ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Shared_Ptr&lt;T&gt;&amp; sp) <span class="comment">// 赋值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if (this != &amp;sp)</span></span><br><span class="line"><span class="keyword">if</span> (_pPtr != sp._pPtr)  <span class="comment">// 如果赋值的不是用一个对象，释放旧资源，指向新对象，引用计数加1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 释放管理的旧资源</span></span><br><span class="line"><span class="built_in">Release</span>();</span><br><span class="line"><span class="comment">// 共享管理新对象的资源，并增加引用计数</span></span><br><span class="line">_pPtr = sp._pPtr;</span><br><span class="line">_pRefCount = sp._pRefCount;</span><br><span class="line">_pMutex = sp._pMutex;</span><br><span class="line"><span class="built_in">AddRefCount</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line"><span class="keyword">return</span> *_pPtr; <span class="comment">// 解引用</span></span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()&#123;<span class="comment">// </span></span><br><span class="line"><span class="keyword">return</span> _pPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UseCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *_pRefCount; &#125;</span><br><span class="line"><span class="function">T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _pPtr; &#125;  <span class="comment">// 获取指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddRefCount</span><span class="params">()</span>  <span class="comment">// 引用计数加1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_pMutex-&gt;<span class="built_in">lock</span>(); <span class="comment">// 加锁</span></span><br><span class="line">++(*_pRefCount);</span><br><span class="line">_pMutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> deleteflag = <span class="literal">false</span>;</span><br><span class="line">_pMutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _pRefCount;</span><br><span class="line"><span class="keyword">delete</span> _pPtr;</span><br><span class="line">deleteflag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">_pMutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">if</span> (deleteflag == <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">delete</span> _pMutex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> *_pRefCount;</span><br><span class="line">T* _pPtr;</span><br><span class="line">mutex* _pMutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><p><a href="https://cloud.tencent.com/developer/article/1688444">面试题：简单实现一个shared_ptr智能指针 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">std::make_shared, std::make_shared_for_overwrite - cppreference.com</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;总结一下智能指针的知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内存资源管理不当：&lt;ul&gt;
&lt;li&gt;内存已被释放，但指针的指向没有改变。–&amp;gt;野指针&lt;/li&gt;
&lt;li&gt;试图释放已经被释放的内存资源&lt;/li&gt;
&lt;li&gt;没有及时释放不再使用的内存资源。–&amp;gt;内存泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;shared-ptr&quot;&gt;&lt;a href=&quot;#shared-ptr&quot; class=&quot;headerlink&quot; title=&quot;shared_ptr&quot;&gt;&lt;/a&gt;&lt;code&gt;shared_ptr&lt;/code&gt;&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="c++" scheme="http://blog.wangeyi.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>内存管理？</title>
    <link href="http://blog.wangeyi.ink/2022/07/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9F/"/>
    <id>http://blog.wangeyi.ink/2022/07/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9F/</id>
    <published>2022-07-21T07:55:21.000Z</published>
    <updated>2022-07-22T07:38:45.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h5 id="内存是什么"><a href="#内存是什么" class="headerlink" title="内存是什么"></a>内存是什么</h5><blockquote><p>内存是用于存放数据的硬件，程序执行之前需要先放到内存中才能被CPU处理</p></blockquote><h5 id="内存管理做什么"><a href="#内存管理做什么" class="headerlink" title="内存管理做什么"></a>内存管理做什么</h5><blockquote><ol><li>操作系统负责内存空间的分配和回收</li><li>提供某种技术从逻辑上对内存空间进行扩充</li><li>负责地址转换，逻辑地址-&gt; 物理地址</li><li>内存保护， 保证各进程在各自空间内独立运行，互不干扰<ol><li>设置上、下限寄存器，存放进程的上下限地址</li><li>重定位寄存器（基址寄存器 存放起始的物理地址）和界地址寄存器（限长寄存器 ，存放最大逻辑地址）</li></ol></li></ol></blockquote><h5 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h5><h6 id="逻辑地址vs物理地址"><a href="#逻辑地址vs物理地址" class="headerlink" title="逻辑地址vs物理地址"></a>逻辑地址vs物理地址</h6><blockquote><p>逻辑地址（相对地址）相对于进程在内存中的起始地址而言的地址</p><p>物理地址（绝对地址）内存中的实际位置</p></blockquote><h6 id="逻辑地址-gt-物理地址的转换-（重定位）"><a href="#逻辑地址-gt-物理地址的转换-（重定位）" class="headerlink" title="逻辑地址-&gt;物理地址的转换 （重定位）"></a>逻辑地址-&gt;物理地址的转换 （重定位）</h6><ul><li><p>静态重定位：可重定位装入</p><p>再程序执行之前进行重定位（把逻辑地址转换为物理地址）</p><p><code>作业装入内存：</code>必须为其分配要求的全部内存空间，否则不能装入</p><p><code>作业在运行期间就不能再移动</code></p></li><li><p>动态重定位：动态运行时装入</p><p>装入程序时不能进行重定位，<code>在程序运行时才进行地址转换</code></p><p><code>运行程序在内存中移动</code>， 能够动态分配内存</p></li></ul><h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><blockquote><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接</p></blockquote><ul><li><p>静态链接： <code>程序运行之前</code>， 把各目标模块以及所需的库函数链接成一个完整的可执行文件。</p><blockquote><p>在使用静态链接库的情况下，在编译链接可执行文件时，链接器会复制静态链接库中的<code>函数和数据</code>，与程序的其他模型组合创建可执行文件。</p></blockquote><p><code>空间浪费</code>： 由于每个可执行文件都需要一个静态链接库的副本，当出现多个程序依赖同一个静态链接库，就会出现在内存中存在多个副本的情况。</p><p><code>更新困难</code>：当修改了库函数的代码时，需要重新编译链接形成可执行晚间。</p><p><code>运行速度快</code>：可执行文件在运行前已经包含需要的所有函数和数据，在执行的时候运行速度快。</p></li><li><p>动态链接：程序执行过程中需要该目标模块时，才对它进行链接</p><p><code>共享库</code>： 就是即使每个程序都依赖于同一个库，也不会像静态链接库那样在内存中存在多个副本，而是这些程序共享同一个库文件</p><p><code>更新方便：</code> 更新只需替换原来的目标文件，不需要重新连接一遍，</p><p><code>性能损耗</code> 每次执行程序时都要进行连接，性能有一定损失。</p></li></ul><h5 id="内存空间扩充"><a href="#内存空间扩充" class="headerlink" title="内存空间扩充"></a>内存空间扩充</h5><blockquote><p>物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</p><p>​<code>覆盖技术</code> <code>交换技术  </code>虚拟内存技术 </p></blockquote><ul><li><p>覆盖技术：将程序分为多个段（模块），常用的段常驻内存，不常用的段需要时调入内存。</p><p>​常驻内存的段放在 “<code>固定区</code>”，调入就不再调出</p><p>​不常用的段放在 “<code>覆盖区</code>”，需要时调入内存，用不到时调出内存</p><p><code>缺点</code>：必须由用户声明覆盖结构，对用户不透明</p></li><li><p>交换技术：内存空间紧张的时候，系统将内存中某些进程暂时换出内存，把外存中具备运行条件的进程换入内存。PCB 会常驻内存</p></li></ul><h5 id="内存空间的分配于回收"><a href="#内存空间的分配于回收" class="headerlink" title="内存空间的分配于回收"></a>内存空间的分配于回收</h5><blockquote><p> 连续分配管理方式 ： 单一连续、固定分区、动态分区</p><p> ​非连续分配管理：</p><p> 区别： 连续分配：为用户进程分配的必须是连续的内存空间</p><p> ​非连续： 为用户进程分配的可以是一些分散的内存空间</p><p> <img src="http://picgo.wangeyi.ink/image-20220718204412405.png" alt="image-20220718204412405"></p></blockquote><h6 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h6><ul><li><p>单一连续分配 ： 内存分为<code>系统区</code> 和<code>用户区</code>，内存中只能有一道用户程序。</p><p><code>优点</code> 实现简单，无外部碎片</p><p><code>缺点</code> 只适用于单用户、单任务的操作系统，有内部碎片</p></li><li><p>固定分区分配： 用户空间划分为若干个<code>固定大小的分区</code>。每个分区只装入一道作业。</p><p><code>分区大小相等</code>  缺乏灵活性，适用于一台计算机控制<code>多个相同对象的场合</code></p><p><code>分区大小不等</code>增加了灵活性</p><p><code>优点</code> 实现简单，无外部碎片</p><p><code>缺点</code> 可能产生内部碎片，内存利用率低</p></li><li><p>动态分区分配：不会预先划分分区，在进程装土内存时根据进程的大小动态建立分区。</p></li></ul><p>​<code>没有内部碎片，但是有外部碎片</code>，外部碎片可以用”紧凑技术“来解决</p><hr><p>  <code>动态分区分配算法</code></p><blockquote><p>在动态分区分配方式中，当多个空闲分区都能满足需求时，应选择哪个分区进行分配</p></blockquote><ul><li><p>首次适应算法：<code>每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</code></p><p>空闲分区按照<code>地址递增</code>的次序排列，每次分配内存的时候顺序查找空闲分区链（表），找到大小能满足的第一个空闲分区</p><p><code>缺点</code> 每次查找都要从头查找，查找开销较大</p></li><li><p>最佳适应算法：<code>优先使用更小的分区</code>， </p><blockquote><p>因为动态分区是一种连续分配方式，分配的空间是连续整片区域，为了保证内存需求大的进程到来时能有足够大的连续空间，尽可能留下大片的空闲区。</p></blockquote><p>空闲分区按照<code>容量递增</code>的次序排列，每次分配内存时顺序查找空闲分区链（表），找到大小能够满足要求的第一个空闲分区。</p><p><code>缺点</code> 每次都使用最小分区进行分配，会产生越来越多不能使用的小内存快，这种方法会产生很多<code>外部碎片</code>。</p></li><li><p>最坏适应算法：<code>优先使用最大的连续空间</code>，为了解决最佳适应产生外部碎片的问题</p><p>空闲分区按照<code>容量递减</code>的次序排列，每次分配内存时顺序查找空闲分区链（表），找到大小能够满足要求的第一个空闲分区。</p><p><code>缺点</code>： 导致较大的连续空间迅速用完。</p></li><li><p>领近适应算法：<code>如果每次都从上次查找结束的位置开始检索</code></p><p>空闲分区以<code>地址递增</code>的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p></li></ul><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应</td><td>从头到尾找适合的分区</td><td>空闲分区以地址递增次序排列</td><td>综合看性能最好。<strong>算法开销小</strong>，回收分区后一.般不需要对空闲分区队列重新排序</td><td></td></tr><tr><td>最佳适应</td><td>优先使用更小的分区，以保留更多大分区</td><td>空闲分区以容量递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多太小的、难以利用的碎片;<strong>算法开销大</strong>，回收分区后可能需要对空闲分区队列重新排序</td></tr><tr><td>最坏适应</td><td>优先使用更大的分区，以防止产生太小的不可用的碎片</td><td>空闲分区以容量递减次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区容易被用完，不利于大进程;<strong>算法开销大</strong>(原因同上)</td></tr><tr><td>邻近适应</td><td>由首次适应演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增次序排列(可排列成循环链表)</td><td>不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong>(原因同首次适应算法)</td><td>会使高地址的大分区也被用完</td></tr></tbody></table><h6 id="非连续分配"><a href="#非连续分配" class="headerlink" title="非连续分配"></a>非连续分配</h6><blockquote><p>基本分页存储管理、基本分段存储管理、段页式存储管理</p></blockquote><h5 id="基本分页存储管理："><a href="#基本分页存储管理：" class="headerlink" title="基本分页存储管理："></a>基本分页存储管理：</h5><blockquote><p>把内存分为大小相等的分区（页框、页帧、内存块、物理块），将用户的进程的地址空间也分为于页框大小相等的 区域（页，页面）。</p></blockquote><p> <code>如何实现地址转换</code> ：</p><p> 逻辑地址对应的页号 -&gt; <code>页号对应页面在内存中的起始地址</code> -&gt; 逻辑地址在页面内的 <code>偏移</code> -&gt; 物理地址 &#x3D; 页面起始地址 + 偏移。</p><p><img src="http://picgo.wangeyi.ink/image-20220718213845792.png" alt="image-20220718213845792"></p><h6 id="页表-：-每个进程对应一个页表"><a href="#页表-：-每个进程对应一个页表" class="headerlink" title="页表 ： 每个进程对应一个页表"></a>页表 ： 每个进程对应一个页表</h6><blockquote><p>记录进程页面和实际存放的内存块之间的对应关系</p><ol><li>一个进程对应一张页表</li><li>进程的每一页对应一个页表项</li><li>每个页表项由 ”页号“ 和  ”块号“ 组成</li><li>记录进程页面和实际存放的内存块之间的对应关系</li></ol></blockquote><h6 id="基本地址转换"><a href="#基本地址转换" class="headerlink" title="基本地址转换"></a>基本地址转换</h6><p><img src="http://picgo.wangeyi.ink/image-20220721143136169.png" alt="image-20220721143136169"></p><blockquote><ol><li>CPU给出逻辑地址，由某个硬件计算得到页号、页内偏移</li><li>比较页号与页表长度，页号大于等于页表长度，则产生越界中断，否则继续执行</li><li>查询页表，找到页号对应的页表项，确定内存块号</li><li>用内存块号和页内偏移计算得到物理地址</li></ol></blockquote><h6 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h6><p><code>局部性原理</code></p><blockquote><p>分为时间局部性和空间局部性两种</p><p><code>时间局部性</code> 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(<em>因为程序中存在大量的循环</em>)</p><p><code>空间局部性</code>旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(<em>因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的</em>)</p></blockquote><p><code>快表（联想寄存器TLB）</code>  ：访问速度比内存快的高速缓冲寄存器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><h6 id="引入快表的地址转换过程"><a href="#引入快表的地址转换过程" class="headerlink" title="引入快表的地址转换过程"></a>引入快表的地址转换过程</h6><blockquote><p>1.CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p><p>2.如果快表命中，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后根据物理地址访问内存</p><p>3.如果快表没有命中，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，同时将这个页表项存入快表，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元</p></blockquote><h6 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h6><ul><li><p>单级页表的问题</p><blockquote><ol><li>页表必须连续存储，当页表很大时，需要占用很多个连续的页框</li><li>没必要让整个页表常驻内存</li></ol></blockquote></li><li><p>两级页表的原理、结构</p><p><img src="http://picgo.wangeyi.ink/image-20220721150054880.png" alt="image-20220721150054880"></p><p><code>逻辑地址的结构发生变化</code></p><p><img src="http://picgo.wangeyi.ink/image-20220721150130035.png" alt="image-20220721150130035"></p></li></ul><h5 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h5><blockquote><p>进程的地址空间： 按照程序<code>自身的逻辑关系</code>划分为若干个段，段的长度是取决于用户编写的程序。</p><p>内存分配： 以段为单位进行分配，每个段在内存中战连续空间，但各段之间可以不相邻</p></blockquote><p>分段系统的逻辑地址由<code>段号</code> 和<code>段内地址</code> 组成</p><h6 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h6><ul><li>记录逻辑段到实际存储位置的映射关系</li></ul><blockquote><ol><li>每个段对应一个段表项，记录起始位置（基址） 和段的长度</li><li>各个段表的长度是相同的，段号是隐含的，不占用存储空间</li></ol></blockquote><h6 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h6><p><img src="http://picgo.wangeyi.ink/image-20220721152213875.png" alt="image-20220721152213875"></p><h5 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h5><h6 id="分页、分段管理的优缺点"><a href="#分页、分段管理的优缺点" class="headerlink" title="分页、分段管理的优缺点"></a>分页、分段管理的优缺点</h6><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页</td><td>内存利用率高、不会产生外部碎片，只会有少量页内碎片</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段</td><td>方便按照逻辑模块实现信息的共享和保护</td><td>会产生外部碎片</td></tr></tbody></table><blockquote><p>将进程按照逻辑模块分段，再将各段分页</p><p>再将内存空间分为大小相同的内存块，</p><p>进程将各页面装入内存块中</p></blockquote><p><code>逻辑地址结构</code> 段号  + 页号 + 页内偏移</p><p><img src="http://picgo.wangeyi.ink/image-20220721153853558.png" alt="image-20220721153853558"></p><p>段表、页表</p><blockquote><p>一个进程对应一个段表，可能对应多个页表</p><p>段表中存放 ： 页表长度、 页表存放块号 （ 这个段对应页表的大小与在内存中存放的地址）</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220721154059737.png" alt="image-20220721154059737"></p><h6 id="地址转换-1"><a href="#地址转换-1" class="headerlink" title="地址转换"></a>地址转换</h6><blockquote><ol><li>根据逻辑地址得到段号、页号、页内偏移</li><li>判断段号是否越界</li><li>根据段号查询段表，找到对应的段表项（页表存放块）  – 第一次访存</li><li>检查页号是否越界</li><li>根据页表存放快、页号查询页表。找到对应的页表项  – 第二次访存</li><li>根据内存块号、 页内偏移得到物理地址</li><li>访问目标内存单元  – 第三次访存</li></ol><p>也可以引入快表</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220721154336798.png" alt="image-20220721154336798"></p>]]></content>
    
    
    <summary type="html">内存</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="os" scheme="http://blog.wangeyi.ink/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>死锁？</title>
    <link href="http://blog.wangeyi.ink/2022/07/21/%E6%AD%BB%E9%94%81%EF%BC%9F/"/>
    <id>http://blog.wangeyi.ink/2022/07/21/%E6%AD%BB%E9%94%81%EF%BC%9F/</id>
    <published>2022-07-21T07:52:51.000Z</published>
    <updated>2022-07-21T07:57:28.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p>并发环境下，多个进程因竞争资源而造成的一种<code>互相等待对方手里的资源</code>，导致各进程阻塞，都无法向前推进</p></blockquote><h6 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h6><ul><li>互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待</li><li>不可剥夺条件： 进程所获得的资源在未使用完之前，<code>不能由其他进程强行夺走</code>，只能主动释放</li><li>请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。  （进程已经保持了至少一个资源，但又提出了新的资源请求，对自身持有的资源保持不放）</li><li>循环等待条件： 存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。<ul><li><code> 注意！发生死锁时一定有循环等待，但是发生循环等 待时末必死锁 （循环等待是死锁的必要不充分条件）</code></li></ul></li></ul><h6 id="发生死锁"><a href="#发生死锁" class="headerlink" title="发生死锁"></a>发生死锁</h6><ul><li>对系统资源的竞争： 各进程对不可剥夺的资源的竞争可能引起死锁。</li><li>进程推荐的顺序非法， 请求和释放资源的顺序不当。</li><li>信号量的使用不当。</li></ul><p><code>对不可剥夺资源的分配不合理的使用，可能出现死锁</code></p><h6 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h6><ul><li><p>鸵鸟策略 ： 忽略死锁。</p><p><code>在死锁不会对用户操作过大影响，或者发生死锁的概率很低的情况下。</code></p></li><li><p>死锁预防：在<code>程序运行之前</code>预防发生死锁，破环四个必要条件的一个或多个。</p></li><li><p>死锁避免：在程序运行时避免发生死锁。</p></li><li><p>死锁的检测和解除:  检测到死锁发生时，采取措施进行恢复。</p></li></ul><h6 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h6><blockquote><p>静态策略</p><p>破环死锁产生的必要条件： 互斥条件、不可剥夺条件、请求和保持条件、循环等待条件。</p></blockquote><ul><li><p>破坏互斥条件：</p><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程 <strong>SPOOLing 技术</strong></p></li><li><p>破环不可剥夺条件：</p><p>1。 某个进程请求新资源时得不到满足，必须释放保持的所有资源。  ———  主动释放，自己体面</p><p>2。 操作系统协助抢占资源，（进程优先级）。 ——— 帮它体面</p><p><code>缺点</code>  ：实现复杂，释放资源可能导致前一阶段的工作失效，</p><p>反复的申请、释放资源会增加系统开销，降低系统吞吐量。</p></li><li><p>破环请求和保持条件：</p><p><code>静态分配法</code> ：进程在运行之前一次性申请完它所需要的全部资源。</p><p><code>缺点：</code> 资源利用率极低，可能导致某种进程饥饿</p></li><li><p>破坏循环等待条件：</p><p><code>顺序资源分配法：</code>  给资源统一编号，进程只能按编号顺序来请求资源。</p><p><code>缺点</code> 不方便增加新设备，可能需要重新分配所有编号，导致资源浪费、用户编程麻烦。</p></li></ul><h6 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h6><blockquote><p>动态策略</p><p>银行家算法</p></blockquote><ul><li><p>安全状态（安全序列）：系统按照这种序列分配资源，则每个进程 都能顺利完成。安全序列可能有多个</p><p>安全状态： 一定不会发生死锁</p><p>不安全状态： 有可能发生死锁</p></li></ul><p><code>银行家算法：</code>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态。</p><p><img src="http://picgo.wangeyi.ink/image-20220717205455844.png" alt="image-20220717205455844"></p><h6 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h6><blockquote><p>死锁检测算法</p><p>死锁解除算法</p></blockquote><ul><li><p>死锁检测算法</p><p><code>数据结构</code> 资源分配图</p></li></ul><p><img src="http://picgo.wangeyi.ink/image-20220717210029820.png" alt="image-20220717210029820"></p><p><img src="http://picgo.wangeyi.ink/image-20220717210228789.png" alt="image-20220717210228789"></p>]]></content>
    
    
    <summary type="html">进程知识</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="os" scheme="http://blog.wangeyi.ink/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>面向对象？</title>
    <link href="http://blog.wangeyi.ink/2022/07/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F/"/>
    <id>http://blog.wangeyi.ink/2022/07/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F/</id>
    <published>2022-07-19T06:51:33.000Z</published>
    <updated>2022-07-19T08:07:46.525Z</updated>
    
    <content type="html"><![CDATA[<hr><h5 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h5><p><code>封装、继承和多态</code></p><h5 id="封装？"><a href="#封装？" class="headerlink" title="封装？"></a>封装？</h5><blockquote><p><code>是什么？ ：</code>把<code>数据</code>和 <code>操作数据的方法</code> 有机结合，形成<code>类</code>，对外隐藏对象的属性和实现细节，对外仅公开接口来实现于对象的交互。</p><p><code>怎么实现：</code> C++ 通过三种成员访问限定符来控制类中成员变量和成员函数的访问权限，分别是</p><p>​<code>public 公有的</code>，修饰的成员是共有的，可以被类内部访问也可以被类外部的用户访问； </p><p>​<code>private 私用的</code>，修饰的成员只能被类内部访问；</p><p>​<code>protected 受保护的</code>，修饰的成员除了能被本类访问，也能被继承类内部访问。</p><p><code>好处</code> ： 隐藏实现细节，提供公共的访问方式，提高代码的复用性，提高安全性</p></blockquote><h6 id="继承？"><a href="#继承？" class="headerlink" title="继承？"></a>继承？</h6><blockquote><p><code>什么是继承</code> 子类继承父类的特征和行为，使得子类对象拥有父类对象的属性和方法</p><p>派生类中的成员，包含两大部分：一类是从基类继承过来的，一类是自己增加的成员</p><p><code>好处</code> 提高代码的复用性；提高代码的拓展性；是多态的前提。</p></blockquote><h6 id="多态？"><a href="#多态？" class="headerlink" title="多态？"></a>多态？</h6><p><code>什么是多态？</code></p><blockquote><p>多态，多种形态，同一事物在不同场景下表现出不同行为就叫多态。</p><p>在面向对象中，多态是指 通过基类的指针或者引用， 在运行时<code>动态调用</code>实际绑定的对象函数的行为，与之相应的，在编译时绑定函数称为<code>静态绑定</code>，所以多态有静态多态和动态多态两种。</p></blockquote><blockquote><p><code>静态多态</code> 是在程序编译期间完成的，编译器根据传递到函数实参类型选择最佳匹配的函数并调用，如果没有呢，就发出警告或错误。静态多态有 函数重载、运算符重载和泛型编程等。</p></blockquote><blockquote><p><code>动态多态</code> <code>是在程序运行时</code> 根据基类的指针或引用 指向的对象的类型来确定调用基类还是派生类的虚函数。当基类指针指向基类对象时，就调用基类对象中的虚函数，如果基类指针指向的时派生类的对象，就调用派生类中定义的虚函数。</p><p>​<code>实现条件</code> 1. 要有继承关系， 2. 派生类要重写基类的虚函数，3. 基类的指针指向派生类对象。</p><p>​<code>实现原理</code>： 类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是存放类的虚函数指针的数据结构，虚函数成员会被编译器放入虚函数表中，当存在虚函数时，每个对象中都有一个指向<code>虚函数表的指针</code>在。多态调用时, vptr 指针就会根据这个<code>对象</code>在对应类的虚函数表中查找被调用的函数，从而找到函数的入口地址。</p></blockquote><h6 id="为什么值复制不能实现多态？"><a href="#为什么值复制不能实现多态？" class="headerlink" title="为什么值复制不能实现多态？"></a>为什么值复制不能实现多态？</h6><blockquote><p>多态是依靠虚函数表实现的，当类中存在虚函数时，类的对象都有一个指向虚函数表的指针。当基类的指针指向派生类对象时，就通过派生类对象中的虚函数指针找到虚函数，而这个虚函数就是派生类中定义的版本。</p></blockquote><p>对象中只保存了数据成员和虚函数指针，对象之间的拷贝复制时，编译器复制虚函数指针的复制，而编译器保证每个类的虚函数只在同类型对象中有用，比如派生类之间的复制，虚函数指针正常复制，而将派生类对象赋值给基类对象时，编译器保证这个基类对象的虚函数指针还是指向基类的虚函数表，而不会指向派生类的虚函数表。</p>]]></content>
    
    
    <summary type="html">C++ 语法</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="c++" scheme="http://blog.wangeyi.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者模型</title>
    <link href="http://blog.wangeyi.ink/2022/07/18/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.wangeyi.ink/2022/07/18/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-07-18T13:15:02.000Z</published>
    <updated>2022-07-18T13:17:28.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生产者-消费者-问题"><a href="#生产者-消费者-问题" class="headerlink" title="生产者-消费者 问题"></a>生产者-消费者 问题</h3><blockquote><p>生产者进程： 每次生产一个产品放入缓冲区</p><p>消费者进程： 每次从缓冲区中取出一个产品并使用</p><p>（产品 &#x3D;&#x3D; 某种数据）</p></blockquote><ul><li><code>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则等待</code></li><li><code>只有缓冲区不空时，消费者才能从中取出产品。否则等待</code></li><li><code>缓冲区是临界资源，必须互斥访问</code></li></ul><h6 id="如何用信号量的P、V操作实现生产者-消费者问题"><a href="#如何用信号量的P、V操作实现生产者-消费者问题" class="headerlink" title="如何用信号量的P、V操作实现生产者-消费者问题"></a>如何用信号量的P、V操作实现生产者-消费者问题</h6><blockquote><p>分析： </p><ol><li>缓冲区满时，生产者进程必须等待  – 同步问题</li><li>缓冲区为空时，消费者进程必须等待 – 同步问题</li><li>缓冲区时临界资源，互斥方位 – 互斥问题</li></ol><p><code>三对PV操作</code></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semaphore mutes = <span class="number">1</span>;  <span class="comment">// 互斥信号量</span></span><br><span class="line">semaphore empty = n;  <span class="comment">// 同步信号量， 空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;  <span class="comment">// 同步信号量, 非空缓冲区的数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">producer</span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> item = <span class="built_in">produce_item</span>(); <span class="comment">// 生产一个产品</span></span><br><span class="line"><span class="built_in">P</span>(empty); <span class="comment">// 消耗一个空缓冲区</span></span><br><span class="line"><span class="built_in">P</span>(mutex); <span class="comment">// 互斥</span></span><br><span class="line"><span class="built_in">insert_item</span>(item); <span class="comment">// 把产品放入缓冲区</span></span><br><span class="line">        <span class="built_in">V</span>(mutex); <span class="comment">// 互斥</span></span><br><span class="line">        <span class="built_in">V</span>(full);  <span class="comment">//增加一个产品</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">consumer</span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">P</span>(full); <span class="comment">// 消耗一个产品</span></span><br><span class="line"><span class="built_in">P</span>(mutex); <span class="comment">// 互斥</span></span><br><span class="line"><span class="type">int</span> item = <span class="built_in">remove_item</span>();</span><br><span class="line"><span class="built_in">consume_itme</span>(item);</span><br><span class="line">        <span class="built_in">V</span>(mutex); <span class="comment">// 互斥</span></span><br><span class="line"><span class="built_in">V</span>(empty); <span class="comment">// 增加一个空闲缓冲区 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现互斥的P操作一定要在实现同步的P操作之后。</li><li>两个V操作顺序可以交换</li></ul><h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h5><p>设置一个COUNT 计数器来记录当前正在访问共享文件的进程数，</p><p>利用互斥信号量实现对count变量的检查和赋值不会被中断</p><blockquote><ol><li>允许多个读者同时对文件执行读操作</li><li>只允许一个写进程往文件中写信息</li><li>任一写进程在完成写操作之前，不允许其他读进程或写进程工作</li><li>写进程执行写操作之前，应让已有的读写进程全部退出</li></ol><p>分析：</p><ol><li>写进程之间互斥、写进程与读进程之间互斥   </li><li>读进程之间不互斥</li><li>读进程互斥访问count</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semaphore rw =<span class="number">1</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">//读进程互斥访问count</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前几个读进程在访问文件</span></span><br><span class="line"><span class="built_in">writer</span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">p</span>(rw);</span><br><span class="line"><span class="comment">//写文件</span></span><br><span class="line"><span class="built_in">v</span>(rw);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reader</span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">p</span>(mutex);</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">p</span>(rw); <span class="comment">// 第一个读进程负责 “加锁” </span></span><br><span class="line">         count ++;</span><br><span class="line"><span class="built_in">v</span>(mutex);</span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="built_in">p</span>(mutex);</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">v</span>(rw); <span class="comment">// 最后一个读进程负责解锁</span></span><br><span class="line">        <span class="built_in">v</span>(mutex);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读者优先 ， 写进程可能会饥饿</span></span><br><span class="line">semaphore w = <span class="number">1</span>; <span class="comment">// 用于实现写优先</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="http://picgo.wangeyi.ink/image-20220716204845429.png" alt="image-20220716204845429" style="zoom: 50%;" /><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><blockquote><p>管程：特殊的软件模块</p><pre><code>1. 局部于管程的共享数据结构说明。 // 临界资源（进程之间共享的数据）1. 对于该数据结构进行操作的`一组过程`。 //“函数”1. 对共享数据设置`初始值`的语句1. 管程有一个名字。</code></pre><p>“ 类似于类class”</p><p>基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问。</li><li>进程只能通过调用管程的过程才能访问管程的共享数据；</li><li><code>每次只允许一个进程在管程内执行某个管程过程。</code><ol><li>这种互斥特性是由编译器实现的</li></ol></li></ol><p>管程引入了   <strong>条件变量</strong>   以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220717172300260.png" alt="image-20220717172300260"></p><p>管程实现生产者-消费者问题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer </span><br><span class="line">    condition full, empty: <span class="comment">//交件交量用来实现同步（排队) ，条件变量</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//级冲区中的产品数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(Item item)</span> </span>&#123; <span class="comment">//把产品item放人續冲区 </span></span><br><span class="line">        <span class="keyword">if</span> (count == N)    <span class="comment">// 缓冲区满，</span></span><br><span class="line">            <span class="built_in">wait</span> (full); </span><br><span class="line">        count++: </span><br><span class="line">        <span class="built_in">insert_item</span> (item); </span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>)   <span class="comment">// 唤醒等待在empty 队列的进程</span></span><br><span class="line">            <span class="built_in">signal</span>(empty); </span><br><span class="line">    &#125; </span><br><span class="line"><span class="function">Item <span class="title">remove</span> <span class="params">()</span> </span>&#123; <span class="comment">//从银冲区中成盛一个产品 </span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) </span><br><span class="line">            <span class="built_in">wait</span> (empty); </span><br><span class="line">        count--; </span><br><span class="line">        <span class="keyword">if</span> (count == N<span class="number">-1</span>)  <span class="comment">// 缓冲区为满 唤醒生产者</span></span><br><span class="line">            <span class="built_in">signal</span>(full); </span><br><span class="line">        <span class="keyword">return</span> remove item):</span><br><span class="line">    &#125;</span><br><span class="line">end monitor;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">PV操作</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="os" scheme="http://blog.wangeyi.ink/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>进程同步与互斥</title>
    <link href="http://blog.wangeyi.ink/2022/07/16/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/"/>
    <id>http://blog.wangeyi.ink/2022/07/16/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/</id>
    <published>2022-07-16T13:28:15.000Z</published>
    <updated>2022-07-16T13:30:15.416Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><blockquote><p>异步性： 各并发执行的进程以各自独立的、不可预知的速度向前推进</p><p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系</p></blockquote><h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><blockquote><p>多个进程在同一时刻只有一个进程能进入临界区。</p></blockquote><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">// entry section  进入区 ： 设置正在访问临界资源的标志，（上锁）</span><br><span class="line">// critical section; 临界区</span><br><span class="line">// exit section 退出区 解除正在访问临界资源标志（解锁）</span><br></pre></td></tr></table></figure><h6 id="进程互斥遵循的原则"><a href="#进程互斥遵循的原则" class="headerlink" title="进程互斥遵循的原则"></a>进程互斥遵循的原则</h6><p><img src="http://picgo.wangeyi.ink/image-20220715202520230.png" alt="image-20220715202520230"></p><h6 id="互斥的软件实现"><a href="#互斥的软件实现" class="headerlink" title="互斥的软件实现"></a>互斥的软件实现</h6><ul><li><p>单标志法</p><p><img src="http://picgo.wangeyi.ink/image-20220715204014338.png" alt="image-20220715204014338"></p><p><code>违背 “空闲让进原则”</code>：如果此时允许进入临界区的是p0，但是p0一直不访问临界区，则临界区空闲时，不允许p1访问。</p></li><li><p>双标志法</p><p><img src="http://picgo.wangeyi.ink/image-20220715204207407.png" alt="image-20220715204207407"></p><p><code>违背忙着等待</code>：进入区的 检查 和 上锁 两个处理不是 原子性的， “上锁之前”可能发生进程切换</p></li><li><p>双标志后检查： 先上锁、后检查</p><p><img src="http://picgo.wangeyi.ink/image-20220715204411613.png" alt="image-20220715204411613"></p><p><code>违背“空闲让进，有限等待”</code></p></li><li><p>peterson （皮特森）算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">boolean flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procedure0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;   <span class="comment">// 表示进程0 想进入临界区</span></span><br><span class="line">        <span class="comment">//调度关系有可能 flag[0] = flag[1] = true;  标记法可能出现 死锁</span></span><br><span class="line">turn=<span class="number">1</span>;<span class="comment">//可以优先让进程1 进入临界区//原子 </span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]&amp;&amp;turn==<span class="number">1</span>) <span class="comment">/*若flag[1]为false，P0就进入临界区；若flag[1]为tureP0循环等待，只要P1退出临界区，P0即可进入*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* donothing*/</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 进入区</span></span><br><span class="line"><span class="built_in">visit</span>();<span class="comment">/*访问临界区*/</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;<span class="comment">/*访问临界区完成，procedure0释放出临界区*/</span></span><br><span class="line"><span class="comment">/*remainder section*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procedure1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">turn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]&amp;&amp;turn==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* donothing*/</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">visit</span>();<span class="comment">/*访问临界区*/</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;<span class="comment">/*访问临界区完成，procedure1释放出临界区*/</span></span><br><span class="line"><span class="comment">/*remainder section*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">flag[<span class="number">0</span>]=flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*start procedure0 and procedure1*/</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="互斥的硬件实现"><a href="#互斥的硬件实现" class="headerlink" title="互斥的硬件实现"></a>互斥的硬件实现</h6><ul><li><p>中断屏蔽</p><p>利用 “ 开&#x2F;关中断指令” 实现</p><p><code>简单、高效</code>， 不适用于多处理机，不适用于用户进程</p></li><li><p>TS <code>TestandSetLock</code> 指令</p><p>把 “上锁” 和 “检查” 操作用硬件的方式编程原子操作。</p><p><img src="http://picgo.wangeyi.ink/image-20220715210233138.png" alt="image-20220715210233138"></p></li><li><p>swap 指令 <code>EXCHANGE XCHG</code></p><p><img src="http://picgo.wangeyi.ink/image-20220715210223366.png" alt="image-20220715210223366"></p></li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><blockquote><p>信号量：其实就是一个变量（可以是整数、也可以是更为复杂的记录型变量），表示系统中某种资源的数量。</p><pre><code> 1. 可以用一对`原语` ： wait(S) , signal(S)  操作信号量， `括号里的信号量S 其实就是传入函数的一个参数`。 2.  wait(S) , signal(S)   -&gt;  P （消费资源）和 V （产生）操作. 3. wait(S)  相当于进入区 4. signal(S)  相当于退出区</code></pre></blockquote><h6 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h6><ul><li><p>整数型的变量作为信号量， 表示系统中的某种资源的数量。<code>信号量的操作只有三种： 初始化、P操作，v操作</code></p><p><code>不满足 “让权等待，会出现“忙等”</code></p></li></ul><h6 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h6><ul><li><p>记录型数据结构表示的信号量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">semaphore</span> &#123; <span class="comment">// 信号量</span></span><br><span class="line"><span class="type">int</span> value; <span class="comment">//资源个数</span></span><br><span class="line">PCB *queue;  <span class="comment">//信号量上的进程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P</span>(semaphore S) &#123;   <span class="comment">// 消费资源</span></span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(s.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">sleep</span>(s.queue);  <span class="comment">// 使进程进入阻塞态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">V</span>(semaphore S) <span class="comment">// 产生资源</span></span><br><span class="line">&#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span>(s.value &lt;= <span class="number">0</span>) <span class="comment">// 表示等待队列中 还有进程在等待资源</span></span><br><span class="line">        <span class="built_in">wakeup</span>(s.queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h6><blockquote><p>互斥量： 信号量的值只能取 <code>1</code> 或  0  </p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex); <span class="comment">// P 操作</span></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex); <span class="comment">// v 操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h6><blockquote><p>让各并发进程按要求有序地推进</p><p>设置同步信号量 的 初始值 为 0</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220716193654857.png" alt="image-20220716193654857"></p>]]></content>
    
    
    <summary type="html">os</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="os" scheme="http://blog.wangeyi.ink/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>进程调度</title>
    <link href="http://blog.wangeyi.ink/2022/07/14/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>http://blog.wangeyi.ink/2022/07/14/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</id>
    <published>2022-07-14T13:25:33.000Z</published>
    <updated>2022-07-21T08:21:00.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h3><blockquote><p>确定某些规则和决定处理任务的顺序</p></blockquote><h5 id="进程的七状态模型"><a href="#进程的七状态模型" class="headerlink" title="进程的七状态模型"></a>进程的七状态模型</h5><ul><li>挂起态：暂时调到外存等待的进程状态<ul><li>就绪挂起</li><li>阻塞挂起</li></ul></li><li><img src="http://picgo.wangeyi.ink/image-20220713213825314.png" alt="image-20220713213825314"></li></ul><h6 id="三种调度模型"><a href="#三种调度模型" class="headerlink" title="三种调度模型"></a>三种调度模型</h6><blockquote><p>一、处理机调度的层次</p><ol><li><code>高级调度（作业调度 / 长程调度）</code><br>调度对象： 作业</li></ol><blockquote><p>功能： 根据某种算法，将<code>后备队列</code>中的某些作业调入内存，为它们创建进程、分配必要资源，并放入就绪队列。</p><p>调度间隔为几秒或几分钟，不如进程调度频繁，因此也称为长程（long-term）调度。</p></blockquote><p>决定了多道批处理系统中的道数。</p><ol start="2"><li><code>低级调度（进程调度 / 短程调度）</code><br>调度对象： 进程（或内核级线程）</li></ol><blockquote><p>功能： 根据某种算法，决定就绪队列中的哪个进程应获得处理机，并将处理机分配给该进程。</p><p>调度间隔为几毫秒甚至更短，因此也称为短程（short-term）调度。</p></blockquote><ol start="3"><li><code>中级调度（内存调度 / 中程调度）（换入换出）</code><br>调度对象： 进程（）</li></ol><blockquote><p>功能：<br>换出： 将那些暂时不能运行的进程，调至外存等待（挂起）；<br>换入： 当条件具备时，再将它们重新调入内存，修改为就绪状态。</p><p>目的： 提高内存利用率和系统吞吐量。</p></blockquote></blockquote><h5 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h5><blockquote><p>需要进行进程调度和切换的情况</p><p>1.主动放弃： 进程正常结束、运行过程中发生异常而终止、进程主动请求阻塞（等待I&#x2F;O）</p><ol start="2"><li>被动放弃：时间片用完（分时系统）、中断处理、被高优先级进程抢占（抢占调度系统中）</li></ol><p>不能进程进程调度</p><ol><li><p>处理中断的过程中，中断处理程序执行过程中</p></li><li><p>进程在操作系统<code>内核程序临界区</code>中</p><img src="http://picgo.wangeyi.ink/image-20220713214710505.png" alt="image-20220713214710505" style="zoom: 50%;" /><ol><li>需要完全屏蔽中断的原子操作过程中</li></ol></li></ol></blockquote><h6 id="调度的方式"><a href="#调度的方式" class="headerlink" title="调度的方式"></a>调度的方式</h6><ul><li>非抢占方式：只允许进程主动放弃CPU</li><li>抢占方式：优先处理更紧急的进程，进程执行被中断</li></ul><h6 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h6><ul><li><p>CPU 利用率 ： 指CPU “忙碌”时间占用总时间的比例</p><img src="http://picgo.wangeyi.ink/image-20220713215618372.png" alt="image-20220713215618372" style="zoom:50%;" /></li><li><p>系统吞吐量： 单位时间内完成作业的数量</p><img src="http://picgo.wangeyi.ink/image-20220713215717667.png" alt="image-20220713215717667" style="zoom:50%;" /></li><li><p>周转时间： 指从<code>作业被提交到系统</code>，到作业完成为止的<code>时间间隔</code></p><ul><li><p>在外存中等待<code>作业调度</code>的时间</p></li><li><p>进程在就绪队列中等待<code>进程调度</code>的时间</p></li><li><p>进程在CPU中执行的时间</p></li><li><p>进程等待I&#x2F;O操作的时间</p><p><img src="http://picgo.wangeyi.ink/image-20220713220043811.png" alt="image-20220713220043811"></p></li><li><p><img src="http://picgo.wangeyi.ink/image-20220713220125949.png" alt="image-20220713220125949"></p></li><li><p>带权周转时间： &gt;&#x3D; 1 , 带权周转时间越小越好</p><p><img src="http://picgo.wangeyi.ink/image-20220713220208743.png" alt="image-20220713220208743"></p></li></ul></li><li><p>等待时间：指进程、作业处于等待处理机状态时间之和。</p><ul><li>等待IO完成的时间是<code>不计入等待时间</code>中的</li></ul></li><li><p>响应时间：<u>用户从提交请求到首次产生响应所用的时间。</u></p></li></ul><h6 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h6><ul><li><p>先来先服务（FCFS）： 按照请求的顺序进行调度</p><p><code>非抢占式的调度算法， FCFS 对于长作业有利，对短作业不利</code>： 短作业必须等待前面的长作业完成才能执行，等待时间过长。</p></li><li><p>短作业优先（SJF- shortest job first）：按估计允许时间最短的顺序进行调度，  每次调度选择当前已经到达且运行时间最短的 作业&#x2F;进程</p><p><code>非抢占式的调度算法 , 对短作业有利、对长作业不利</code>：</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。</p></li><li><p>最短剩余时间优先算法 shortest remaining time next（SRTN）</p><p><code>最短作业优先的抢占式版本</code></p><p>每当有新进程加入<code>就绪队列</code> 就需要调度，进程完成时也需要进行调度</p><p>如果新达到的进程<code>剩余运行时间</code> 比当前运行的进程的剩余时间<code>更短</code>， 则新进程 <code>抢占CPU</code></p></li><li><p>高响应比优先算法（HRRN, Highest Response Ratio Next）</p><p>每次调度时先计算各个作业进程的响应比，选择响应比高的进程</p><p><img src="http://picgo.wangeyi.ink/image-20220714203623890.png" alt="image-20220714203623890"></p><p><code>非抢占式调度算法</code></p></li></ul><hr><ul><li><p>时间片轮转调度算法（RR）</p><p>按照各进程到达<code>就绪队列</code>顺序（FCFS），轮流让各个进程执行一个时间片，时间片用完时，由<code>计时器发出时钟中断</code>，调度程序停止该进程的执行，将进程重新放入就绪队列的队尾，时间片分配给队首的进程。</p><p><code>抢占式调度算法</code></p><blockquote><p>优缺点</p><p>公平，响应快，适用于分时操作系统，</p><p>高频率的进程切换，有一定的开销，不能够区分任务的紧急程度。</p></blockquote><p>时间片轮转调度算法的效率 和<code>时间片的大小</code> 有很大的关系：</p><ul><li>时间片太小：由于进度切换都要保存进程的信息和载入新的进程信息，进程切换太频繁，在进程切换上会花过多时间</li><li>时间片太大：退化外先来先服务调度，会增大进程的响应时间，实时性得不到保证。</li></ul></li><li><p>优先级调度算法   </p><p>为每个进程分配一个优先级，按优先级进行调度。</p><p><img src="http://picgo.wangeyi.ink/image-20220714211209575.png" alt="image-20220714211209575"></p><blockquote><p>静态优先级： 创建进程时确定，之后一直不变</p><p>有可能导致低优先级进行饥饿</p><p>动态优先级： 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级</p></blockquote><p><code>非抢占式</code> ： 进程主动放弃处理机的时候进行调度</p><p><code>抢占式</code> ： 就绪队列发生改变，判断是否发生抢占</p></li><li><p>多级反馈队列调度算法</p><p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。</p><p>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片未结束，则进程进入下一级队列队尾。</p><p>如果此时己经在最下级的队列，则重新放回 队列队尾</p><p> 只有第k级队列为空时， 才会为k+1 级队头的进程分配时间片。</p><p>被抢占处理机的进程重新放回原队列队尾</p><blockquote><p>优缺点</p><p>对各类型进程相对公平（FCFS）</p><p>新到达的进程都可以得到很快的 响应 RR</p><p>短进程等待时间短</p><p>有可能导致饥饿</p></blockquote><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/操作系统-6-1.png" style="zoom:50%;" /><p><code>抢占式调度算法</code>。</p></li></ul>]]></content>
    
    
    <summary type="html">进程知识</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="os" scheme="http://blog.wangeyi.ink/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>进程？</title>
    <link href="http://blog.wangeyi.ink/2022/07/13/%E8%BF%9B%E7%A8%8B%EF%BC%9F/"/>
    <id>http://blog.wangeyi.ink/2022/07/13/%E8%BF%9B%E7%A8%8B%EF%BC%9F/</id>
    <published>2022-07-13T13:17:24.000Z</published>
    <updated>2022-07-19T05:10:06.769Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>引起进程创建的事件： 用户登陆、作业调度、提供服务、应用请求。</p></blockquote><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><blockquote><p>程序段、数据段、PCB 三部分组成了<code>进程实体</code>，简称为进程，PCB是进程存在的唯一标志</p><blockquote><p>进程是进程实体的<code>运行过程</code>，是系统进行资源分配和调度的一个独立单位。</p></blockquote></blockquote><ul><li>PCB (进程控制块) </li><li>是进程存在的唯一标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级、CPU现场保护区（用于进程切换），占有的资源清单等。<img src="http://picgo.wangeyi.ink/image-20220711201917644.png" alt="image-20220711201917644"></li></ul><h5 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h5><ul><li>链接方式：<ol><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向各个队列的指针<img src="http://picgo.wangeyi.ink/image-20220711202351484.png" alt="image-20220711202351484" style="zoom:50%;" /></li></ol></li><li>索引方式：<br>1. 根据进程状态的不同，建立几张索引表<br>2. 操作系统持有指向各个索引的指针<br>3. <img src="http://picgo.wangeyi.ink/image-20220711202407084.png" alt="image-20220711202407084" style="zoom:50%;" /></li></ul><h5 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h5><blockquote><p>动态性、并发性、独立性、异步性、结构性</p></blockquote><p><code>进程最基本的特征：动态性</code>，进程是程序的一次执行过程，是动态产生、变化和消亡的。</p><p><img src="http://picgo.wangeyi.ink/image-20220711203050666.png" alt="image-20220711203050666"></p><h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><h6 id="三态模型："><a href="#三态模型：" class="headerlink" title="三态模型："></a>三态模型：</h6><p><img src="https://s2.ax1x.com/2019/03/31/AryWDI.png" alt="img"></p><ul><li>运行态： 进程占有处理器，正在运动</li><li>就绪态：具备运行条件，等待系统调度</li><li>阻塞态： 不具备运行条件，等待资源</li><li>切换：<ul><li>运行态-&gt;阻塞态： 等待使用资源，如外设传输</li><li>阻塞态-&gt;就绪态：得到等待的资源</li><li>运行态-&gt;就绪态： 时间片用完；出现更高优先权进程</li><li>就绪态-&gt;运行态：进程调度选择一个就绪进程</li></ul></li></ul><h6 id="另外两种状态"><a href="#另外两种状态" class="headerlink" title="另外两种状态"></a>另外两种状态</h6><ul><li>创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB</li><li>终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源，撤销PCB</li></ul><p><img src="http://picgo.wangeyi.ink/image-20220711203857710.png" alt="image-20220711203857710"></p><h6 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h6><ul><li>创建态-&gt; 就绪态： 系统完成创建进程的一系列工作</li><li>就绪态-&gt;运行态:  进程被调度</li><li>运行态-&gt;就绪态： 时间片用完，或CPU被高优先级进程抢占</li><li>运行态-&gt; 阻塞态：进程使用系统调用申请资源，或请求等待某事件发生 （主动行为：进程自身做出的）</li><li>阻塞态-&gt;就绪态:  申请的资源被分配、等待的事件发生（被动行为）</li><li>运行态-&gt;终止态： 进程运行结束、运行过程中遇到不可修复的错误。</li></ul><blockquote><p>不能由阻塞态直接转换为运行态， 只有就绪态才能被调度</p><p>不能由就绪态直接转换为阻塞态，因为进入阻塞态是一种主动请求（请求系统资源），而就绪态的进程没有分配到处理器资源，不能发出一些主动请求。</p></blockquote><h5 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h5><ul><li>进程控制？， 实现进程状态的转换，用<code>原语</code>实现进程控制</li></ul><blockquote><p>原语：特点是执行期间不允许中断，”不可被中断“的操作称为原子操作</p><p>采用 ”<code>关中断指令</code>“ 和 ”<code>开中断指令</code>“ 实现的</p></blockquote><table><thead><tr><th>更新PCB信息</th><th>修改进程状态标志、保存和恢复运行环境到&#x2F;从PCB</th></tr></thead><tbody><tr><td></td><td>所有进程控制原语一定会修改进程状态标志</td></tr><tr><td>将PCB插入合适的队列</td><td></td></tr><tr><td>分配&#x2F;回收资源</td><td></td></tr></tbody></table><ul><li>创建原语、撤销原语（运行态-|就绪|阻塞-&gt;终止态），</li><li>阻塞原语（运行态-&gt;阻塞态），唤醒原语（阻塞态-&gt;就绪态）<code>阻塞和唤醒要成对出现</code></li><li>切换原语： （运行态-&gt; 阻塞态|就绪态， 就绪态-&gt; 运行态）</li></ul><h5 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h5><blockquote><p>进程之间的信息交换</p><p>各进程拥有的内存地址空间相互独立</p><p>不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同</p><p>进程间可以共享的数据有以下几类 ：程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p></blockquote><p><code>共享存储、消息传递、管道通信</code></p><h6 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h6><blockquote><p> 不同的进程可以将同一个内存页面连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址</p></blockquote><ul><li>共享内存在各种进程间通信方式中具有最高的效率，访问共享内存区域和访问进程独有的内存区域一样快，并不需要通过系<strong>统调用或者其它需要切入内核的过程</strong>来完成</li></ul><h6 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h6><blockquote><p>管道：用于连接读写进程的一个共享文件、在内存中开辟的一个大小固定的缓冲区</p></blockquote><ul><li>匿名管道<ul><li>特殊的文件，只存在于内存中</li><li>只能用于父子进程、兄弟进程之间，必须用于具有亲缘关系的进程间的通信</li><li>半双工</li></ul></li><li>有名管道：<ul><li>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</li><li>有名管道可以在不具有亲缘关系的进程间进行通信。</li></ul></li><li>管道不适合进程间频繁地交换数据</li></ul><h6 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h6><blockquote><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</p></blockquote><p>进程通过操作系统提供的 ”发送消息、接收消息“两个原语进行数据交换 </p><h6 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h6><blockquote><p> 信号量是一个计数器，可以用来控制多个进程对共享资源的访问</p></blockquote><ul><li><p>控制信号量有两种原子操作：</p><ul><li>一个是<code>P操作</code>，这个操作会把信号量减去1，相减后如果信号量&lt;0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量&gt;&#x3D;0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是<code>V操作</code>，这个操作会把信号量加上1，相加后如果信号量&lt;&#x3D;0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量&gt;0，则表明当前没有阻塞中的进程。</li></ul><blockquote><p>P操作是用在进入共享资源之前，V操作是用在离开共享资源之后，这两个操作是必须成对出现的</p></blockquote></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>线程是一个基本的CPU执行单元，是程序执行的基本单位</p><p><code>内核级线程才是处理器分配的单位</code></p><p>进程是资源分配的基本单元</p></blockquote><p>进程与线程的区别</p><ol><li><code>定义</code>：进程是资源分配的最小单位、线程是程序执行的最小单位</li><li><code>内存分配</code>： 进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。</li><li><code>通信</code>：进程之间的通信需要借助操作系统，线程可以直接读写进程<code>数据段</code>（如全局变量）进行通信</li><li><code>系统开销</code> ： <ol><li>进程切换需要切换虚拟地址空间、切换内核栈和硬件上下文，页表切换等，开销较大。</li><li>线程切换 只需保存少量寄存器内容，开销较小。</li></ol></li></ol><ul><li><p>一个进程可以创建几个线程？</p><p>一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，</p><p>过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。</p></li></ul>]]></content>
    
    
    <summary type="html">进程知识</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="os" scheme="http://blog.wangeyi.ink/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://blog.wangeyi.ink/2022/07/07/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blog.wangeyi.ink/2022/07/07/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-07T06:48:16.000Z</published>
    <updated>2022-07-14T13:30:51.577Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>平衡二叉树（AVL树），满足以下性质的二叉搜索树：</p><ol><li>可以是空树</li><li>若不是空树，则其左右两个子树的高度差的<strong>绝对值不超过1</strong>， 且左右两个子树都是平衡二叉树</li></ol><blockquote><p>解决二叉搜索树退化成链表的问题，插入、查找、删除的时间复杂度好情况和最坏情况都维持在O(logN)。</p></blockquote><h4 id="平衡二叉树的-“旋转-”"><a href="#平衡二叉树的-“旋转-”" class="headerlink" title="平衡二叉树的 “旋转 ”"></a>平衡二叉树的 “旋转 ”</h4><ul><li>在下图平衡二叉树插入新结点 <code>99</code> ：</li></ul><p><img src="http://picgo.wangeyi.ink/v2-2ddb0f9b832fff594e294dffc299b373_b.webp" alt="动图"></p><p>结点66 的左子树高度为1，右子树高度为3，<strong>平衡因子</strong>为 2，树失衡。结点66称为最小失衡树。</p><blockquote><p>最小失衡树： 在新插入的结点向上查找，以第一个平衡因子的绝对值大于1的结点为根的子树。</p></blockquote><p>平衡二叉树的失衡调整就是通过<strong>旋转</strong>最小失衡树实现的 ，有左旋、右旋两种处理方式。</p><h5 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h5><p>旋转的目的是降低树的高度，上图右子树的高度大于左子树，因此往左旋转以降低右子树的高度。</p><ul><li><p>左旋的流程为：</p><ul><li><p>找到最小失衡树</p></li><li><p>用该结点的右孩子代替该结点</p></li><li><p>右孩子的左子树作为该结点的右子树</p></li><li><p>节点本身成为右孩子的左子树</p><img src="http://picgo.wangeyi.ink/v2-db1cdb0da952a71f9b6d64b2608467eb_b.jpg" alt="动图封面" style="zoom: 50%;" /></li></ul></li></ul><h5 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h5><p>与左旋类似</p><ul><li>找到最小失衡树</li><li>用该结点的左孩子代替该结点</li><li>左孩子的右子树作为该结点的左子树</li><li>节点本身成为左孩子的右子树</li></ul><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>假设一颗 AVL 树的某个节点为 A，四种不同的插入操作会导致节点A失衡，有以下四种情况：</p><table><thead><tr><th></th><th>描述</th><th>旋转方式</th></tr></thead><tbody><tr><td><img src="http://picgo.wangeyi.ink/20191229165610778.png" alt="img" style="zoom: 50%;" /></td><td>LL : 在A左孩子的左子树插入新节点</td><td>右旋</td></tr><tr><td><img src="http://picgo.wangeyi.ink/20191229173015599.png" alt="img" style="zoom:50%;" /></td><td>RR : 在A右孩子的右子树插入节点</td><td>左旋</td></tr><tr><td><img src="http://picgo.wangeyi.ink/20191229174410251.png" alt="img" style="zoom: 50%;" /></td><td>LR:  在A左孩子的右子树插入节点</td><td>先左旋后右旋</td></tr><tr><td><img src="http://picgo.wangeyi.ink/20191229175624726.png" alt="img" style="zoom:50%;" /></td><td>RL : 在A右孩子的左子树插入节点</td><td>先右旋后左旋</td></tr></tbody></table><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> depth; <span class="comment">//深度，这里计算每个结点的深度，通过深度的比较可得出是否平衡</span></span><br><span class="line"></span><br><span class="line">    Tree parent; <span class="comment">//该结点的父节点</span></span><br><span class="line"></span><br><span class="line">    ElementType val; <span class="comment">//结点值</span></span><br><span class="line"></span><br><span class="line">    Tree lchild;</span><br><span class="line"></span><br><span class="line">    Tree rchild;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVLNode</span>(<span class="type">int</span> val=<span class="number">0</span>) &#123;</span><br><span class="line">        parent = <span class="literal">NULL</span>;</span><br><span class="line">        depth = <span class="number">0</span>;</span><br><span class="line">        lchild = rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//LL型调整函数</span></span><br><span class="line"><span class="comment">//返回:新父节点</span></span><br><span class="line"><span class="function">Tree <span class="title">LL_rotate</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//node为离操作结点最近的失衡的结点</span></span><br><span class="line">    Tree parent=<span class="literal">NULL</span>,son;</span><br><span class="line">    <span class="comment">//获取失衡结点的父节点</span></span><br><span class="line">    parent=node-&gt;parent;</span><br><span class="line">    <span class="comment">//获取失衡结点的左孩子</span></span><br><span class="line">    son=node-&gt;lchild;</span><br><span class="line">    <span class="comment">//设置son结点右孩子的父指针</span></span><br><span class="line">    <span class="keyword">if</span> (son-&gt;rchild!=<span class="literal">NULL</span>)  son-&gt;rchild-&gt;parent=node;</span><br><span class="line">    <span class="comment">//失衡结点的左孩子变更为son的右孩子</span></span><br><span class="line">    node-&gt;lchild=son-&gt;rchild;</span><br><span class="line">    <span class="comment">//更新失衡结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(node);</span><br><span class="line">    <span class="comment">//失衡结点变成son的右孩子</span></span><br><span class="line">    son-&gt;rchild=node;</span><br><span class="line">    <span class="comment">//设置son的父结点为原失衡结点的父结点</span></span><br><span class="line">    son-&gt;parent=parent;</span><br><span class="line">    <span class="comment">//如果失衡结点不是根结点，则开始更新父节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son</span></span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;lchild==node)&#123;</span><br><span class="line">            parent-&gt;lchild=son;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//父节点的右孩子是失衡结点</span></span><br><span class="line">              parent-&gt;rchild=son;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置失衡结点的父亲</span></span><br><span class="line">    node-&gt;parent=son;</span><br><span class="line">    <span class="comment">//更新son结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(son);</span><br><span class="line">    <span class="keyword">return</span> son;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RR型调整函数</span></span><br><span class="line"><span class="comment">//返回新父节点</span></span><br><span class="line"><span class="comment">// 右旋</span></span><br><span class="line"><span class="function">Tree <span class="title">RR_rotate</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//node为离操作结点最近的失衡的结点</span></span><br><span class="line">    Tree parent=<span class="literal">NULL</span>,son;</span><br><span class="line">    <span class="comment">//获取失衡结点的父节点</span></span><br><span class="line">    parent=node-&gt;parent;</span><br><span class="line">    <span class="comment">//获取失衡结点的右孩子</span></span><br><span class="line">    son=node-&gt;rchild;</span><br><span class="line">    <span class="comment">//设置son结点左孩子的父指针</span></span><br><span class="line">    <span class="keyword">if</span> (son-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">          son-&gt;lchild-&gt;parent=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//失衡结点的右孩子变更为son的左孩子</span></span><br><span class="line">    node-&gt;rchild=son-&gt;lchild;</span><br><span class="line">    <span class="comment">//更新失衡结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(node);</span><br><span class="line">    <span class="comment">//失衡结点变成son的左孩子</span></span><br><span class="line">    son-&gt;lchild=node;</span><br><span class="line">    <span class="comment">//设置son的父结点为原失衡结点的父结点</span></span><br><span class="line">    son-&gt;parent=parent;</span><br><span class="line">    <span class="comment">//如果失衡结点不是根结点，则开始更新父节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son</span></span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;lchild==node)&#123;</span><br><span class="line">            parent-&gt;lchild=son;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//父节点的右孩子是失衡结点</span></span><br><span class="line">            parent-&gt;rchild=son;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置失衡结点的父亲</span></span><br><span class="line">    node-&gt;parent=son;</span><br><span class="line">    <span class="comment">//更新son结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(son);</span><br><span class="line">    <span class="keyword">return</span> son;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>处理方式分类两大类：</p><blockquote><ol><li><p>RR型和LL型，以被破坏节点为基础进行其反向的旋转即可，即RR型进行左旋，LL型进行右旋。</p></li><li><p>RL型和LR型，先以被破坏节点的LR或RL首字母的节点进行LR或RL首字母旋转，再以被破坏节点为基础进行LR或RL尾字母旋转，</p><ol><li>即RL型先以被破坏节点的R（右）节点为基础进行一次R（右）选，再以被破坏节点为基础进行一次L（左）旋；</li><li>LR旋先以被破坏节点的L（左）节点为基础进行一次L（左）选，再以被破坏节点为基础进行一次R（右）旋</li></ol></li></ol></blockquote><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/m0_37914588/article/details/103754959"> 数据结构之——平衡二叉树（内容详解）_许夜3的博客-CSDN博客_二叉平衡树</a></p><p><a href="https://www.cnblogs.com/zhangbaochong/p/5164994.html">平衡二叉树详解 - zhangbaochong - 博客园 (cnblogs.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/56066942">什么是平衡二叉树（AVL） - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">平衡二叉树</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Binary Tree" scheme="http://blog.wangeyi.ink/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接状态</title>
    <link href="http://blog.wangeyi.ink/2022/06/29/TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.wangeyi.ink/2022/06/29/TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/</id>
    <published>2022-06-28T16:00:40.000Z</published>
    <updated>2022-07-07T09:05:46.313Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><p>“三次握手” ： 交换三个报文段</p><img src="http://picgo.wangeyi.ink/image-20220629000959273.png" alt="image-20220629000959273" style="zoom: 33%;" /><ul><li>​初始状态：客户端和服务器地处于关闭状态（<strong>CLOSE</strong>）, 服务器\客户端进程创建<strong>传输控制块</strong><ul><li>TCP服务器进入监听状态（<strong>LISTEN</strong>）</li></ul></li><li>客户端在<code>打算建立TCP连接时</code>：<ul><li>向服务器发送请求连接报文段（SYN报文）, 报文段中的同步位（SYN）被置为 1，序号字段设置初始值x，SYN报文不能携带数据。</li><li>进入同步以发送状态（<strong>SYN-SENT</strong>）</li></ul></li><li>服务器进程<code>接收到**SYN**报文后</code>：<ul><li>同意连接，向客户端进程发送连接请求确认报文段（SYNACK报文）, 报文段中的同步为（SYN &#x3D; 1）、确认位（ACK &#x3D; 1），序号字段设置初始值y，不能携带数据。</li><li>进入同步以接收状态（SYN-RCVD）</li></ul></li><li>客户端接收到服务器的<code>连接请求确认报文段后</code>：<ul><li>发送普通的确认报文段：ACK &#x3D; 1。</li><li>进入连接以建立状态（ESTABLISHED）。</li></ul></li><li>服务器收到确认报文段后“<ul><li>进入连接以建立状态（ESTABLISHED）。</li></ul></li></ul></li><li><p>为什么是三次握手，二次不行吗？</p><ul><li><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p><ul><li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li><li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ul><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><p>试想如果是用两次握手，则会出现下面这种情况：</p><blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote></li></ul></li><li><p>四次挥手：</p><p><img src="http://picgo.wangeyi.ink/image-20220629194549514.png" alt="image-20220629194549514"></p><ul><li><p>通信双方都能够释放连接</p></li><li><p>客户端发送<code>连接释放报文段</code>(FIN报文)：</p><ul><li>报文中FIN &#x3D; 1，ACK &#x3D; 1。</li><li>进入终止等待1状态（FIN-WAIT-1）</li></ul></li><li><p>服务器接收到连接释放报文段后</p><ul><li>发送普通的<code>确认报文段</code>，ACK &#x3D; 1.</li></ul></li><li><p>此时处于半连接状态： 客户端已经没有要发送的数据、服务器向客户端的连接还未关闭（持续一段时间）</p></li><li><p>客户端接收到确认报文段后：</p><ul><li>进入终止等待2状态（FIN-WAIT-2）</li></ul></li><li><p>服务器发送完数据后，发送连接释放报文段</p><ul><li>进入最后确认报文段(LAST-ACK)</li><li>FIN &#x3D; 1, ACK &#x3D; 1</li></ul></li><li><p>客户端收到连接释放报文段后：</p><ul><li>发送普通的确认报文段,ACK &#x3D; 1.</li><li>进入时间等待状态（TIME-WAIT）</li></ul></li><li><p>服务器收到确认报文段后</p><ul><li>进入关闭状态（CLOSE）</li></ul></li><li><p>时间等待 2MSL 后，客户端进入关闭状态</p></li></ul><blockquote><p>MSL： Maximum Segment Lifetime 最长报文段寿命。</p></blockquote></li><li><p>时间等待2MSL 的意义：</p><ul><li>如果客户端最后一个确认报文丢失，服务器会重传<code>连接释放报文段</code>， 这时如果客户端已经进入关闭状态，不会发送确认报文，导致服务器反复重传<code>连接释放报文段</code>。 –&gt;TIME_WAIT状态就是用来重发可能丢失的ACK报文。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;“三次握手” ： 交换三个报文段&lt;/p&gt;
&lt;img src=&quot;http://picgo.wangeyi.ink/image-20220629000959273.png&quot; alt=&quot;image-20220629000959273&quot; style=&quot;z</summary>
      
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TCP" scheme="http://blog.wangeyi.ink/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>并发编程</title>
    <link href="http://blog.wangeyi.ink/2022/06/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.wangeyi.ink/2022/06/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2022-06-25T12:50:26.000Z</published>
    <updated>2022-06-25T15:17:48.841Z</updated>
    
    <content type="html"><![CDATA[<hr><h6 id="什么是-”并发“"><a href="#什么是-”并发“" class="headerlink" title="什么是 ”并发“"></a>什么是 ”并发“</h6><blockquote><p>指的是多道程序指令快速交替执行，但是同一时刻只有一条指令在执行。-&gt; 宏观多个进程同时执行，微观上并不是同时执行。</p></blockquote><p>区别与 ”并行“</p><blockquote><p>并行：同一时刻有多道程序指令在多个处理器上同时执行，宏观和微观上<strong>都是同时执行</strong>。</p></blockquote><h6 id="三种构造并发程序的方法："><a href="#三种构造并发程序的方法：" class="headerlink" title="三种构造并发程序的方法："></a>三种构造并发程序的方法：</h6><ol><li><p><code>进程：</code></p><p>每个逻辑控制流都是一个进程：<code>运行起来的可执行程序</code> ， 由内核调度维护</p><p>进程有独立的虚拟地址空间：每个进程占有独立的CPU、内存、文件等资源</p><p>独立的虚拟地址空间： 进程之间的通信需要借助操作系统来完成</p></li><li><p><code>I/O 多路复用</code> ： </p></li><li><p><code>线程</code> ： </p><p>运行在<code>单一进程</code>上下文总的逻辑流：  <code>程序执行的基本单位</code> ， 由<strong>内核调度</strong></p><p>共享进程的资源（进程代码段、进程公有数据，进程拥有的资源）</p><p>线程独立的资源 （线程id，寄存器、程序计数器、堆栈）</p></li></ol><h6 id="进程的状态与切换"><a href="#进程的状态与切换" class="headerlink" title="进程的状态与切换"></a>进程的状态与切换</h6><ul><li><p>三态模型：</p><p><img src="https://s2.ax1x.com/2019/03/31/AryWDI.png" alt="img"></p><ul><li>运行态： 进程占有处理器，正在运动</li><li>就绪态：具备运行条件，等待系统调度</li><li>阻塞态： 不具备运行条件，等待资源</li><li>切换：<ul><li>运行态-&gt;阻塞态： 等待使用资源，如外设传输</li><li>阻塞态-&gt;就绪态：得到等待的资源</li><li>运行态-&gt;就绪态： 时间片用完；出现更高优先权进程</li><li>就绪态-&gt;运行态：进程调度选择一个就绪进程</li></ul></li></ul></li></ul><h6 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h6><p><a href="http://picgo.wangeyi.ink/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.pdf">http://picgo.wangeyi.ink/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.pdf</a></p>]]></content>
    
    
    <summary type="html">深入理解计算机操作系统指并发编程</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="os" scheme="http://blog.wangeyi.ink/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>ACM标准输入输出</title>
    <link href="http://blog.wangeyi.ink/2022/06/21/ACM%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://blog.wangeyi.ink/2022/06/21/ACM%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2022-06-21T14:46:24.000Z</published>
    <updated>2022-06-24T13:47:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录： LeetCode上的核心代码题刷多了，遇到标准输入输出的题还是有的吃力，总结一下C++标准输入输出的模板</p></blockquote><h4 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h4><ul><li><p><code>operator &gt;&gt;</code> : 可以从缓冲区<strong>连续</strong>读取数据，数据以分隔符（空格、tab、换行符）分隔，</p><ul><li>若缓冲区中<strong>第一个字符</strong>是空格、tab或换行这些分隔符时，cin&gt;&gt;会将其忽略并清除，继续读取下一个字符。</li><li>cin &gt;&gt; 对字符后面残留在缓冲区的 换行符不做处理。</li><li><code>&gt;&gt;</code> 表达式返回cin流的状态，输入成功：流保持有效状态 , 条件为真。</li></ul></li><li><p><code>cin.get()</code> : 读取<strong>单个</strong>字符</p><ul><li>原型：<ul><li><code>int_type get();</code>  返回ASCII码值，遇到文件结束符（win Ctrl + z，linux ：Ctrl + d） 返回EOF(- 1)。</li><li><code>basic_istream&amp; get( char_type&amp; ch );</code>： 返回对象引用，支持<code>cin.get(b).get(c)</code></li><li>……</li></ul></li><li>从输入缓冲区读取单个字符，不会忽略分隔符。</li></ul></li><li><p>cin.getline() : 读取一串字符串，并以<strong>指定的结束符</strong>结束</p><ul><li><p>原型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">basic_istream&amp; getline( char_type* s, std::streamsize count, char_type delim );</span><br><span class="line">// s : 指向要存储字符的字符串的指针</span><br><span class="line">// count : s所指向的字符串的大小</span><br><span class="line">// delim : 结束字符， 被提取不会被存储</span><br></pre></td></tr></table></figure></li><li><p>分隔符（指定的结束符）有被从缓冲区读取，但 <strong>不会</strong> 存储到接收字符串的字符地址（与<code>cin.get()</code> <strong>不同</strong>）</p></li></ul></li><li><p><code>getline()</code></p><ul><li><p>原型：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::basic_istream&lt;CharT,Traits&gt;&amp; <span class="title">getline</span><span class="params">( std::basic_istream&lt;CharT,Traits&gt;&amp;&amp; input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           std::basic_string&lt;CharT,Traits,Allocator&gt;&amp; str,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           CharT delim )</span></span>;</span><br><span class="line"><span class="comment">//分隔符字符是从 中提取的，但不会追加到str</span></span><br></pre></td></tr></table></figure></li><li><p>和<code>cin.getline()</code>类似，但是<code>cin.getline()</code>属于<code>istream</code>流，而<code>getline()</code>属于string流，是不一样的两个函数</p><p>在遇到需要输入一串带有空格的字符串的时候，要用<code>getline(cin,s),</code>因为 cin&gt;&gt;s，遇到空格就会默认停止。</p></li></ul></li><li><p><code>cin.clear()</code>： 将流的所有状态复位</p></li><li><p><code>cin.ignore()</code> ：从输入流中提取并丢弃字符，直到（包含）结束符</p><ul><li><p>原型：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">basic_istream&amp; ignore（ std：：streamsize count = <span class="number">1</span>， int_type delim = Traits：：eof（） ）;</span><br><span class="line"><span class="comment">//  count</span></span><br><span class="line"><span class="comment">// delim ： 结束符</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="输入输出练习"><a href="#输入输出练习" class="headerlink" title="输入输出练习"></a>输入输出练习</h4><p><a href="https://ac.nowcoder.com/acm/contest/5652">OJ输入输出</a></p><h5 id="A-B"><a href="#A-B" class="headerlink" title="A+B"></a>A+B</h5><h6 id="1-输入包括两个正整数a-b-1-lt-x3D-a-b-lt-x3D-1000-输入数据包括多组，组数不定。"><a href="#1-输入包括两个正整数a-b-1-lt-x3D-a-b-lt-x3D-1000-输入数据包括多组，组数不定。" class="headerlink" title="1. 输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000),输入数据包括多组，组数不定。"></a>1. 输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000),输入数据包括多组，组数不定。</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入包括两个正整数a,b(1 &lt;= a, b &lt;= 1000),输入数据包括多组。</span></span><br><span class="line"><span class="comment">//输出 a + b</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b)</span><br><span class="line">        cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-输入第一行包括一个数据组数t-1-lt-x3D-t-lt-x3D-100-接下来每行包括两个正整数a-b-1-lt-x3D-a-b-lt-x3D-1000"><a href="#2-输入第一行包括一个数据组数t-1-lt-x3D-t-lt-x3D-100-接下来每行包括两个正整数a-b-1-lt-x3D-a-b-lt-x3D-1000" class="headerlink" title="2. 输入第一行包括一个数据组数t(1 &lt;&#x3D; t &lt;&#x3D; 100) ,接下来每行包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000)"></a>2. 输入第一行包括一个数据组数t(1 &lt;&#x3D; t &lt;&#x3D; 100) ,接下来每行包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000)</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t,a,b;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; a + b &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-输入包括两个正整数a-b-1-lt-x3D-a-b-lt-x3D-10-9-输入数据有多组-如果输入为0-0则结束输入"><a href="#3-输入包括两个正整数a-b-1-lt-x3D-a-b-lt-x3D-10-9-输入数据有多组-如果输入为0-0则结束输入" class="headerlink" title="3.输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入"></a>3.输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h6><blockquote><p>输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100), n为0的时候结束输入。<br>接下来n个正整数,即需要求和的每个正整数。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4 1 2 3 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; size) &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(; size &gt; <span class="number">0</span> ; --size) &#123;</span><br><span class="line">            cin &gt;&gt; temp;</span><br><span class="line">            sum += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h6><blockquote><p>输入的第一行包括一个正整数t(1 &lt;&#x3D; t &lt;&#x3D; 100), 表示数据组数。<br>接下来t行, 每行一组数据。<br>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。<br>接下来n个正整数, 即需要求和的每个正整数。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tsize = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; tsize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tsize; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; size;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; size &gt; <span class="number">0</span>; --size) &#123;</span><br><span class="line">            cin &gt;&gt; temp;</span><br><span class="line">            sum += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li></li></ol><blockquote><p>来源：牛客网</p><p>输入数据有多组, 每行表示一组输入数据。</p><p>每行不定有n个整数，空格隔开。(1 &lt;&#x3D; n &lt;&#x3D; 100)。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; temp) &#123;  <span class="comment">//cin&gt;&gt;会将其忽略并清除 空格 ，换行</span></span><br><span class="line">        sum += temp;</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) &#123; <span class="comment">// get 来判断到每一行末尾</span></span><br><span class="line">            cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h4><ol><li></li></ol><blockquote><p>输入有两行，第一行n<br>第二行是n个字符串，字符串之间用空格隔开<br>输出一行排序后的字符串，空格隔开，无结尾空格</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    cin &gt;&gt; size;</span><br><span class="line">    cin.<span class="built_in">ignore</span>(<span class="number">1</span>,<span class="string">&#x27;\n&#x27;</span>);  <span class="comment">// 清除缓冲区上的一个换行符</span></span><br><span class="line">    vector&lt;string&gt; sort_string;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="built_in">getline</span>(cin,temp,<span class="string">&#x27; &#x27;</span>);  <span class="comment">// 以 ’ ‘ 为分隔符提出字符串</span></span><br><span class="line">        sort_string.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sort_string.<span class="built_in">begin</span>(),sort_string.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i)</span><br><span class="line">        cout &lt;&lt; sort_string[i] + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; sort_string[size - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><blockquote><p>多个测试用例，每个测试用例一行。<br>每行通过空格隔开，有n个字符，n＜100</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; temp) &#123;</span><br><span class="line">        vec.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; str : vec) &#123;</span><br><span class="line">                cout &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            vec.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li></li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多个测试用例，每个测试用例一行。</span><br><span class="line">每行通过,隔开，有n个字符，n＜100</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; temp) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(temp)</span></span>;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,str,<span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; vec[i] + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; vec.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/mini-coconut/p/9041925.html">C++中关于输入cin的一些总结 - Mini_Coconut - 博客园 (cnblogs.com)</a></p><p><a href="https://en.cppreference.com/w/cpp/io">Input&#x2F;output library - cppreference.com</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录： LeetCode上的核心代码题刷多了，遇到标准输入输出的题还是有的吃力，总结一下C++标准输入输出的模板&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;cin&quot;&gt;&lt;a href=&quot;#cin&quot; class=&quot;headerlink&quot; title=&quot;cin&quot;&gt;&lt;/a&gt;cin&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;operator &amp;gt;&amp;gt;&lt;/code&gt; : 可以从缓冲区&lt;strong&gt;连续&lt;/strong&gt;读取数据，数据以分隔符（空格、tab、换行符）分隔，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若缓冲区中&lt;strong&gt;第一个字符&lt;/strong&gt;是空格、tab或换行这些分隔符时，cin&amp;gt;&amp;gt;会将其忽略并清除，继续读取下一个字符。&lt;/li&gt;
&lt;li&gt;cin &amp;gt;&amp;gt; 对字符后面残留在缓冲区的 换行符不做处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 表达式返回cin流的状态，输入成功：流保持有效状态 , 条件为真。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;cin.get()&lt;/code&gt; : 读取&lt;strong&gt;单个&lt;/strong&gt;字符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int_type get();&lt;/code&gt;  返回ASCII码值，遇到文件结束符（win Ctrl + z，linux ：Ctrl + d） 返回EOF(- 1)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;basic_istream&amp;amp; get( char_type&amp;amp; ch );&lt;/code&gt;： 返回对象引用，支持&lt;code&gt;cin.get(b).get(c)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从输入缓冲区读取单个字符，不会忽略分隔符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cin.getline() : 读取一串字符串，并以&lt;strong&gt;指定的结束符&lt;/strong&gt;结束&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原型：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;basic_istream&amp;amp; getline( char_type* s, std::streamsize count, char_type delim );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// s : 指向要存储字符的字符串的指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// count : s所指向的字符串的大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// delim : 结束字符， 被提取不会被存储&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分隔符（指定的结束符）有被从缓冲区读取，但 &lt;strong&gt;不会&lt;/strong&gt; 存储到接收字符串的字符地址（与&lt;code&gt;cin.get()&lt;/code&gt; &lt;strong&gt;不同&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;getline()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原型：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;std::basic_istream&amp;lt;CharT,Traits&amp;gt;&amp;amp; &lt;span class=&quot;title&quot;&gt;getline&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( std::basic_istream&amp;lt;CharT,Traits&amp;gt;&amp;amp;&amp;amp; input,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                                           std::basic_string&amp;lt;CharT,Traits,Allocator&amp;gt;&amp;amp; str,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                                           CharT delim )&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//分隔符字符是从 中提取的，但不会追加到str&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;/li&gt;
&lt;li&gt;&lt;p&gt;和&lt;code&gt;cin.getline()&lt;/code&gt;类似，但是&lt;code&gt;cin.getline()&lt;/code&gt;属于&lt;code&gt;istream&lt;/code&gt;流，而&lt;code&gt;getline()&lt;/code&gt;属于string流，是不一样的两个函数&lt;/p&gt;
&lt;p&gt;在遇到需要输入一串带有空格的字符串的时候，要用&lt;code&gt;getline(cin,s),&lt;/code&gt;因为 cin&amp;gt;&amp;gt;s，遇到空格就会默认停止。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;cin.clear()&lt;/code&gt;： 将流的所有状态复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;cin.ignore()&lt;/code&gt; ：从输入流中提取并丢弃字符，直到（包含）结束符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原型：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;basic_istream&amp;amp; ignore（ std：：streamsize count = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;， int_type delim = Traits：：eof（） ）;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  count&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// delim ： 结束符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;输入输出练习&quot;&gt;&lt;a href=&quot;#输入输出练习&quot; class=&quot;headerlink&quot; title=&quot;输入输出练习&quot;&gt;&lt;/a&gt;输入输出练习&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5652&quot;&gt;OJ输入输出&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="c++" scheme="http://blog.wangeyi.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>os</title>
    <link href="http://blog.wangeyi.ink/2022/06/21/os/"/>
    <id>http://blog.wangeyi.ink/2022/06/21/os/</id>
    <published>2022-06-21T12:17:42.000Z</published>
    <updated>2022-08-25T08:57:56.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h1><pre><code>大型的程序系统，负责计算机的全部软、硬资源的***分配与回收，控制与协调并发活动***，实现信息的存取和保护。</code></pre><h2 id="操作系统视频笔记"><a href="#操作系统视频笔记" class="headerlink" title="操作系统视频笔记"></a><a href="%5B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%E6%9D%8E%E6%B2%BB%E5%86%9B%E8%80%81%E5%B8%88%EF%BC%8932%E8%AE%B2%EF%BC%88%E5%85%A8%EF%BC%89%E8%B6%85%E6%B8%85_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1d4411v7u7/?p=2&spm_id_from=pageDriver)">操作系统视频笔记</a></h2><p><em>冯诺依曼</em> 存储程序系统 ： 将程序和数据存放到计算机内部侧存储中，计算机怎么工作的： <strong>取指执行</strong></p><p><img src="http://picgo.wangeyi.ink/image-20220329211604196.png" alt="image-20220329211604196"></p><h4 id="L2"><a href="#L2" class="headerlink" title="L2"></a>L2</h4><p>系统启动时，</p><ul><li>pc 指向0XFFFF0 (ROM BIOS 映射区 | 基本输入输出系统程序)， 检查RAM，键盘，显示器，软硬磁盘硬件。</li><li>然后将  “磁盘0磁道0扇区 (<em>引导扇区</em>)”的512字节的引导启动代码读入到内存0x7c00处</li><li>设置pc 指向 0x7c00</li></ul><blockquote><p>PC是指寄存器PC，它里边的值总是指向当前程序的运行点的地址 </p><p>CS : 代码段寄存器；IP : 指令指针寄存器。在8086机中，任意时刻，CPU将CS:IP指向的内容当作指令来执行。</p><p>PC &#x3D; CS &lt;&lt; 4 + IP</p></blockquote><p>引导扇区： <em>启动设备的第一个扇区</em></p><p>引导启动代码的第一步是：</p><ul><li>把256字节的代码从0x7c00处移动到0x9000处。然后从0x9000处开始运行 （<code>bootsect.s</code>） 。</li><li>BIOS 0x13 中断：读取磁盘扇区的中断读磁盘0磁道0扇区后面的4个setup扇区，把这4个扇区读到0x90200地址处。</li><li>接下来的代码不读磁盘了，而是用10号中断在屏幕上显示加载系统的图片和文字。</li><li>pc指向setup程序的地址继续执行 （<code>setup.s</code>）</li><li>setup程序首先通过15号中断获得内存的大小等硬件参数。<ul><li>然后把从0x9000处所有的操作系统代码移到0地址处。（在物理内存中，操作 系统就存放在低地址中）</li></ul></li><li>set up的最后代码是一条高级指令，<ul><li>它会把 <code>cr0</code> 寄存器的最后一位置1，这样寻址方式从以前的模式转变为保护模式，寻址不再是cs左移4位加上<code>ip</code>地址，而是cs寄存器指向<code>gdt</code>表，找到基地址，然后加上ip寄存器的偏移地址来寻址，这样可以查找更大的空间，以前是寻址空间2的16次方，现在是2的32次方。</li></ul></li><li>接下来跳到system模块去执行，也就是前5个扇区之后的代码处去执行。<br>注意，磁盘上的程序一次是boot–setup–system程序，最终转变到内存中也要是这样的顺序，boot将setup的程序拿到内存，setup将system的程序拿到内存。system程序的开始一定是是head.s文件</li><li>head.s文件会初始化idt和gdt表，这两个表格是寻址用的，以方便保护模式下使用，该模式下很多汇编指令改变，比如mov des  sor 变成<br>mov sor des,32位汇编代码和16位汇编代码不同。整个启动过程用了16位汇编，32位汇编，内嵌汇编三种。\</li><li>最后跳到main（）函数去执行，在main函数里面进行各个模块的初始化工作。前面第6部获得的物理内存大小参数就可以传到一些初始化函数中进行使用。</li></ul><h4 id="L4-操作系统接口"><a href="#L4-操作系统接口" class="headerlink" title="L4 操作系统接口"></a>L4 操作系统接口</h4><blockquote><p>接口： 链接上层应用和操作系统，信号转换。屏蔽具体实现细节</p><p>命令行：本质时一个C语言程序（shell），调用fork(), exec() 对计算机进行使用</p><p>图形按钮: 基于消息机制 </p><p>连接操作系统和应用软件</p></blockquote><ul><li>操作系统接口：  表现为函数调用，***<u>（系统调用 SYSTEM_CALL）</u>***<ul><li>操作系统与应用程序之间的接口 （ 汇编语言实现 | 高级语言需提供调用汇编程序的接口）</li></ul></li></ul><h4 id="L5-系统调用的实现"><a href="#L5-系统调用的实现" class="headerlink" title="L5 系统调用的实现"></a>L5 系统调用的实现</h4><blockquote><p>系统调用： 不能随意调用数据|jmp </p><p>将 内核程序和用户程序***<u>隔离</p><blockquote><p></u>***</p></blockquote><ul><li>内核态： 可以访问任何数据</li><li>用户态：不能访问内核数据</li></ul></blockquote><ul><li><p><strong>调用门与特权级</strong></p><ul><li>特权级：较为核心的代码和数据放在特权级高得层级中，避免底层级得任务方位</li><li><img src="http://picgo.wangeyi.ink/image-20220307195425284.png" alt="image-20220307195425284"></li><li>CPL、DPL、RPL<ul><li>CPL代表代码所在的段的特权级。当程序转移到不同特权级的代码段时，处理器将改变CPL。只有0和3两个值，分别表示用户态3和内核态0。</li><li>DPL表示段或门的特权级，它被存储在段描述符或者门描述符的DPL字段中（<a href="http://www.cnblogs.com/chenwb89/p/operating_system_003.html">《操作系统篇-分段机制与GDT|LDT》</a>中有提到），当当前代码段试图访问一个段或者门（这里大家先把门看成跟段一样，下面我们会介绍），DPL将会和CPL以及段或者门选择子的RPL相比较，根据段或者门类型的不同，DPL将会区别对待。</li><li>RPL是通过段选择子的第0和第1位表现出来的。RPL是代码中根据不同段跳转而确定，以动态刷新CS里的CPL，在代码段选择符中。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。操作系统往往用RPL来避免低特权级应用程序访问高特权级段内的数据，即便提出访问请求的段有足够的特权级，如果RPL不够也是不行的，当RPL的值比CPL大的时候，RPL将起决定性作用。也就是说，RPL相当于附加的一个权限控制，只有当RPL&gt;DPL的时候，才起到实际的限制作用。</li></ul></li></ul></li><li><p>主动进入 ”内核 “ 的方法：中断指令（int）</p><ul><li><p>系统调用的核心：</p><ul><li><em><strong>用户程序</strong></em>中包含一段包含int 指令的代码</li><li>操作系统写<em><strong>中断处理</strong></em>，获取想调程序的编号</li><li>操作系统根据编号 <em><strong>执行相应代码</strong></em></li></ul></li><li><p>Linux 实现系统调用指令: <code>int $0x80</code> ： 将控制权转移给内核</p><ul><li>&#96;&#96;&#96;c<br>#define _syscall1(type，name, type1 ,arg1) <br>type name(type1,arg1) { \<br>long _res; \<br>_asm_volatile(“int $0x80”   &#x2F;&#x2F; 表示括号中插入的是汇编代码片段<br>              : “&#x3D;a” (_res)   &#x2F;&#x2F; 返回值放在 寄存器eax中<br>              :”0” (<em>NR</em>##name), “b”((long)(arg1))); \ &#x2F;&#x2F;系统调用名称 NR_name放在eax中， 参数放在寄存器ebx中<br>_syscall_return(type,_res);  &#x2F;&#x2F; 执行结果放在res中并返回调用程序<br>}<br>&#x2F;&#x2F; 例子<br>_syscall1(int,setuid,uid_t,uid)<br>&#x2F;&#x2F;1. 产生的函数返回值为int<br>&#x2F;&#x2F; 2. 产生的函数名称为setuid<br>&#x2F;&#x2F;uid_t 和 uid 指示系统调用需要的参数类型和参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      - `_syscallN()` 宏指令对特定系统调用的N个参数进行扩展</span><br><span class="line">      - ![image-20220309105426358](http://picgo.wangeyi.ink/image-20220309105426358.png)</span><br><span class="line"></span><br><span class="line">#### L8 CPU管理</span><br><span class="line"></span><br><span class="line">&gt; 工作原理：不断地取指执行</span><br><span class="line">&gt;</span><br><span class="line">&gt; 最直观的方法：设置PC好的初值   ——I执行 IO指令 远比 计算指令 慢  -&gt;  CPU效率慢，利用率低   （PC 程序计数器）</span><br><span class="line">&gt;</span><br><span class="line">&gt; 多道程序**交替**执行：**并发**</span><br><span class="line">&gt;</span><br><span class="line">&gt; 进程：（操作系统对一个正在运行的程序的一种抽象） |  （运行中的程序，需要记录程序状态）</span><br><span class="line"></span><br><span class="line">#### L9 多进程图像</span><br><span class="line"></span><br><span class="line">&gt; 多进程推进，操作系统只需要把这些进程记录好、按照合理的次序推进（分配资源、进行调度）</span><br><span class="line">&gt;</span><br><span class="line">&gt; -从启动开始到关节结束</span><br><span class="line"></span><br><span class="line">- 组织多进程： PCB（***Process Control Block***, *进程控制块*）用来记录进程信息的数据结构  放在不同的**队列**中  &lt;a name = PCB&gt;&lt;/a&gt;</span><br><span class="line">- 进程状态图: 给出进程生存期的清晰描述</span><br><span class="line">  - &lt;img src=&quot;http://picgo.wangeyi.ink/image-20220309203939537.png&quot; alt=&quot;image-20220309203939537&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line">  - 运行态：进程正在处理机上运行的状态，该进程已获得必要的资源，</span><br><span class="line">  - 阻塞状态：进程等待某种事件的完成（I/O）,不能参与竞争CPU</span><br><span class="line">  - 就绪状态：等待CPU的状态</span><br><span class="line">- 状态转化：</span><br><span class="line">  - 就绪-运行：进程调度程序(优先级| 时间片) CPU 分配给某个就绪进程</span><br><span class="line">  - 运行-就绪: 进程时间片用完-&gt;系统发出超时中断请求，</span><br><span class="line">  - 运行-阻塞： 运行中的进程需要IO操作</span><br><span class="line">  - 阻塞-就绪：被阻塞的进程获得解除后，变成就绪状态等待CPUI</span><br><span class="line"></span><br><span class="line">- 交替多个进程：队列操作 | 调度 | 切换、</span><br><span class="line">  - 进程调度 ： FIFO 先进先出| Priority 优先级</span><br><span class="line">- 多进程之间的影响：地址空间分离 —— [虚拟内存](#虚拟内存)</span><br><span class="line">- 多进程合作：`多个进程之间共享内存出现混乱的现象`   核心在于进程同步（合理的推进顺序） </span><br><span class="line">  - 总结：</span><br><span class="line">    - 读写PCB [PCB](#PCB)</span><br><span class="line">    - 操作寄存器进行切换  [L10](#L10) [L11](#L11) [L12](#L12)</span><br><span class="line">    - 调度程序 [L14](#L14) [L14](#L14)</span><br><span class="line">    - 进程同步与合作 [L16](#L16)</span><br><span class="line">    - 地址映射 [L20](#L20)</span><br><span class="line"></span><br><span class="line">#### L10 用户级线程 </span><br><span class="line"></span><br><span class="line">&lt;a name = L10&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">- 进程： 资源+ 指令执行序列 ——***一个资源 + 多个指令执行序列*** </span><br><span class="line">- 线程：只切换指令执行序列，不切换资源——保留了并发的优点，避免进程切换的代价</span><br><span class="line">  -  每个线程都有自己的栈</span><br><span class="line">     - TCB (Thread Control Block) :  是与进程的控制块（[PCB](#PCB)）相似的子控制块，只是[TCB](https://baike.baidu.com/item/TCB/5732988)中所保存的线程状态比PCB中保存少而已。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">Create // 创建线程 ：创建线程栈 | TCB 切换的PC在栈中</span><br><span class="line">void create &#123;</span><br><span class="line">    TCB *tcb = malloc();  // 申请TCB </span><br><span class="line">    *stack = malloc();// 申请线程栈</span><br><span class="line">    *stack = A; //100// 线程栈中填入 程序执行的初始地址</span><br><span class="line">    tcb.esp = stack;// 线程栈与TCB g</span><br><span class="line">&#125;</span><br><span class="line">Yield  //  切换 ？？  只需切换线程栈 ，PC(程序计数器） 已经压在栈里了</span><br><span class="line">void Yield() &#123;</span><br><span class="line">    TCB2.esp = esp; //esp 栈指针寄存器， 存线程2的状态</span><br><span class="line">    esp = TCB1.esp； // 切换到线程1</span><br><span class="line">//  jmp 204：  // 不需要jmp</span><br><span class="line">&#125; //--ret, 返回时弹出线程栈1， PC 指向该指令</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="L11-内核级线程"><a href="#L11-内核级线程" class="headerlink" title="L11 内核级线程"></a>L11 内核级线程</h4><p><a name = L11></a>    —— 进程必须是内核级  </p><ul><li><p>与用户级线程的区别</p><ul><li>一套栈： 用户态执行的时候（<em><strong>用户栈</strong></em>）| 内核执行时 （<em><strong>内核栈</strong></em>）</li></ul></li><li><p><em><strong>用户栈 | 内核栈</strong></em>  之间的关联</p><ul><li><p>中断 进入内核时， 内核栈 压入用户栈的 ss sp 、 用户态的指令地址 pc cs  <code>硬件处理</code></p></li><li><blockquote><p>SS:存放栈的段地址；<br>SP:堆栈寄存器SP(stack pointer)存放栈的偏移地址</p></blockquote></li><li><p>中断返回iret， 弹出用户栈和用户态执行指令的地址</p></li></ul></li><li><p>内核栈的切换 ： <code>switch_to</code></p><ul><li>切换 TCB，根据TCB 切换内核栈，执行到某个内核程序，通过中断返回<code>iret</code> 最后切换到用户态执行</li><li>内核线程切换的五段论<ul><li><img src="http://picgo.wangeyi.ink/image-20220310204542607.png" alt="image-20220310204542607"></li></ul></li></ul></li></ul><h4 id="L14-CPU-调度-schedule"><a href="#L14-CPU-调度-schedule" class="headerlink" title="L14 CPU 调度 schedule"></a>L14 CPU 调度 <em>schedule</em></h4><p><a name = L14></a></p><p>” 动态地、合理地把处理机分配给就绪队列中的某一个进程“</p><ul><li><p>CPU调度的目标： </p><ul><li>尽快结素任务： <em><strong>周转时间短</strong></em>（任务进入到任务结束）</li><li>用户操作尽快响应： <em><strong>响应时间短</strong></em>（操作发生到响应）</li><li>系统内耗时间少： <em><strong>吞吐量</strong></em>（完成的任务量）</li></ul></li><li><p>FCFS ( First come, First Served): 按进程先后顺序调度</p></li><li><p>轮转调度 | 分级轮转：按时间片来轮转调度、</p></li><li><p>优先级法：</p><ul><li><p>静态优先级： 进程类型（IO约束型| CPU约束型）、运行时间、作业优先级</p><ul><li>短作业优先 <em><strong>SJF</strong></em> : 运行时间短的作业优先级较高</li></ul></li><li><p><strong>动态优先级：进程的优先级在该进程的生存期间内可以改变 ”折中 综合“</strong> </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/linux <span class="number">0</span> <span class="number">.11</span>/<span class="built_in">schedule</span>() 函数</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Schedule</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        c = <span class="number">-1</span>; next = <span class="number">0</span>; i = NR_TASKS;</span><br><span class="line">      p = &amp;task[NR_TASKS];</span><br><span class="line">    <span class="keyword">while</span>(--i) &#123; </span><br><span class="line">            <span class="keyword">if</span>((*p)-&gt;state == TASK_RUNNIMG &amp;&amp; (*P)-&gt;counter &gt; c)) &#123;    <span class="comment">// 状态就绪 ，counter ： 优先级|时间片</span></span><br><span class="line">                c = (*p)-&gt;counter,next = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(c) <span class="keyword">break</span>;        &#125;<span class="comment">//找到counter 最大的进程 并跳转去执行</span></span><br><span class="line">                 <span class="comment">//修改优先级</span></span><br><span class="line">             <span class="keyword">for</span>(p= &amp;LAST_TASK; P &gt; &amp;FIRST_TASK;--p) &#123;</span><br><span class="line">                 (*p) -&gt; counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) + (*p)-&gt;priority;  <span class="comment">// 设置就绪状态的进程 counter 的初值priority</span></span><br><span class="line">                 <span class="comment">// 阻塞状态的 counter ： priority + (原来的 / 2)   优先级提高： </span></span><br><span class="line">                 <span class="comment">//动态调整优先级</span></span><br><span class="line">             &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">   switch_to(next); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时钟中断里减时间片</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">do_timer</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>((--current-&gt;counter &gt; <span class="number">0</span>)) <span class="keyword">return</span>;</span><br><span class="line">     current-&gt;counter = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">Schedule</span>();   <span class="comment">//时间片用完了 -&gt; 调度</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="L16-进程同步与信号量"><a href="#L16-进程同步与信号量" class="headerlink" title="L16 进程同步与信号量"></a>L16 进程同步与信号量</h4><ul><li><p>进程同步：进程间必须互相合作的协同工作关系。有前后次序的<em><strong>等待</strong></em>关系 </p></li><li><p>信号量： 用于提供不同进程之间或者一个给定的不同线程间<em><strong>同步</strong></em>手段的原语 ： 量用来记录， 信号用来 “sleep、wakeup”</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">semaphore</span> &#123; <span class="comment">// 信号量</span></span><br><span class="line"><span class="type">int</span> value; <span class="comment">//资源个数</span></span><br><span class="line">PCB *queue;  <span class="comment">//信号量上的进程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P</span>(semaphore S) &#123;   <span class="comment">// 消费资源</span></span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(s.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">sleep</span>(s.queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">V</span>(semaphore S) <span class="comment">// 产生资源</span></span><br></pre></td></tr></table></figure><h4 id="L17-信号量的临界区保护"><a href="#L17-信号量的临界区保护" class="headerlink" title="L17 信号量的临界区保护"></a>L17 信号量的临界区保护</h4><ul><li><p>保护：  共同修改信号量，可能 出现 <em><strong>和调度有关的共享数据语义错误</strong></em>（<em><strong>竞争条件</strong></em>）</p></li><li><p>临界区？ ： 一次只允许一个进程进入该进程的  <u><em>那一段代码</em></u>  ： （修改共享数据的地方、读写信号量的代码）</p><ul><li>必须互斥执行的程序段，相对论临界资源的临界区（互斥段）</li><li>临界资源： 某段时间内 <em><strong>只允许一个</strong></em> 进程使用的资源</li></ul></li><li><p>基本原则： <em><strong>互斥进入</strong></em> </p><ul><li>有空让进： 进程要求 进入空闲临界区时，应尽快让进</li><li>有限等待：进程发出请求进入到允许进入不能无限等待</li></ul></li><li><p>“<em>非对称标记</em>” :  Peterson 算法  两个进程</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">boolean flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procedure0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;   <span class="comment">//调度关系有可能 flag[0] = flag[1] = true;  标记法可能出现 死锁</span></span><br><span class="line">turn=<span class="number">1</span>;<span class="comment">//原子 </span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]&amp;&amp;turn==<span class="number">1</span>) <span class="comment">/*若flag[1]为false，P0就进入临界区；若flag[1]为tureP0循环等待，只要P1退出临界区，P0即可进入*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* donothing*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">visit</span>();<span class="comment">/*访问临界区*/</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;<span class="comment">/*访问临界区完成，procedure0释放出临界区*/</span></span><br><span class="line"><span class="comment">/*remainder section*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procedure1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">turn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]&amp;&amp;turn==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* donothing*/</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">visit</span>();<span class="comment">/*访问临界区*/</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;<span class="comment">/*访问临界区完成，procedure1释放出临界区*/</span></span><br><span class="line"><span class="comment">/*remainder section*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">flag[<span class="number">0</span>]=flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*start procedure0 and procedure1*/</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多个进程： <em><strong>面包店算法</strong></em></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// declaration and initial values of global variables</span></span><br><span class="line">    Entering: array [<span class="number">1.</span>.NUM_THREADS] of <span class="type">bool</span> = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    Number: array [<span class="number">1.</span>.NUM_THREADS] of integer = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>  <span class="built_in">lock</span>(integer i) &#123;</span><br><span class="line"> <span class="number">2</span>      Entering[i] = <span class="literal">true</span>;   <span class="comment">// 标记</span></span><br><span class="line"> <span class="number">3</span>      Number[i] = <span class="number">1</span> + <span class="built_in">max</span>(Number[<span class="number">1</span>], ..., Number[NUM_THREADS]);   <span class="comment">// 叫当前最大的号</span></span><br><span class="line"> <span class="number">4</span>      Entering[i] = <span class="literal">false</span>;  <span class="comment">// 当前进程 等待</span></span><br><span class="line"> <span class="number">5</span>      <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= NUM_THREADS; j++) &#123;</span><br><span class="line"> <span class="number">6</span>          <span class="comment">// Wait until thread j receives its number:</span></span><br><span class="line"> <span class="number">7</span>          <span class="keyword">while</span> (Entering[j]) &#123; <span class="comment">/* nothing */</span> &#125;</span><br><span class="line"> <span class="number">8</span>          <span class="comment">// Wait until all threads with smaller numbers or with the same</span></span><br><span class="line"> <span class="number">9</span>          <span class="comment">// number, but with higher priority, finish their work:</span></span><br><span class="line"><span class="number">10</span>          <span class="keyword">while</span> ((Number[j] != <span class="number">0</span>) &amp;&amp; ((Number[j], j) &lt; (Number[i], i))) &#123; <span class="comment">/* nothing */</span> &#125;</span><br><span class="line"><span class="number">13</span>      &#125;</span><br><span class="line"><span class="number">14</span>  &#125;</span><br><span class="line"><span class="number">15</span>  </span><br><span class="line"><span class="number">16</span>  <span class="built_in">unlock</span>(integer i) &#123;</span><br><span class="line"><span class="number">17</span>      Number[i] = <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span>  &#125;</span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span>  <span class="built_in">Thread</span>(integer i) &#123;</span><br><span class="line"><span class="number">21</span>      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="number">22</span>          <span class="built_in">lock</span>(i);</span><br><span class="line"><span class="number">23</span>          <span class="comment">// The critical section goes here...</span></span><br><span class="line"><span class="number">24</span>          <span class="built_in">unlock</span>(i);</span><br><span class="line"><span class="number">25</span>          <span class="comment">// non-critical section...</span></span><br><span class="line"><span class="number">26</span>      &#125;</span><br><span class="line"><span class="number">27</span>  &#125;</span><br></pre></td></tr></table></figure><h4 id="L19-死锁处理"><a href="#L19-死锁处理" class="headerlink" title="L19 死锁处理"></a>L19 死锁处理</h4><ul><li><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。产生死锁的原因，主要包括：</p><ul><li>系统资源不足；</li><li>程序执行的顺序有问题；  （多个进程由于互相等待对方持有的资源 而造成 谁都无法向下推进现象 ）</li><li>资源分配不当等。</li></ul></li><li><p>死锁的<em><strong>4个必要条件</strong></em></p><ul><li><em><strong>互斥使用</strong></em> ： 一个资源每次只能被一个进程使用</li><li><em><strong>不可抢占</strong></em>： 资源只能自愿放弃，进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li><em><strong>请求和保持</strong></em>：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li><em><strong>循环等待</strong></em>：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul></li><li><p>解决死锁 方法  （ 预防|避免| 检测恢复|忽略）</p><ul><li><p>预防方法： 一次性申请所有资源（需预知未来，资源利用率低），资源申请必须按序进行（资源浪费）</p></li><li><p>避免： 判断资源请求是否会引起死锁：（找到<em><strong>安全序列</strong></em> （所有进程存在可完成的执行序列））：</p><ul><li>银行家算法 ”Dijkstra 提出“ ： 时间复杂度高</li></ul> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> Available[<span class="number">1.</span>.m]; <span class="comment">// 每种资源的剩余数量</span></span><br><span class="line"><span class="type">int</span> Allocation[<span class="number">1.</span>.n,<span class="number">1.</span>.m]; <span class="comment">//已分配资源数量</span></span><br><span class="line"><span class="type">int</span> Need[<span class="number">1.</span>.n,<span class="number">1.</span>.m]; <span class="comment">// 进程还需要的各种资源数量</span></span><br><span class="line"><span class="type">int</span> Work[<span class="number">1.</span>.m]; <span class="comment">// 工作向量</span></span><br><span class="line"><span class="type">bool</span> Finish[<span class="number">1.</span>.n]; <span class="comment">// 进程是否结束</span></span><br><span class="line"></span><br><span class="line">work = Available ;Finish[<span class="number">1.</span>.n] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(Finish[i] == <span class="literal">false</span> &amp;&amp; Need[i] &lt;= work) &#123;</span><br><span class="line">work += Allocation[i];</span><br><span class="line">Finis[i] = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">END: <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=n;++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(Finish[i] == <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;deadlock&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度 ： o(mn^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>死锁检测+处理： 发现问题再处理</p></li><li><p>通用操作系统：采用死锁忽略方法:</p></li></ul></li></ul><h4 id="L20-内存使用和分段"><a href="#L20-内存使用和分段" class="headerlink" title="L20 内存使用和分段"></a>L20 内存使用和分段</h4><ul><li><p>重定位：把逻辑地址 转换成 物理地址 工作   </p><ul><li>静态重定位： 再程序执行之前进行重定位： 逻辑地址+ 起始地址。（程序在内存中不能移动，要求连续的内存空间）</li><li>动态重定位： 在程序执行过程中进行重定位 （每次访问内存单元时 才进行地址重定位）</li><li>—–运行时重定位（地址翻译： 执行指令时第一步： 从PCB中取出 <em><strong>基地址</strong></em> ）</li></ul></li><li><p><strong>分段</strong>：     程序由若干部分（段）组成： 将每个段分别放入内存中</p><ul><li><strong>LDT</strong> ( 局部描述符表 ) :描述局部于每个程序的段，包括其代码、数据、堆栈等</li><li><strong>GDT</strong> (全局描述符表):</li></ul></li></ul><h4 id="L21-内存分区与分页"><a href="#L21-内存分区与分页" class="headerlink" title="L21 内存分区与分页"></a>L21 内存分区与分页</h4><ul><li><p>分区：将内存分成若干个连续区域，每个分区只能存储一个程序</p><ul><li>操作系统维护 ： <strong>分区表（分区链表）</strong> ，包含分区的起始地址、大小及状态</li></ul></li><li><p>固定分区：分为大小固定的分区，系统运行时不再改变分区的大小</p></li><li><p>可变分区：在装入程序时划分内存区域，（使分配的分区大小等于该程序的需求量）</p><p><em><strong>内存分配算法：</strong></em></p><ul><li><strong>最佳适配</strong>（best fit）：从全部分区中找出满足作业需求的最小空闲区 - &gt; 使内存碎片尽量小</li><li><strong>首先适配</strong> （first fit）：按序查找，分配最先找到能够满足作业需求的空闲内存 -&gt; 最快</li><li><strong>最差适配</strong> （worst fit）：找到最大的空闲区 -&gt; 使剩下的空闲区最大，减小碎片机会</li></ul></li><li><p>分区管理的<strong>缺点</strong>：<u>内存使用不充分，存在着较为严重的碎片问题</u> ， 内存移动（<strong>内存紧缩</strong>）浪费处理机时间</p></li><li><p>分页存储管理： 将内存分为大小固定的若干块(页面，物理块)，（内存块号）</p><p>- </p><ul><li>同样，用户程序的虚拟地址划分为同样大小的若干页面- &gt; 每个页面对应一个编号（页号）</li><li>地址转换：<ul><li>页表： 程序逻辑地址中 <strong>页号</strong> 与 内存物理地址 中的 <strong>内存块号</strong> 的对应关系， 页表指针存在PCB中 （一个进程有一个页表）</li><li>执行指令时，硬件（MMU内存管理单元）按照 <strong>页号</strong> 查得到对应的内存块号，<strong>物理地址 &#x3D; 内存块号 * 块长 + 页内地址</strong></li></ul></li></ul></li></ul><h4 id="L22-多级页表、快表"><a href="#L22-多级页表、快表" class="headerlink" title="L22 多级页表、快表"></a>L22 多级页表、快表</h4><ul><li>多级页表： 页目录表+ 页表 （空间效率高，时间代价）<ul><li><img src="http://picgo.wangeyi.ink/image-20220328203652371.png" alt="image-20220328203652371" style="zoom:50%;" /></li></ul></li><li>快表：<strong>TLB</strong> 一组相联快速存储，是<strong>寄存器</strong>，<ul><li>快表是一种特殊的<a href="https://baike.baidu.com/item/%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/9027270">高速缓冲存储器</a>（Cache），内容是页表中的一部分或全部内容。</li><li><img src="http://picgo.wangeyi.ink/image-20220328204527093.png" alt="image-20220328204527093" style="zoom:50%;" /></li></ul></li></ul><h4 id="L23-段页式存储管理"><a href="#L23-段页式存储管理" class="headerlink" title="L23 段页式存储管理"></a>L23 段页式存储管理</h4><ul><li><p>分段和分页原理的组合：将用户程序分为若干段，每段分为若干页，并为每一段赋予一个段名</p><ul><li>地址结构： 段号+段内页号+页内地址</li><li>段内页号用于确定一个段内有多少页：  数量  &#x3D;  段长  &#x2F; 页面大小</li><li>”<em><strong>虚拟内存</strong></em>“ ：为每个进程提供虚拟的地址空间**（每个进程看到的内存都是一致的）</li></ul></li><li><p>段页同时存在的 地址翻译:</p><ul><li><p>逻辑地址（段号+偏移）-&gt;(LDT)-&gt; 虚拟地址（页号+偏移）-&gt;页表-&gt;物理地址（物理页号+偏移）</p><img src="http://picgo.wangeyi.ink/image-20220328213700237.png" alt="image-20220328213700237" style="zoom:50%;" /></li></ul></li><li><p>程序载入内存：<em><strong>*读时共享写时复制*</strong></em></p><ul><li><p>写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。</p><img src="http://picgo.wangeyi.ink/image-20220328225902355.png" alt="image-20220328225902355" style="zoom:50%;" /><ul><li><strong>优点</strong>是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作时可以共享同一份资源。</li></ul></li></ul></li></ul><h4 id="L24-内存换入-请求调页"><a href="#L24-内存换入-请求调页" class="headerlink" title="L24 内存换入_请求调页"></a>L24 内存换入_请求调页</h4><blockquote><p> 换入换出实现”<strong>虚拟内存</strong>“</p><p> 进程运行时，不是装入全部页面，而是动态装入，当内存控件已满，且需要装入新的页面，需要换入换出</p></blockquote><ul><li>缺页中断： （用户进程的当前用到的 <strong>页面</strong> 是放在<strong>主存（内存）</strong>中，其他页面放在 外存(磁盘中)）。<ul><li>当 从页表中查出该页 不在主存中，发送 <strong>缺页中断</strong></li></ul></li><li>请求调页： 发送缺页中断时，调入所需的页面</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">address &amp;+ <span class="number">0xfffff000</span>; <span class="comment">// 页面地址</span></span><br><span class="line">page = get_free_page(); <span class="comment">// 在物理内存中申请一个空页</span></span><br><span class="line">bread_page(page,current-&gt;executable-&gt;i_dev,n); <span class="comment">// 从磁盘中读入到物理内存page中</span></span><br><span class="line">put_page(page,address); <span class="comment">// 建立虚拟地址和 物理地址的映射， 填 页表</span></span><br></pre></td></tr></table></figure><h4 id="L25-内存换出"><a href="#L25-内存换出" class="headerlink" title="L25 内存换出"></a>L25 内存换出</h4><h5 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h5><blockquote><p>内存是有限的，需要<strong>选择页淘汰</strong>，换出到磁盘</p></blockquote><ul><li><p>FIFO (先进先出): 优先淘汰在内存中驻留时间最长的页，</p><ul><li>页面置换FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多，但缺页率反而提高的异常现象，这是一个违反直觉的现象</li></ul></li><li><p>MIN页面置换（最优）</p></li><li><p>LRU(最近最少使用）: 选择 <strong>最近最长</strong> 一段时间没有使用的页换出 <!--实际使用--></p><ul><li>”近似算法“”：每个页添加一个<strong>引用位</strong>：（SCR : second chance Replacement 二次机会算法： clock algorithm）<ul><li><img src="http://picgo.wangeyi.ink/image-20220329205819272.png" alt="image-20220329205819272" style="zoom:50%;" /></li><li>定时清 <strong>R 位</strong></li></ul></li><li><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></li></ul></li><li><p>LFU (最不频繁使用)：</p></li></ul><p>&lt;a name &#x3D; “内存换入换出”&gt;</a></p><h4 id="L26-I-x2F-O与显示器"><a href="#L26-I-x2F-O与显示器" class="headerlink" title="L26 I&#x2F;O与显示器"></a>L26 I&#x2F;O与显示器</h4><h4 id="L27-键盘"><a href="#L27-键盘" class="headerlink" title="L27 键盘"></a>L27 键盘</h4><ul><li>“按键”-&gt; <em><strong>产生中断</strong></em></li><li>中断处理函数 ，按照扫描码得到ASCII 码 -按键对应的字符</li><li><img src="http://picgo.wangeyi.ink/image-20220415201246914.png" alt="image-20220415201246914" style="zoom:50%;" /></li></ul><h4 id="生磁盘-（raw-disk）"><a href="#生磁盘-（raw-disk）" class="headerlink" title="生磁盘 （raw disk）"></a>生磁盘 （raw disk）</h4><ul><li><p>读写的基本单位是扇区 ： 512字节</p></li><li><p>I&#x2F;O过程： 寻道 -&gt; 旋转-&gt; 传输</p><ul><li>往磁盘控制器 写 “柱面” <code>cyl</code>, “磁头 <code>head</code>”、“扇区 <code>sec</code>”、“缓存位置” </li><li><img src="http://picgo.wangeyi.ink/image-20220415201736076.png" alt="image-20220415201736076" style="zoom: 25%;" /></li></ul></li><li><p>一层抽象 ：<em><strong>盘块号  block 读写磁盘</strong></em></p><ul><li><p><u>磁盘驱动</u> 负责从 <strong>block</strong> 计算出 <code>cyl，head，sec</code> （CHS）</p></li><li><img src="http://picgo.wangeyi.ink/image-20220415203356458.png" alt="image-20220415203356458" style="zoom:50%;" /></li><li><blockquote><p>磁盘访问时间： 写入控制器时间 + 寻道时间 + 旋转时间 + 传输时间 ，  主要的时间发在<strong>寻道时间</strong>上</p></blockquote></li><li><p>扇区 到 盘块 ： 上层读写的单位 变为盘块</p></li></ul></li><li><p>二层抽象 ：多个进程通过队列使用磁盘</p><ul><li>磁盘调度  （  平均访问延迟小 、 <code>关键:寻道时间</code>） ： <u>最优：电梯算法</u><ul><li>FCFS:  </li><li>SSTF (短磁道优先) ： 移动到最近的柱面  —— 存在饥饿问题</li><li>**SCAN **：sstf + 中途不回折<ul><li>C-SCAN（电梯算法） : <img src="http://picgo.wangeyi.ink/image-20220415205236783.png" alt="image-20220415205236783" style="zoom:50%;" /> <!--真实算法--></li></ul></li></ul></li><li>整理</li><li><ol><li>进程得到“盘块号”，算出扇区号<ol><li>用扇区号make req，发出请求，用电梯算法<code>add_request</code> 放入请求队列中</li><li>进程<code>sleep_on</code> </li><li>磁盘中断处理</li></ol></li></ol></li></ul></li><li><p>第三层抽象： 引入文件</p><ul><li>文件： 建立 <strong>字符流</strong> 到 <strong>盘块集合</strong> 的 <em><strong>映射</strong></em> 关系<ul><li>连续结构：(数组)   -&gt; 不适用于动态增长的文件</li><li>链式结构：（链表）-&gt; 不能随机存储</li><li>索引结构：”索引块“ 存储文件盘块的目录</li><li>实际系统中： <strong>多级索引结构</strong></li></ul></li></ul></li></ul><h4 id="L31-目录树"><a href="#L31-目录树" class="headerlink" title="L31 目录树"></a>L31 目录树</h4><ul><li>第四层抽象： <strong>文件系统</strong><ul><li>根据 文件的路径 得到文件的 <code>FCB</code></li></ul></li><li>树状目录的完整实现<ul><li><img src="http://picgo.wangeyi.ink/image-20220417171304628.png" alt="image-20220417171304628" style="zoom:50%;" /></li></ul></li></ul><h2 id="CSAPP"><a href="#CSAPP" class="headerlink" title="CSAPP"></a>CSAPP</h2><ul><li><p>程序文件翻译过程</p><ul><li>预处理器cpp: 根据#开头的命令，修改原始程序，得到另一个C程序 ，以.i 为文件扩展名（文本文件）</li><li>编译器ccl: 将文本文件.i翻译为.s 汇编语言程序</li><li>汇编器as ：将汇编语言程序翻译为机器语言.o（二进制文件）。</li><li>链接器id ： 负责将其他.o文件链接到该文件中，结果得到可执行目标文件（可执行文件）<ul><li><a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">目标文件</a></li></ul></li></ul></li><li><p>系统硬件组成</p><ul><li>总线：</li><li>IO设备</li><li>主存： 临时存储设备，用来存放程序和程序处理的数据</li><li>处理器CPU</li></ul></li><li><p>存储器额层次结构</p><ul><li><img src="http://picgo.wangeyi.ink/image-20220218164314858.png" alt="image-20220218164314858"></li></ul></li><li><p>操作系统管理硬件 （CPU管理 | 内存管理 | 终端管理 | 磁盘管理 | 文件管理） </p></li><li><p>文件是对io设备的抽象，虚拟内存是对程序存储器的抽象，进程是对正在运行的程序的抽象、虚拟机对整个计算机的抽象（操作系统、处理器、程序）</p><ul><li>进程：操作系统对一个正在运行的程序的一种抽象<ul><li>并发底执行多个进程：</li><li>上下文切换： 保存当前进程的上下文，恢复新进程的上下文，CPU控制权传递给新进程</li></ul></li><li>线程：一个进程可由多个执行单元组成（线程）-更容易共享数据</li><li>虚拟内存<strong>：为每个进程提供虚拟的地址空间</strong>（每个进程看到的内存都是一致的）  <a name = 虚拟内存></a></li><li>文件： 就是字节序列，（磁盘、键盘、显示器、网络都可以看成是文件）</li></ul></li><li><p>并发与并行</p><ul><li>并发：指一个同时具有多个活动的系统</li><li>并行：用并发来使一个系统运行得更快</li></ul></li></ul><h3 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h3><h4 id="2-信息的表示和处理"><a href="#2-信息的表示和处理" class="headerlink" title="2.信息的表示和处理"></a>2.信息的表示和处理</h4><h5 id="2-1信息存储"><a href="#2-1信息存储" class="headerlink" title="2.1信息存储"></a>2.1信息存储</h5><ul><li>一般计算机使用字节作为最小的可寻址内存单位</li><li>虚拟内存：机器级程序将内存视为一个整体的字节数组（每个字节由唯一的数字标识——内存地址）</li><li>字数据大小 ——字长（决定系统虚拟地址空间的最大大小）<ul><li>字长为w位的机器，虚拟地址范围为 <code>0 ~ 2 ^ W - 1</code></li></ul></li><li>寻址和字节顺序： 多字节对象呗存储再连续的地址空间，对象的地址使用的字节中最小的地址</li><li>扩展数字的位表示：<ul><li>无符号数的<strong>零扩展</strong>：高位补零</li><li>有符号数的<strong>符号扩展</strong>：高位补最高位有效值</li></ul></li></ul><h4 id="3-程序的机器级表示"><a href="#3-程序的机器级表示" class="headerlink" title="3.程序的机器级表示"></a>3.程序的机器级表示</h4><h5 id="3-1程序编码"><a href="#3-1程序编码" class="headerlink" title="3.1程序编码"></a>3.1程序编码</h5><ul><li>预处理器：插入所有<code>#include</code>命令指定的文件，扩展<code>#define</code>声明的宏</li><li>编译器：产生程序文件的汇编代码</li><li>汇编器：将汇编代码转化成 <strong>二进制表示</strong>的目标代码文件（.o）</li><li>链接器：合并实现库函数的代码，产生最终的可执行文件</li></ul><h6 id="3-1-1机器级代码"><a href="#3-1-1机器级代码" class="headerlink" title="3.1.1机器级代码"></a>3.1.1机器级代码</h6><ul><li><p><em><strong>ISA指令集架构：</strong></em>定义机器级程序的格式和行为，定义处理器状态、指令个格式，以及每条指令对状态的影响</p></li><li><p><em><strong>虚拟地址的抽象：</strong></em>机器级程序使用的内存地址的虚拟地址：（非常大的字节数组）</p></li><li><p>程序的内存：<u>程序的可执行的机器代码</u>、操作系统需要的信息、管理过程调用和返回的运行时栈、用户动态分配的内存</p></li><li><blockquote><p>操作系统负责管理程序的虚拟地址空间、将虚拟地址空间翻译成实际处理器内存中的物理地址</p></blockquote></li></ul><h6 id="3-1-2-代码示例"><a href="#3-1-2-代码示例" class="headerlink" title="3.1.2 代码示例"></a>3.1.2 代码示例</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mstore.c</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span>,<span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> * dest)</span> &#123;</span><br><span class="line"><span class="type">long</span> t = mult2(x,y);</span><br><span class="line">*dest = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令行：</span></span><br><span class="line">linux&gt; gcc -Og -S mstore.c     -S 选项能看到编译器产生的汇编代码</span><br><span class="line">linux&gt; gcc -Og -c mstore.c   -c 选项能看到目标代码文件</span><br></pre></td></tr></table></figure><h5 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h5><img src="http://picgo.wangeyi.ink/image-20220219152312027.png" alt="image-20220219152312027" style="zoom:200%;" /><h5 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h5><p>X86-64的处理器包含一组16个存储64位值得<u><em>通用目的寄存器</em></u>，用来存储整数数据和指针</p><p><img src="http://picgo.wangeyi.ink/image-20220219152726646.png" alt="image-20220219152726646"></p><h6 id="3-4-1-操作数指示符"><a href="#3-4-1-操作数指示符" class="headerlink" title="3.4.1 操作数指示符"></a>3.4.1 操作数指示符</h6><ul><li>操作数（operand）： 指示出执行操作中要使用的<em><strong>源数据值</strong></em>、以及<em><strong>放置结果得目标位置</strong></em>， <u>三种类型</u><ul><li>立即数：表示常数值 ，<code>$-577</code></li><li>寄存器：表示某个寄存器的内容</li><li>内存引用：根据计算出来的地址访问某个内存位置</li></ul></li></ul><p><img src="http://picgo.wangeyi.ink/image-20220219154259004.png" alt="image-20220219154259004"></p><h6 id="3-4-2-数据传送指令"><a href="#3-4-2-数据传送指令" class="headerlink" title="3.4.2 数据传送指令"></a>3.4.2 数据传送指令</h6><blockquote><p>最频繁使用的指令： 将数据从一个位置复制到另一个位姿</p></blockquote><ul><li><p>MOV类 ：<code>mov S,D</code> : 把数据从源位置S复制到目标位置D</p><ul><li><p><img src="http://picgo.wangeyi.ink/image-20220219155002813.png" alt="image-20220219155002813"><img src="http://picgo.wangeyi.ink/image-20220219155638700.png" alt="image-20220219155638700"></p></li><li><p>源操作数：立即数|存储在寄存器|存储在内存中</p></li><li><p>目的操作数：指定位置|寄存器|内存地址</p></li><li><blockquote><p>x86-64的限制：两个操作数不能都指向内存位置，需要两条指令：</p><p>1.将源值加载到寄存器</p><p>2.将该寄存器值写入目的位置</p></blockquote></li></ul></li></ul><p><img src="http://picgo.wangeyi.ink/image-20220219155522238.png"></p><ul><li>将较小的源值复制到较大的目的时：<ul><li><img src="http://picgo.wangeyi.ink/image-20220219155841596.png" alt="image-20220219155841596"></li></ul></li></ul><h6 id="3-4-3-压入和弹出栈数据"><a href="#3-4-3-压入和弹出栈数据" class="headerlink" title="3.4.3 压入和弹出栈数据"></a>3.4.3 压入和弹出栈数据</h6><blockquote><p>x86-64中： 程序栈是向下增长的,栈顶元素的地址是所有栈中元素地址中*<em>最低</em>的</p></blockquote><ul><li><img src="http://picgo.wangeyi.ink/image-20220219161647610.png" alt="image-20220219161647610"><ul><li>压栈：首先将栈指针减8，然后将值写到新的栈顶地址</li><li>弹出: 从栈顶位置读出数据，然后将栈指针加8</li></ul></li></ul><h5 id="3-5-算术和逻辑操作"><a href="#3-5-算术和逻辑操作" class="headerlink" title="3.5 算术和逻辑操作"></a>3.5 算术和逻辑操作</h5><ul><li><img src="http://picgo.wangeyi.ink/image-20220219162136047.png" alt="image-20220219162136047"></li></ul><h6 id="3-5-1-加载有效地址"><a href="#3-5-1-加载有效地址" class="headerlink" title="3.5.1 加载有效地址"></a>3.5.1 加载有效地址</h6><ul><li><p><code>leaq</code> 指令：<code>movq</code> 的变形</p></li><li><blockquote><p>指令形式是从内存读数据到寄存器，但实际上没引用内存，而是将有效地址写入到目的操作数</p></blockquote><ul><li>&#96;&#96;&#96;basic<br>movq 7(%rdx,%rdx,4), %rax  : M[5 * R[%rdx] + 7] -&gt; R[%rax]<br>leaq 7(%rdx,%rdx,4), %rax  : 5 * R[%rdx] + 7 - &gt; R[%rax]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - ![image-20220219163126101](http://picgo.wangeyi.ink/image-20220219163126101.png)</span><br><span class="line"></span><br><span class="line">###### 3.5.2 一元和二元操作</span><br><span class="line"></span><br><span class="line">- 一元操作： *&lt;u&gt;操作数即是源又是目的&lt;/u&gt;*</span><br><span class="line">- 二元操作：***第二个操作数既是源又是目的***</span><br><span class="line">  - 第一个操作数： 立即数|寄存器|内存位置</span><br><span class="line">  - 第二个操作数：寄存器|内存位置</span><br><span class="line">    - 内存位置：处理器必须从内存读出值，执行操作，再把结果写回内存</span><br><span class="line"></span><br><span class="line">###### 3.5.3 移位操作</span><br><span class="line"></span><br><span class="line">- 第一操作数是移位量（立即数|单字节寄存器%cl），第二操作数是要移位的数</span><br><span class="line">- 左移指令：`SAL|SHL`右边补上0</span><br><span class="line">- 右移指令：SAR(算术右移)：补上符号位| SLR(逻辑右移)：补上0</span><br><span class="line"></span><br><span class="line">###### 3.5.4 特殊的算术操作</span><br><span class="line"></span><br><span class="line">- ![image-20220219174818555](http://picgo.wangeyi.ink/image-20220219174818555.png)</span><br><span class="line"></span><br><span class="line">##### 3.6控制（执行操作的顺序）</span><br><span class="line"></span><br><span class="line">###### 3.6.1条件码</span><br><span class="line"></span><br><span class="line">- 一组单个位的条件码：描述最近的算术或逻辑操作的属性</span><br><span class="line">  - CF 进位标志：最近的操作使最高位产生了进位</span><br><span class="line">  - ZF零标志：最近的操作得出结果为0</span><br><span class="line">  - SF符号标志：最近的操作得到结果为负数</span><br><span class="line">  - OF溢出标志：最近的操作导致一个补码溢出——正溢出|负溢出</span><br><span class="line">- CMP指令|TEST指令 ： 只设置条件码而不改变任何其他寄存器</span><br><span class="line">  - CMP指令根据两个操作数的***&lt;u&gt;差&lt;/u&gt;*** 来设置条件码</span><br><span class="line">  - ![image-20220220193542268](http://picgo.wangeyi.ink/image-20220220193542268.png)</span><br><span class="line"></span><br><span class="line">###### 3.6.2 访问条件码</span><br><span class="line"></span><br><span class="line">- SET指令: 根据条件码的某种组合，将一个字节设置为0|1</span><br><span class="line">  - 目的操作数是**低位单字节寄存器元素|一个字节的内存地址**</span><br><span class="line">  - ![image-20220220194115433](http://picgo.wangeyi.ink/image-20220220194115433.png)</span><br><span class="line"></span><br><span class="line">###### 3.6.3 跳转指令</span><br><span class="line"></span><br><span class="line">- jump指令 ： 跳转的目的地通常用一个标号label指明</span><br><span class="line"></span><br><span class="line">- 跳转指令的编码方式：</span><br><span class="line">  - PC-relative (PC 相对):  将***跳转目标指令的地址***   与 紧邻 ***跳转指令（jump）*** ***后面一条指令*** ***的地址*** 之间的差作为编码</span><br><span class="line"></span><br><span class="line">###### 3.6.4 条件分支的实现</span><br><span class="line"></span><br><span class="line">- 条件控制：根据有条件|无条件控制跳转</span><br><span class="line">  - 首先比较两个操作数，按照条件码来控制跳转</span><br><span class="line">  - ![image-20220221172509594](http://picgo.wangeyi.ink/image-20220221172509594.png)</span><br><span class="line"></span><br><span class="line">- 条件传送： 计算条件操作的***两种结果*** ， 根据 ***条件是否满足*** 选取一个</span><br><span class="line">  - ![image-20220221172727169](http://picgo.wangeyi.ink/image-20220221172727169.png)</span><br><span class="line"></span><br><span class="line">- ![image-20220221172740678](http://picgo.wangeyi.ink/image-20220221172740678.png)</span><br><span class="line">  - 条件控制|条件传送：  ***&lt;u&gt;（分支预测错误|大量计算）&lt;/u&gt;***</span><br><span class="line">    - ![image-20220221173144768](http://picgo.wangeyi.ink/image-20220221173144768.png)</span><br><span class="line"></span><br><span class="line">###### 3.6.5 条件传送指令</span><br><span class="line"></span><br><span class="line">![image-20220221172841354](http://picgo.wangeyi.ink/image-20220221172841354.png)</span><br><span class="line"></span><br><span class="line">###### 3.6.6 循环</span><br><span class="line"></span><br><span class="line">- 利用 **&lt;u&gt;条件测试和跳转&lt;/u&gt;** 组合来实现**循环** </span><br><span class="line"></span><br><span class="line">##### 3.7 过程 （函数|方法|子例程| 处理函数）</span><br><span class="line"></span><br><span class="line">- 提供封装代码的方式(指定参数|返回值实现</span><br><span class="line">  - 设：过程p调用过程q，q执行完后返回p</span><br><span class="line">    - ***传递控制*** ： 进入 **q** 时，程序计数器必须被设置为 **q** 的代码地址，返回时，程序计数器设置为 **p** 中调用 **q** 之后的指令的地址。</span><br><span class="line">    - ***传递数据*** ：  p-&gt; q : 参数  | q -&gt; p : 返回值</span><br><span class="line">    - ***分配和释放内存***： 为局部变量分配空间，返回时释放这些空间。</span><br><span class="line"></span><br><span class="line">###### 3.7.1 运行时栈</span><br><span class="line"></span><br><span class="line">- 调用函数|过程时， （*栈指针`%rsp`*）控制 和数据信息添加到栈尾</span><br><span class="line">- 从函数|过程返回时：栈尾的数据被释放掉</span><br><span class="line"></span><br><span class="line">&gt; 当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间 -———(过程的**栈帧**)</span><br><span class="line">&gt;</span><br><span class="line">&gt; 许多函数根本不需要栈帧</span><br><span class="line"></span><br><span class="line">###### 3.7.2 转移控制</span><br><span class="line"></span><br><span class="line">- **！**</span><br><span class="line">  - 调用时： 将程序计数器设置为 q  的代码地址</span><br><span class="line">  - 返回时：将程序计数器设置为继续 p 的执行的代码位置</span><br><span class="line">- 指令 `call` ： </span><br><span class="line">  - ![image-20220224193254529](http://picgo.wangeyi.ink/image-20220224193254529.png)</span><br><span class="line"></span><br><span class="line">###### 3.7.3 数据传送</span><br><span class="line"></span><br><span class="line">- 大部分过程间的数据传送时通过寄存器实现的。-x86-64 可通过寄存器最多传递6个整形![image-20220228210232218](http://picgo.wangeyi.ink/image-20220228210232218.png)</span><br><span class="line"></span><br><span class="line">###### 3.7.6 递归过程</span><br><span class="line"></span><br><span class="line">- 递归调用一个函数本身与调用其他函数是一样的</span><br><span class="line">  - ![image-20220228210639268](http://picgo.wangeyi.ink/image-20220228210639268.png)</span><br><span class="line"></span><br><span class="line">##### 3.8 数组分配和访问</span><br><span class="line"></span><br><span class="line">###### 3.8.2 指针运算</span><br><span class="line"></span><br><span class="line">- ![image-20220228211329553](D:\Study\文献\笔记\学习笔记\image-20220228211329553.png)</span><br><span class="line"></span><br><span class="line">###### 3.8.3 嵌套的数组</span><br><span class="line"></span><br><span class="line">- 对于多维数组：数组元素在内存种按照“***行优先***”的顺序排列</span><br><span class="line"></span><br><span class="line">  - ![image-20220301205310282](http://picgo.wangeyi.ink/image-20220301205310282.png)</span><br><span class="line"></span><br><span class="line">  - 示例：![image-20220301205351083](http://picgo.wangeyi.ink/image-20220301205351083.png)</span><br><span class="line"></span><br><span class="line">###### 3.8.4  定长数组</span><br><span class="line"></span><br><span class="line">- #define 声明数组的长度</span><br><span class="line"></span><br><span class="line">##### 3.9 数据结构</span><br><span class="line"></span><br><span class="line">##### 3.9.1 结构</span><br><span class="line"></span><br><span class="line">- 结构的所有组成部分都存放在内存中一段连续的地址内。 —— 指向***&lt;u&gt;结构的指针&lt;/u&gt;*** 就是 结构第一个字节的地址。 </span><br><span class="line"></span><br><span class="line">###### 3.9.2 联合</span><br><span class="line"></span><br><span class="line">![image-20220301214302883](http://picgo.wangeyi.ink/image-20220301214302883.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 6. 存储器结构</span><br><span class="line"></span><br><span class="line">##### 6.1 存储技术</span><br><span class="line"></span><br><span class="line">###### 随机访问存储器</span><br><span class="line"></span><br><span class="line">- random access memory： `RAM 静态RAM(SRAM)、动态RAM(DRAM)`</span><br><span class="line"></span><br><span class="line">- SRAM：每位存储在 ”双稳态的存储单元“，</span><br><span class="line">  - 作为高速缓存存储器</span><br><span class="line">  - ![image-20220419205405437](http://picgo.wangeyi.ink/image-20220419205405437.png)</span><br><span class="line">- DRAM:  每一位存储为 对一个**电容的充电**。</span><br><span class="line">  - 作为主存，图形系统的帧缓冲区</span><br><span class="line">- ![image-20220419205957007](http://picgo.wangeyi.ink/image-20220419205957007.png)</span><br><span class="line"></span><br><span class="line">- 非易失性存储器： </span><br><span class="line">  - ROM（只读存储器）：</span><br><span class="line">    - PROM (Programmable ROM)：只能被编程一次</span><br><span class="line">    - EPROM (Erasable  Programmable ROM): 可擦写可编程、EEROM (电子可擦除)</span><br><span class="line">    - 闪存 （Flash Memory )- &gt; 基于闪存的SSD （Solid state disk）</span><br><span class="line">  - 固件：firmware， 存储在rom设备中的程序</span><br><span class="line">- 访问主存 ：</span><br><span class="line">  - 数据流通过总线在cpu和主存之间传输。 称为总线事务(读事务、写事务)</span><br><span class="line">  - ![image-20220419213154365](http://picgo.wangeyi.ink/image-20220419213154365.png)</span><br><span class="line"></span><br><span class="line">###### 磁盘存储</span><br><span class="line"></span><br><span class="line">- ***广为应用的保存大量数据的存储设备*** , (存储数据多，读写数据慢（毫秒级）)</span><br><span class="line"></span><br><span class="line">- 构造：</span><br><span class="line">  - 由盘片构成： 每个盘片有两面：表面； 表面上覆盖磁性记录材料</span><br><span class="line">  - 每个表面由一组称为 **“磁道”**  同心圆组成，</span><br><span class="line">  - 每个磁道被划分为一组 **“扇区”**，每个扇区包含相等数量的数据位</span><br><span class="line">  - 柱面： 所有盘片表面上到主轴中心的距离**相等**的磁道的集合</span><br><span class="line">  - ![image-20220430144948094](http://picgo.wangeyi.ink/image-20220430144948094.png)</span><br><span class="line">- 磁盘容量：可以记录的最大位数：最大容量</span><br><span class="line">  - 记录密度： 磁道一英寸的段中可以放入的位数</span><br><span class="line">  - 磁道密度： 盘片中心出发半径一英寸的段内可以有的磁道数</span><br><span class="line">  - 面密度： 记录密度 与磁道密度 的乘积</span><br><span class="line">  - ![image-20220430145446976](http://picgo.wangeyi.ink/image-20220430145446976.png)</span><br><span class="line">  - ![image-20220430145600262](image-20220430145600262.png)</span><br><span class="line">- 磁盘操作</span><br><span class="line">  - “**读/写头**” 来读写存储在磁性表面的位 </span><br><span class="line">  - “**寻道**” ：驱动器通过 前后移动传动臂，将“读/写头定位在盘面上的任何磁道”</span><br><span class="line">  - 磁盘以***扇区为单位***进行读写，访问时间的三个主要部分：</span><br><span class="line">    - 寻道时间：移动读写头的传动臂所需的时间，通常3 ~9ms， 最大高达20ms</span><br><span class="line">    - 旋转时间：目标扇区的第一位旋转到读写头下，![image-20220430151037163](http://picgo.wangeyi.ink/image-20220430151037163.png)</span><br><span class="line">    - 传送时间： 读写的时间</span><br><span class="line">  - ![image-20220430151147469](image-20220430151147469.png)</span><br><span class="line">- 逻辑磁盘块：</span><br><span class="line">  - 呈现为一个 逻辑块的序列， 磁盘控制器负责维护逻辑块号与实际磁盘扇区之间的映射关系</span><br><span class="line">  - ![image-20220430152227725](http://picgo.wangeyi.ink/image-20220430152227725.png)</span><br><span class="line">- 连接I/O 设备：</span><br><span class="line">  - ![image-20220430153221413](http://picgo.wangeyi.ink/image-20220430153221413.png)</span><br><span class="line">  - 三种不同类型的设备比连接到总线</span><br><span class="line">    - USB 通用串行总线：连接各种外围IO设备</span><br><span class="line">    - 显卡</span><br><span class="line">    - 主机总线适配器：将一或多个磁盘连接到IO总线上，</span><br><span class="line">      - 磁盘接口 **SCSI** 、SATA</span><br><span class="line">- 访问磁盘：</span><br><span class="line">  - ![image-20220430154010783](http://picgo.wangeyi.ink/image-20220430154010783.png)</span><br><span class="line"></span><br><span class="line">###### 固态硬盘</span><br><span class="line"></span><br><span class="line">- SSD，基于闪存的存储技术</span><br><span class="line">  - 封装有一个或多个***闪存芯片*** 和 ***闪存翻译层*** </span><br><span class="line">    - 闪存芯片： 代替 “机械驱动器”</span><br><span class="line">    - 闪存翻译层： 代替 “磁盘控制器”</span><br><span class="line">  - ![image-20220430155609417](http://picgo.wangeyi.ink/image-20220430155609417.png)</span><br><span class="line"></span><br><span class="line">##### 6.2 局部性</span><br><span class="line"></span><br><span class="line">&gt; 局部性原理（**locality**）：无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</span><br><span class="line">&gt;</span><br><span class="line">&gt; || :编写良好的计算机程序 倾向于引用领近于其他最近引用过的数据项</span><br><span class="line"></span><br><span class="line">- 通常有两种形式 : 时间局部性、空间局部性</span><br><span class="line">- 硬件层： 引入`高速缓存存储器` 保存最近被引用的指令和数据项</span><br><span class="line">- 操作系统级：</span><br><span class="line"></span><br><span class="line">###### 程序数据引用的局部性</span><br><span class="line"></span><br><span class="line">![image-20220501144958459](http://picgo.wangeyi.ink/image-20220501144958459.png)</span><br><span class="line"></span><br><span class="line">- 顺序引用模式： 步长为`1` 的引用模式， 例顺序一维数组</span><br><span class="line">- 连续向量中， 每隔 k 个元素进行访问，称为 步长为 k 的引用模式；随着步长增加，空间局部性下降。</span><br><span class="line">- 二维数组: 交换行列的访问顺序，行优先 步长为 1，列优先步长为N</span><br><span class="line"></span><br><span class="line">###### 小结</span><br><span class="line"></span><br><span class="line">- **重复引用相同的变量的程序具有良好的局部性**</span><br><span class="line">- **步长越小，空间局部性越好**</span><br><span class="line">- **取指令：循环有好的时间和空间局部性，循环体越小，循环迭代次数越多，局部性越好**</span><br><span class="line"></span><br><span class="line">##### 6.3 存储器的层次结构</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://picgo.wangeyi.ink/image-20220501150222848.png&quot; alt=&quot;image-20220501150222848&quot;  /&gt;</span><br><span class="line"></span><br><span class="line">###### 缓存</span><br><span class="line"></span><br><span class="line">- 存储器层次结构的中心思想：</span><br><span class="line">  - ![image-20220501151100415](http://picgo.wangeyi.ink/image-20220501151100415.png)</span><br><span class="line"></span><br><span class="line">- 高速缓存：小而快速的存储设备，作为存储在更大、更慢的设备中的数据对象的缓冲区。</span><br><span class="line"></span><br><span class="line">&gt; 存储器被划分为连续的数据对象组块，称为块（**block**）’</span><br><span class="line">&gt;</span><br><span class="line">&gt; 数据总是以**块** 大小为传送单元在 k层 和 k + 1层之间来回复制</span><br><span class="line"></span><br><span class="line">- 缓冲命中：</span><br><span class="line">  - 当程序需要第 k + 1层的某个数据对象 `d` 时，首先在当前存储在第k层的块中查找 `d`，如果 **d 刚好缓存在第k层中**，称为 ”缓存命中“。</span><br><span class="line">- 缓存不命中：</span><br><span class="line">  - 第k层中没有缓存对象d，需要从第k + 1层 缓存中取出包含d的块。</span><br><span class="line">  - 替换策略：[跳转](#内存换入换出)</span><br><span class="line"></span><br><span class="line">###### 小结</span><br><span class="line"></span><br><span class="line">![image-20220501154632773](http://picgo.wangeyi.ink/image-20220501154632773.png)</span><br><span class="line"></span><br><span class="line">##### 6.4 高速缓存存储器</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://picgo.wangeyi.ink/image-20220501155335549.png&quot; alt=&quot;image-20220501155335549&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&gt; 读吞吐量：程序中存储系统中读数据的速率（或称为读带宽）</span><br><span class="line"></span><br><span class="line">##### 小结</span><br><span class="line"></span><br><span class="line">###### 基本存储技术:</span><br><span class="line"></span><br><span class="line">- RAM(随机存储器)</span><br><span class="line">  - SRAM: (快、贵) 用做CPU芯片、芯片下的高速缓存</span><br><span class="line">  - DAMR：主存、图形帧缓冲区</span><br><span class="line">- ROM(非易失性存储器) 断电数据不丢失</span><br><span class="line">- ![image-20220517190207261](http://picgo.wangeyi.ink/image-20220517190207261.png)</span><br><span class="line"></span><br><span class="line">#### 7.链接</span><br><span class="line"></span><br><span class="line">将各种代码和数据片段收集并组合成为一**&lt;u&gt;个单一文件的过程&lt;/u&gt;**</span><br><span class="line"></span><br><span class="line">##### 7.2 静态链接</span><br><span class="line"></span><br><span class="line">&gt; 以一组可重定位目标文件.o 和命令参数作为输入，生成完全链接的、可以加载和运行可执行目标文件</span><br><span class="line">&gt;</span><br><span class="line">&gt; 链接器的两个主要任务： 符号解析、重定位</span><br><span class="line"></span><br><span class="line">- 符号解析： 定义和引用符号：（每个符号对应于&lt;u&gt;函数“函数必须是全局的”|全局变量 | 静态变量&lt;/u&gt; ）—— 将每个**符号引用**（符号的使用）正好与一个**符号定义**关联起来</span><br><span class="line"></span><br><span class="line">  - ![image-20220301215816642](http://picgo.wangeyi.ink/image-20220301215816642.png)</span><br><span class="line"></span><br><span class="line">  - 对于相同模块（代码块&#123;&#125;）中的局部符号的引用： 只允许每个模块中的每个局部符号只有一个定义</span><br><span class="line">  - 对于全局符号：生成链接器**符号表**条目，在其他输入模块中查找</span><br><span class="line">    - 重载函数的符号：“将每个唯一的方法和参数列表 **组合** 编码成 ’唯一的名字‘ ”</span><br><span class="line">    - 全局符号 ： 强 （函数&amp;已初始化的全局变量）|  弱 （未初始化的全局变量）</span><br><span class="line">      - 解析多重定义的全局符号</span><br><span class="line">        1. 不允许有多个同名的强符号</span><br><span class="line">        2. 强符号和弱符号同名，选择强符号</span><br><span class="line">        3. 多个弱符号同名，任意选择一个</span><br><span class="line"></span><br><span class="line">- 重定位：将每个符号定义与一个内存位置关联起来，然后修改符号引用指向**这些内存**  。 修改符号定义的逻辑地址  -&gt; 物理地址</span><br><span class="line"></span><br><span class="line">##### 7.3 目标文件</span><br><span class="line"></span><br><span class="line">&gt; &lt;a name = “目标文件&quot;&gt;&lt;/a&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt; 三种形式：</span><br><span class="line"></span><br><span class="line">- 可重定位目标文件：“二进制代码和数据”， 可在编译时与其他可重定位目标文件合并</span><br><span class="line">- 可执行目标文件： “二进制代码和数据”： 形式可以被直接复制到内存并执行</span><br><span class="line">- 共享目标文件： “特殊类型的可重定位文件”, 加载|运行时被**动态** 地加载进内存并 链接</span><br><span class="line"></span><br><span class="line">##### 7.4 可重定位文件</span><br><span class="line"></span><br><span class="line">深入理解计算机操作系统 - 7.4</span><br><span class="line"></span><br><span class="line">##### 7.6 符号解析</span><br><span class="line"></span><br><span class="line">###### 7.6.2 静态链接库</span><br><span class="line"></span><br><span class="line">- 编译系统提供的机制：将所有相关的目标文件打包成“**静态链接库**”</span><br><span class="line"></span><br><span class="line">![image-20220302110057813](http://picgo.wangeyi.ink/image-20220302110057813.png)</span><br><span class="line"></span><br><span class="line">##### 7.7 重定位</span><br><span class="line"></span><br><span class="line">&gt; 合并输入的模块，并为每个符号分配运行时的地址</span><br><span class="line"></span><br><span class="line">- *重定位节* （节： 代码节|数据节）和*符号定义*：合并相同类型的节，![image-20220302110856000](http://picgo.wangeyi.ink/image-20220302110856000.png)</span><br><span class="line"></span><br><span class="line">- 重定位节中的符号引用：![image-20220302110920768](http://picgo.wangeyi.ink/image-20220302110920768.png)</span><br><span class="line"></span><br><span class="line">###### 7.7.1 重定位条目</span><br><span class="line"></span><br><span class="line">- **汇编器** 遇到 对最终位置未知的目标引用，——生成一个重定位条目（告诉链接器）</span><br><span class="line"></span><br><span class="line">##### 7.10 动态链接库</span><br><span class="line"></span><br><span class="line">![image-20220302190332255](http://picgo.wangeyi.ink/image-20220302190332255.png)</span><br><span class="line"></span><br><span class="line">共享库以两种不同的方式来“共享”</span><br><span class="line"></span><br><span class="line">- 唯一的.so文件(对于一个库)： 所有应用该库的可执行文件***共享这个文件***中的代码和数据。</span><br><span class="line"></span><br><span class="line">- 内存中，共享库的**.text节**的副本可以被不同正在运行的进程共享。</span><br><span class="line"></span><br><span class="line">  &gt; 一般C语言的编译后执行语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部静态变量都保存在. data段</span><br><span class="line"></span><br><span class="line">##### 7.12 位置无关代码</span><br><span class="line"></span><br><span class="line">- 可以加载而无需重定位的代码 ;位置无关代码（Position-Independent Code，PIC）</span><br><span class="line">- PIC 数据引用：  对于全局变量的引用：“数据段和代码段的距离总是保持不变的”</span><br><span class="line"></span><br><span class="line">#### 8 异常控制流</span><br><span class="line"></span><br><span class="line">&gt; ECF:  Exceptional Control Flow</span><br><span class="line">&gt;</span><br><span class="line">&gt; 硬件层：硬件检测事件触发异常处理程序</span><br><span class="line">&gt;</span><br><span class="line">&gt; 操作系统层：内核的上下文切换</span><br><span class="line">&gt;</span><br><span class="line">&gt; 应用层： 进程之间的通信，接收方转移到信号处理程序</span><br><span class="line"></span><br><span class="line">##### 8.1 异常</span><br><span class="line"></span><br><span class="line">&gt; 异常控制流的一种形式，用来处理处理器状态中的某些变换</span><br><span class="line"></span><br><span class="line">- 处理器检测到**事件发生时**，通过“ ***异常表*** ” 跳转到 “ ***异常处理程序*** ” ，进行处理。</span><br><span class="line">  - 根据 引起异常的**事件类型**，发生一下三种情况</span><br><span class="line">    - 返回到当前指令， 回到当事件发生时正在执行的指令</span><br><span class="line">    - 返回给下一条指令，回到没有异常将会执行的下一条指令</span><br><span class="line">    - 终止被中断的程序</span><br><span class="line"></span><br><span class="line">###### 异常处理</span><br><span class="line"></span><br><span class="line">&gt; 系统中可能的每种类型的异常都分配了唯一一个 “非负整数”的异常号</span><br><span class="line">&gt;</span><br><span class="line">&gt; （处理器设计者分配、操作系统内核设计者分配）</span><br><span class="line">&gt;</span><br><span class="line">&gt; 异常 处理程序完全运行在内核模式下</span><br><span class="line"></span><br><span class="line">- 异常表： 表目k 包含异常 k的处理程序的地址</span><br><span class="line">  - 异常号是异常中的索引</span><br><span class="line">  - 寻址：异常表基址寄存器+ 异常号 x84 = 异常 k 的条目的地址</span><br><span class="line"></span><br><span class="line">###### 类型</span><br><span class="line"></span><br><span class="line">- 中断：异步产生，来自处理器外部的I/O设备的信号，不由任何一条专门指令造成</span><br><span class="line">- 陷阱：“有意”的异常，提供系统调用</span><br><span class="line">- 故障： 由错误引起，可能能够被故障处理程序修正，（能够修正：返回**当前指令** | 不能修正：终止程序）</span><br><span class="line">  - “缺页异常”</span><br><span class="line">- 终止： 不可恢复的错误造成的</span><br><span class="line"></span><br><span class="line">&gt; Linux 系统调用的参数都是通过**通用寄存器**传递的</span><br><span class="line"></span><br><span class="line">##### 8.2 进程</span><br><span class="line"></span><br><span class="line">**“ 异常是允许操作系统内核提供进程概念的基本构造块”**</span><br><span class="line"></span><br><span class="line">&gt; 进程；运行中的程序</span><br><span class="line"></span><br><span class="line">- 进程的两个关键抽象:</span><br><span class="line">  - 独立的逻辑控制流：程序计数值（PC）</span><br><span class="line">  - 私有的地址空间：虚拟内存</span><br><span class="line">- 并发： 多个程序交替执行  | 并行： 多核上同时执行</span><br><span class="line"></span><br><span class="line">###### 用户态、内核态</span><br><span class="line"></span><br><span class="line">&gt; 模式位控制状态（设置模式位：内核态）</span><br><span class="line"></span><br><span class="line">用户态进入内核态：（中断、故障、 系统调用）</span><br><span class="line"></span><br><span class="line">&gt; 当从异常处理程序（中断、故障、陷阱系统调用）返回到应用程序代码时，模式从内核态切换至用户态</span><br><span class="line"></span><br><span class="line">###### 上下文切换</span><br><span class="line"></span><br><span class="line">- [CPU调度 ](#L14)</span><br><span class="line"></span><br><span class="line">##### 8.4进程控制</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">pid_t getpid(void);  // 获取进程ID, 每个进程都有唯一个正数ID</span><br><span class="line">void exit(int status); // 以状态status 退出状态来终止进程</span><br><span class="line">pid_t fork(void);  // 父进程调用fork函数创建一个新的运行子进程</span><br><span class="line">pid_t waitpid(pid_t pid, int *statusp, int ortions); //等待子进程终止或停止</span><br><span class="line">unsigned int sleep(unsigned in secs);</span><br><span class="line">int pause(void); // 让调用函数休眠，直到该进程收到一个信号</span><br><span class="line">int execve(const char * filename,const char * argv[], const char * envp[]); // 加载并运行可执行目标文件</span><br><span class="line">// filename ： 可执行文件</span><br><span class="line">// argv ： 参数字符串</span><br><span class="line">// envp ： 环境变量z</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>fork 函数：</strong> </p><ul><li>子进程得到父进程 相同独立的虚拟内存副本。子进程和父进程之间最大的区别就是由不同的PID</li><li>调用一次、返回两次<ul><li>返回子进程的PID到父进程</li><li>返回0 到子进程</li></ul></li><li>并发执行：父进程与子进程并发执行</li><li>相同但是独立的地址空间：子进程复制一份父进程的内存地址</li><li>共享文件：子进程继承父进程打开的所有文件</li></ul></li></ul><h6 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h6><p>已经终止的进程会保持在 “ 已终止”的状态，直到被它的父进程回收。</p><h5 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h5><blockquote><p>信号就是一条小消息： 通知进程系统中发生了某种类型的事件</p></blockquote><ul><li><p>发送信号 （进程可以发送信号给自己）</p><ul><li><p>内核检测到系统事件，</p></li><li><p>进程调用了kill函数</p></li><li><blockquote><p>发送信号的机制都基于进程组</p></blockquote></li></ul></li><li><p>接收信号</p><ul><li>进程可以<strong>忽略</strong> 、 <strong>终止或者通过执行</strong> “”信号处理程序</li></ul></li></ul><h4 id="9-虚拟内存"><a href="#9-虚拟内存" class="headerlink" title="9 虚拟内存"></a>9 虚拟内存</h4><blockquote><p>为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。虚拟内存是<strong>硬件异常、硬件地址翻译、主存、磁盘文件和内核软件</strong>的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：</p><p>虚拟内存的三个重要能力:</p><pre><code>1. 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，高效地使用了主存1. 为每个进程提供了一致的地址空间，简化了内存管理，1. 保护每个进程的地址空间不被其他进程破坏</code></pre></blockquote><h6 id="物理寻址"><a href="#物理寻址" class="headerlink" title="物理寻址"></a>物理寻址</h6><blockquote><p>CPU直接使用物理地址访问内存</p></blockquote><h6 id="虚拟寻址"><a href="#虚拟寻址" class="headerlink" title="虚拟寻址"></a>虚拟寻址</h6><blockquote><p>通过虚拟地址来访问内存</p><pre><code>虚拟地址首先被转换成适当的物理地址，”地址翻译“。</code></pre></blockquote><h6 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h6><blockquote><p>非负整数地址的有序合集</p></blockquote><ul><li>虚拟地址空间： 虚拟内存的地址空间<ul><li>大小表示由最大地址所需的位数来描述（32位、64位）</li></ul></li><li>物理地址空间：对应系统中物理内存的空间</li></ul><h6 id="作为缓存工具"><a href="#作为缓存工具" class="headerlink" title="作为缓存工具"></a>作为缓存工具</h6><blockquote><p>虚拟内存被组织成存放在磁盘上的N个连续的字节大小的单元组成的数组 （每个字节由唯一的虚拟地址）。</p><p>虚拟内存被分割成称为”虚拟页“的大小固定的块</p><p>物理内存被分割位物理页</p></blockquote><h6 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h6><blockquote><p>将<strong>虚拟页</strong> 映射到<strong>物理页</strong> 的数据结构</p><p>页表条目的数组</p></blockquote><h6 id="作为内存管理的工具"><a href="#作为内存管理的工具" class="headerlink" title="作为内存管理的工具"></a>作为内存管理的工具</h6><blockquote><p>操作系统位每个进程提供了一个独立的页表，——独立的虚拟地址空间</p><p>多个虚拟页面可以映射到同一个共享物理页面上</p></blockquote><ul><li>简化链接：<ul><li>虚拟内存的”独立“的地址空间允许 每个进程的内存映像使用相同的格式，而不用管代码和数据实际存放在物理内存的地址。</li></ul></li><li>简化加载<ul><li>虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页VP，把他们<strong>标记为无效（未被缓存）</strong> ，将页表条目指向目标文件的起始位置。<ul><li><strong>加载器从不在磁盘到内存实际复制任何数据，在每个页初次被引用时，虚拟内存系统会按照需要自动的调入数据页。</strong></li></ul></li></ul></li></ul><ol><li><ul><li><strong>简化共享：</strong> 独立地址空间为OS提供了一个管理用户进程和操作系统自身之间共享的一致机制。<ul><li>一般：每个进程有各自私有的代码，数据，堆栈，是不和其他进程共享的，<strong>这样OS创建页表，将虚拟页映射到不连续的物理页面。</strong></li><li>某些情况下，需要进程来共享代码和数据。例如每个进程调用相同的操作系统内核代码，或者C标准库函数。<strong>OS会把不同进程中适当的虚拟页面映射到相同的物理页面。</strong></li></ul></li><li><strong>简化内存分配：</strong> 虚拟内存向用户提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如<code>malloc</code>），OS分配一个适当k大小个连续的虚拟内存页面，并且将他们映射到物理内存中任意位置的k个任意物理页面，*<u><strong>因此操作系统没有必要分配k个连续的物理内存页面，页面可以随机的分散在物理内存中</strong>。</u>*</li></ul></li></ol><ul><li>虚拟内存作为内存保护的工具。</li><li>不应该允许一个用户进程修改它的只读段，也不允许它修改任何内核代码和数据结构，不允许读写其他进程的私有内存，不允许修改任何与其他进程共享的虚拟页面。每次CPU生成一个地址时，<code>MMU</code>会读一个<code>PTE</code>，通过在<code>PTE</code>上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。</li></ul><h4 id="11-网络编程"><a href="#11-网络编程" class="headerlink" title="11 网络编程"></a>11 网络编程</h4><blockquote><p>网络应用是基于客户端-服务器模型的（一个服务器，，多个客户端·）</p><p>IP 地址： 32位无符号整型数，（点分十进制表示）</p><p>域名：由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称</p></blockquote><blockquote><p><strong>抖动就是指当内存中已无空闲空间而又发生缺页中断时，需要从内存中调出一页程序或数据送磁盘的对换区中，如果算法不适当，刚被换出的页很快被访问，需重新调入，因此需再选一页调出，而此时被换出的页很快又要被访问，因而又需将它调入，如此频繁更换页面，以致花费大量的时间</strong></p><p>请求分页要有页面调度，可能会产生抖动</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><h3 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h3><blockquote><p>大型的程序系统，负责计算机的全部软、硬资源的<em><strong>分配与回收，控制与协调并发活动</strong></em>，实现信息的存取和保护。</p></blockquote><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><ul><li><code>系统资源管理者</code>：CPU管理、内存管理、文件管理、设备管理</li><li><code>作为用户和硬件之间的接口</code>： 命令接口，程序接口、GUI<ul><li><img src="http://picgo.wangeyi.ink/image-20220711165400986.png" alt="image-20220711165400986"></li></ul></li><li><code>实现对硬件机器的拓展</code>：</li></ul><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><blockquote><p>并发、共享、虚拟、异步</p><p>最基本的两个特征：并发、共享</p></blockquote><ul><li><p><code>并发</code>：宏观上同时发生、微观上交替发生 ， <code>计算机系统中同时存在多道运行的程序</code></p></li><li><p><code>共享</code>： 资源共享，指系<code>统中的资源可以供内存中多个并发执行的进程共同使用</code></p><ul><li><p>两种共享方式：</p><ul><li><p>互斥共享方式</p><p><img src="http://picgo.wangeyi.ink/image-20220711170408487.png" alt="image-20220711170408487"></p><p>互斥共享的资源称为<code>临界资源，例如打印机等，在同一时刻只允许一个进程访问</code></p></li><li><p>同时共享方式</p><p><img src="http://picgo.wangeyi.ink/image-20220711170428541.png" alt="image-20220711170428541"></p></li></ul></li><li><p><code>例子</code></p><img src="http://picgo.wangeyi.ink/image-20220711170512685.png" alt="image-20220711170512685" style="zoom:80%;" /></li><li><p>并发和共享的关系：<code>互为存在的关系</code></p></li></ul></li><li><p><code>虚拟</code> ： 把物理上的实体变为若干逻辑上的对应物，物理实体是实际存在的、逻辑上的对应物是用户感受到。</p></li><li><img src="http://picgo.wangeyi.ink/image-20220711171045812.png" alt="image-20220711171045812" style="zoom: 50%;" /></li><li><p><code>异步</code>：由于资源的限制，进程执行不是一贯到底的的， <strong>进程以不可预知的速度向前推进</strong></p><ul><li>只有系统用于并发性，才有可能产生异步性</li></ul></li></ul><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p><img src="http://picgo.wangeyi.ink/image-20220711172322481.png" alt="image-20220711172322481"></p><h5 id="运行机制和体系结构"><a href="#运行机制和体系结构" class="headerlink" title="运行机制和体系结构"></a>运行机制和体系结构</h5><blockquote><p>指令：<code>cpu</code>能够识别、执行的最基本的命令</p><p>​特权指令（核心态才能使用），非特权指令</p></blockquote><ul><li><p>两种指令、两种处理器状态、两种程序</p><p><img src="http://picgo.wangeyi.ink/image-20220711172745195.png" alt="image-20220711172745195"></p><blockquote><p>内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</p><p>用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。</p><p>用户程序运行在用户态,操作系统内核运行在内核态。</p></blockquote><blockquote><p>处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。</p><ol><li>系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。</li><li>异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。</li><li>外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。</li></ol></blockquote></li><li><p>操作系统的内核： 操作系统最基本、最核心的部分</p><ul><li><code>时钟管理</code>： 实现计时功能， 进程切换等都需要依赖计时功能</li><li><code>中断处理</code> 实现中断机制</li><li><code>原语</code>：具有原子性：运行只能一气呵成，不可中断</li><li>其他管理功能</li></ul><p><img src="http://picgo.wangeyi.ink/image-20220711172947139.png" alt="image-20220711172947139"></p></li></ul><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><h5 id="中断概念和作用"><a href="#中断概念和作用" class="headerlink" title="中断概念和作用"></a>中断概念和作用</h5><ul><li>中断发生时，CPU立即进入<code>核心态</code><ul><li>”中断“是CPU从用户态进入核心态的唯一途径</li></ul></li><li>中断发生后，当前运行的进程暂停运行，由操作系统内核对中断进行处理</li><li>不同的中断信号，会进行不同的处理</li></ul><blockquote><p>1. </p></blockquote><h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h5><ul><li>内中断（异常、例外、陷入）： <code>信号来源于CPU内部与当前执行的指令有关。</code><ul><li>指令中断：使用<code>系统调用</code>的陷入指令</li><li>软件中断：非法操作码、地址越界、算术溢出。</li><li>硬件故障：缺页中断</li></ul></li><li>外中断（中断）：<code>信号来源于CPU 外部、与当前指令无关</code>， <ul><li>如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</li></ul></li></ul><h5 id="外中断的处理过程"><a href="#外中断的处理过程" class="headerlink" title="外中断的处理过程"></a>外中断的处理过程</h5><blockquote><p>执行完每一条指令之后，CPU检查当前是否由外部中断信号</p><p>如果有，保护中断进程的CPU环境</p><p>转入相应中断处理程序</p><p>恢复原进程的CPU环境并退出中断</p></blockquote><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><blockquote><p>操作系统提供给应用程序使用的接口，可供调用的特殊的函数</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220711195626671.png" alt="image-20220711195626671"></p><ul><li>传递系统调用参数，</li><li>执行陷入指令，<code>陷入指令是在用户态执行的</code> ，引发一个内终端，从而使CPU进入<code>内核态</code></li><li>执行系统调用的相应服务程序（根据系统调用号）（核心态）</li><li>返回用户程序</li></ul><blockquote><p>发出系统调用请求的是在<code>用户态</code></p><p>对系统调用的相应处理是在<code>核心态</code></p><p>陷入指令 是唯一一个只能在用户态执行的指令</p><p>在管态执行的指令： 特权指令</p><p>必须在管态下执行的指令，即<strong>特权指令</strong>。</p><p>特权执行包括：</p><p>（1）有关<strong>对I&#x2F;O设备使用的指令</strong> 如启动I&#x2F;O设备指令、测试I&#x2F;O设备工作状态和控制I&#x2F;O设备动作的指令等。</p><p>（2）有关<strong>访问程序状态的指令</strong> 如对程序状态字（PSW）的指令等。</p><p>（3）**存取特殊寄存器**<strong>指令</strong> 如存取中断寄存器、时钟寄存器等指令。</p></blockquote><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><blockquote><p>程序段、数据段、PCB 三部分组成了<code>进程实体</code>，简称为进程，<code>PCB是进程存在的唯一标志</code></p><blockquote><p>进程是进程实体的<code>运行过程</code>，是系统进行资源分配和调度的一个独立单位。</p></blockquote></blockquote><ul><li>PCB (进程控制块) </li><li>是进程存在的唯一标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级、CPU现场保护区（用于进程切换），占有的资源清单等。<img src="http://picgo.wangeyi.ink/image-20220711201917644.png" alt="image-20220711201917644"></li></ul><h5 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h5><ul><li>链接方式：<ol><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向各个队列的指针<img src="http://picgo.wangeyi.ink/image-20220711202351484.png" alt="image-20220711202351484" style="zoom:50%;" /></li></ol></li><li>索引方式：<br> 1. 根据进程状态的不同，建立几张索引表<br> 2. 操作系统持有指向各个索引的指针<br> 3. <img src="http://picgo.wangeyi.ink/image-20220711202407084.png" alt="image-20220711202407084" style="zoom:50%;" /></li></ul><h5 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h5><blockquote><p>动态性、并发性、独立性、异步性、结构性</p></blockquote><p><code>进程最基本的特征：动态性</code>，进程是程序的一次执行过程，是动态产生、变化和消亡的。</p><p><img src="http://picgo.wangeyi.ink/image-20220711203050666.png" alt="image-20220711203050666"></p><h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><h6 id="三态模型："><a href="#三态模型：" class="headerlink" title="三态模型："></a>三态模型：</h6><p><img src="https://s2.ax1x.com/2019/03/31/AryWDI.png" alt="img"></p><ul><li>运行态： 进程占有处理器，正在运动</li><li>就绪态：具备运行条件，等待系统调度</li><li>阻塞态： 不具备运行条件，等待资源</li><li>切换：<ul><li>运行态-&gt;阻塞态： 等待使用资源，如外设传输</li><li>阻塞态-&gt;就绪态：得到等待的资源</li><li>运行态-&gt;就绪态： 时间片用完；出现更高优先权进程</li><li>就绪态-&gt;运行态：进程调度选择一个就绪进程</li></ul></li></ul><h6 id="另外两种状态"><a href="#另外两种状态" class="headerlink" title="另外两种状态"></a>另外两种状态</h6><ul><li>创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB</li><li>终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源，撤销PCB</li></ul><p><img src="http://picgo.wangeyi.ink/image-20220711203857710.png" alt="image-20220711203857710"></p><h6 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h6><ul><li>创建态-&gt; 就绪态： 系统完成创建进程的一系列工作</li><li>就绪态-&gt;运行态:  进程被调度</li><li>运行态-&gt;就绪态： 时间片用完，或CPU被高优先级进程抢占</li><li>运行态-&gt; 阻塞态：进程使用系统调用申请资源，或请求等待某事件发生 （主动行为：进程自身做出的）</li><li>阻塞态-&gt;就绪态:  申请的资源被分配、等待的事件发生（被动行为）</li><li>运行态-&gt;终止态： 进程运行结束、运行过程中遇到不可修复的错误。</li></ul><blockquote><p>不能由阻塞态直接转换为运行态， 只有就绪态才能被调度</p><p>不能由就绪态直接转换为阻塞态，因为进入阻塞态是一种主动请求（请求系统资源），而就绪态的进程没有分配到处理器资源，不能发出一些主动请求。</p></blockquote><h5 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h5><ul><li>进程控制？， 实现进程状态的转换，用<code>原语</code>实现进程控制</li></ul><blockquote><p>原语：特点是执行期间不允许中断，”不可被中断“的操作称为原子操作</p><p>采用 ”<code>关中断指令</code>“ 和 ”<code>开中断指令</code>“ 实现的</p></blockquote><table><thead><tr><th>更新PCB信息</th><th>修改进程状态标志、保存和恢复运行环境到&#x2F;从PCB</th></tr></thead><tbody><tr><td></td><td>所有进程控制原语一定会修改进程状态标志</td></tr><tr><td>将PCB插入合适的队列</td><td></td></tr><tr><td>分配&#x2F;回收资源</td><td></td></tr></tbody></table><ul><li>创建原语、撤销原语（运行态-|就绪|阻塞-&gt;终止态），</li><li>阻塞原语（运行态-&gt;阻塞态），唤醒原语（阻塞态-&gt;就绪态）<code>阻塞和唤醒要成对出现</code></li><li>切换原语： （运行态-&gt; 阻塞态|就绪态， 就绪态-&gt; 运行态）</li></ul><h5 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h5><blockquote><p>进程之间的信息交换</p><p>各进程拥有的内存地址空间相互独立</p><p>不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同</p></blockquote><p><code>共享存储、消息传递、管道通信</code></p><h6 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h6><blockquote><p> 不同的进程可以将同一个内存页面连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址</p></blockquote><ul><li>共享内存在各种进程间通信方式中具有最高的效率，访问共享内存区域和访问进程独有的内存区域一样快，并不需要通过系<strong>统调用或者其它需要切入内核的过程</strong>来完成</li></ul><h6 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h6><blockquote><p>管道：用于连接读写进程的一个共享文件、在内存中开辟的一个大小固定的缓冲区</p></blockquote><ul><li>匿名管道<ul><li>特殊的文件，只存在于内存中</li><li>只能用于父子进程、兄弟进程之间，必须用于具有亲缘关系的进程间的通信</li><li>半双工</li></ul></li><li>有名管道：<ul><li>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</li><li>有名管道可以在不具有亲缘关系的进程间进行通信。</li></ul></li><li>管道不适合进程间频繁地交换数据</li></ul><h6 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h6><blockquote><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</p></blockquote><p>进程通过操作系统提供的 ”发送消息、接收消息“两个原语进行数据交换 </p><h6 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h6><blockquote><p> 信号量是一个计数器，可以用来控制多个进程对共享资源的访问</p></blockquote><ul><li><p>控制信号量有两种原子操作：</p><ul><li>一个是<code>P操作</code>，这个操作会把信号量减去1，相减后如果信号量&lt;0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量&gt;&#x3D;0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是<code>V操作</code>，这个操作会把信号量加上1，相加后如果信号量&lt;&#x3D;0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量&gt;0，则表明当前没有阻塞中的进程。</li></ul><blockquote><p>P操作是用在进入共享资源之前，V操作是用在离开共享资源之后，这两个操作是必须成对出现的</p></blockquote></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>线程是一个基本的CPU执行单元，是程序执行的基本单位</p><p><code>内核级线程才是处理器分配的单位</code></p><p>进程是资源分配的基本单元</p></blockquote><p>进程与线程的区别</p><ol><li><code>定义</code>：进程是资源分配的最小单位、线程是程序执行的最小单位</li><li><code>内存分配</code>： 进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。</li><li><code>通信</code>：进程之间的通信需要借助操作系统，线程可以直接读写进程<code>数据段</code>（如全局变量）进行通信</li><li><code>系统开销</code> ： <ol><li>进程切换需要切换虚拟地址空间、切换内核栈和硬件上下文，页表切换等，开销较大。</li><li>线程切换 只需保存少量寄存器内容，开销较小。</li></ol></li></ol><ul><li><p>一个进程可以创建几个线程？</p><p>一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，</p><p>过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。</p></li></ul><h3 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h3><blockquote><p>确定某些规则和决定处理任务的顺序</p></blockquote><h5 id="进程的七状态模型"><a href="#进程的七状态模型" class="headerlink" title="进程的七状态模型"></a>进程的七状态模型</h5><ul><li>挂起态：暂时调到外存等待的进程状态<ul><li>就绪挂起</li><li>阻塞挂起</li></ul></li><li><img src="http://picgo.wangeyi.ink/image-20220713213825314.png" alt="image-20220713213825314"></li></ul><h5 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h5><blockquote><p>需要进行进程调度和切换的情况</p><p>  1.主动放弃： 进程正常结束、运行过程中发生异常而终止、进程主动请求阻塞（等待I&#x2F;O）</p><ol start="2"><li>被动放弃：时间片用完（分时系统）、中断处理、被高优先级进程抢占（抢占调度系统中）</li></ol><p>不能进程进程调度</p><ol><li><p>处理中断的过程中，中断处理程序执行过程中</p></li><li><p>进程在操作系统<code>内核程序临界区</code>中</p><img src="http://picgo.wangeyi.ink/image-20220713214710505.png" alt="image-20220713214710505" style="zoom: 50%;" /></li><li><p>需要完全屏蔽中断的原子操作过程中</p></li></ol></blockquote><h6 id="调度的方式"><a href="#调度的方式" class="headerlink" title="调度的方式"></a>调度的方式</h6><ul><li>非抢占方式：只允许进程主动放弃CPU</li><li>抢占方式：优先处理更紧急的进程，进程执行被中断</li></ul><h6 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h6><ul><li><p>CPU 利用率 ： 指CPU “忙碌”时间占用总时间的比例</p><img src="http://picgo.wangeyi.ink/image-20220713215618372.png" alt="image-20220713215618372" style="zoom:50%;" /></li><li><p>系统吞吐量： 单位时间内完成作业的数量</p><img src="http://picgo.wangeyi.ink/image-20220713215717667.png" alt="image-20220713215717667" style="zoom:50%;" /></li><li><p>周转时间： 指从<code>作业被提交到系统</code>，到作业完成为止的<code>时间间隔</code></p><ul><li><p>在外存中等待<code>作业调度</code>的时间</p></li><li><p>进程在就绪队列中等待<code>进程调度</code>的时间</p></li><li><p>进程在CPU中执行的时间</p></li><li><p>进程等待I&#x2F;O操作的时间</p><p><img src="http://picgo.wangeyi.ink/image-20220713220043811.png" alt="image-20220713220043811"></p></li><li><p><img src="http://picgo.wangeyi.ink/image-20220713220125949.png" alt="image-20220713220125949"></p></li><li><p>带权周转时间： &gt;&#x3D; 1 , 带权周转时间越小越好</p><p><img src="http://picgo.wangeyi.ink/image-20220713220208743.png" alt="image-20220713220208743"></p></li></ul></li><li><p>等待时间：指进程、作业处于等待处理机状态时间之和。</p><ul><li>等待IO完成的时间是<code>不计入等待时间</code>中的</li></ul></li><li><p>响应时间：<u>用户从提交请求到首次产生响应所用的时间。</u></p></li></ul><h6 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h6><ul><li><p>先来先服务（FCFS）： 按照请求的顺序进行调度</p><p><code>非抢占式的调度算法， FCFS 对于长作业有利，对短作业不利</code>： 短作业必须等待前面的长作业完成才能执行，等待时间过长。</p></li><li><p>短作业优先（SJF- shortest job first）：按估计允许时间最短的顺序进行调度，  每次调度选择当前已经到达且运行时间最短的 作业&#x2F;进程</p><p><code>非抢占式的调度算法 , 对短作业有利、对长作业不利</code>：</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。</p></li><li><p>最短剩余时间优先算法 shortest remaining time next（SRTN）</p><p><code>最短作业优先的抢占式版本</code></p><p>每当有新进程加入<code>就绪队列</code> 就需要调度，进程完成时也需要进行调度</p><p>如果新达到的进程<code>剩余运行时间</code> 比当前运行的进程的剩余时间<code>更短</code>， 则新进程 <code>抢占CPU</code></p></li><li><p>高响应比优先算法（HRRN, Highest Response Ratio Next）</p><p>每次调度时先计算各个作业进程的响应比，选择响应比高的进程</p><p><img src="http://picgo.wangeyi.ink/image-20220714203623890.png" alt="image-20220714203623890"></p><p><code>非抢占式调度算法</code></p></li></ul><hr><ul><li><p>时间片轮转调度算法（RR）</p><p>按照各进程到达<code>就绪队列</code>顺序（FCFS），轮流让各个进程执行一个时间片，时间片用完时，由<code>计时器发出时钟中断</code>，调度程序停止该进程的执行，将进程重新放入就绪队列的队尾，时间片分配给队首的进程。</p><p><code>抢占式调度算法</code></p><blockquote><p>优缺点</p><p>公平，响应快，适用于分时操作系统，</p><p>高频率的进程切换，有一定的开销，不能够区分任务的紧急程度。</p></blockquote><p>时间片轮转调度算法的效率 和<code>时间片的大小</code> 有很大的关系：</p><ul><li>时间片太小：由于进度切换都要保存进程的信息和载入新的进程信息，进程切换太频繁，在进程切换上会花过多时间</li><li>时间片太大：退化外先来先服务调度，会增大进程的响应时间，实时性得不到保证。</li></ul></li><li><p>优先级调度算法   </p><p>为每个进程分配一个优先级，按优先级进行调度。</p><p><img src="http://picgo.wangeyi.ink/image-20220714211209575.png" alt="image-20220714211209575"></p><blockquote><p>静态优先级： 创建进程时确定，之后一直不变</p><p>   有可能导致低优先级进行饥饿</p><p>动态优先级： 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级</p></blockquote><p><code>非抢占式</code> ： 进程主动放弃处理机的时候进行调度</p><p><code>抢占式</code> ： 就绪队列发生改变，判断是否发生抢占</p></li><li><p>多级反馈队列调度算法</p><p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。</p><p>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片未结束，则进程进入下一级队列队尾。</p><p>如果此时己经在最下级的队列，则重新放回 队列队尾</p><p> 只有第k级队列为空时， 才会为k+1 级队头的进程分配时间片。</p><p>被抢占处理机的进程重新放回原队列队尾</p><blockquote><p>优缺点</p><p>对各类型进程相对公平（FCFS）</p><p>新到达的进程都可以得到很快的 响应 RR</p><p>短进程等待时间短</p><p>有可能导致饥饿</p></blockquote><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/操作系统-6-1.png" style="zoom:50%;" /><p><code>抢占式调度算法</code>。</p></li></ul><h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><blockquote><p>异步性： 各并发执行的进程以各自独立的、不可预知的速度向前推进</p><p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系</p></blockquote><h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><blockquote><p>多个进程在同一时刻只有一个进程能进入临界区。</p></blockquote><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">// entry section  进入区 ： 设置正在访问临界资源的标志，（上锁）</span><br><span class="line">// critical section; 临界区</span><br><span class="line">// exit section 退出区 解除正在访问临界资源标志（解锁）</span><br></pre></td></tr></table></figure><h6 id="进程互斥遵循的原则"><a href="#进程互斥遵循的原则" class="headerlink" title="进程互斥遵循的原则"></a>进程互斥遵循的原则</h6><p><img src="http://picgo.wangeyi.ink/image-20220715202520230.png" alt="image-20220715202520230"></p><h6 id="互斥的软件实现"><a href="#互斥的软件实现" class="headerlink" title="互斥的软件实现"></a>互斥的软件实现</h6><ul><li><p>单标志法</p><p><img src="http://picgo.wangeyi.ink/image-20220715204014338.png" alt="image-20220715204014338"></p><p><code>违背 “空闲让进原则”</code>：如果此时允许进入临界区的是p0，但是p0一直不访问临界区，则临界区空闲时，不允许p1访问。</p></li><li><p>双标志法</p><p><img src="http://picgo.wangeyi.ink/image-20220715204207407.png" alt="image-20220715204207407"></p><p><code>违背忙着等待</code>：进入区的 检查 和 上锁 两个处理不是 原子性的， “上锁之前”可能发生进程切换</p></li><li><p>双标志后检查： 先上锁、后检查</p><p><img src="http://picgo.wangeyi.ink/image-20220715204411613.png" alt="image-20220715204411613"></p><p><code>违背“空闲让进，有限等待”</code></p></li><li><p>peterson （皮特森）算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">boolean flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procedure0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;   <span class="comment">// 表示进程0 想进入临界区</span></span><br><span class="line">        <span class="comment">//调度关系有可能 flag[0] = flag[1] = true;  标记法可能出现 死锁</span></span><br><span class="line">turn=<span class="number">1</span>;<span class="comment">//可以优先让进程1 进入临界区//原子 </span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]&amp;&amp;turn==<span class="number">1</span>) <span class="comment">/*若flag[1]为false，P0就进入临界区；若flag[1]为tureP0循环等待，只要P1退出临界区，P0即可进入*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* donothing*/</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 进入区</span></span><br><span class="line"><span class="built_in">visit</span>();<span class="comment">/*访问临界区*/</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;<span class="comment">/*访问临界区完成，procedure0释放出临界区*/</span></span><br><span class="line"><span class="comment">/*remainder section*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procedure1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">turn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]&amp;&amp;turn==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* donothing*/</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">visit</span>();<span class="comment">/*访问临界区*/</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;<span class="comment">/*访问临界区完成，procedure1释放出临界区*/</span></span><br><span class="line"><span class="comment">/*remainder section*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">flag[<span class="number">0</span>]=flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*start procedure0 and procedure1*/</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="互斥的硬件实现"><a href="#互斥的硬件实现" class="headerlink" title="互斥的硬件实现"></a>互斥的硬件实现</h6><ul><li><p>中断屏蔽</p><p>利用 “ 开&#x2F;关中断指令” 实现</p><p><code>简单、高效</code>， 不适用于多处理机，不适用于用户进程</p></li><li><p>TS <code>TestandSetLock</code> 指令</p><p>把 “上锁” 和 “检查” 操作用硬件的方式编程原子操作。</p><p><img src="http://picgo.wangeyi.ink/image-20220715210233138.png" alt="image-20220715210233138"></p><p>&#96;&#96;</p></li><li><p>swap 指令 <code>EXCHANGE XCHG</code></p><p><img src="http://picgo.wangeyi.ink/image-20220715210223366.png" alt="image-20220715210223366"></p></li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><blockquote><p>信号量：其实就是一个变量（可以是整数、也可以是更为复杂的记录型变量），表示系统中某种资源的数量。</p><pre><code> 1. 可以用一对`原语` ： wait(S) , signal(S)  操作信号量， `括号里的信号量S 其实就是传入函数的一个参数`。 2.  wait(S) , signal(S)   -&gt;  P （消费资源）和 V （产生）操作. 3. wait(S)  相当于进入区 4. signal(S)  相当于退出区</code></pre></blockquote><h6 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h6><ul><li><p>整数型的变量作为信号量， 表示系统中的某种资源的数量。<code>信号量的操作只有三种： 初始化、P操作，v操作</code></p><p><code>不满足 “让权等待，会出现“忙等”</code></p></li></ul><h6 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h6><ul><li><p>记录型数据结构表示的信号量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">semaphore</span> &#123; <span class="comment">// 信号量</span></span><br><span class="line"><span class="type">int</span> value; <span class="comment">//资源个数</span></span><br><span class="line">PCB *queue;  <span class="comment">//信号量上的进程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P</span>(semaphore S) &#123;   <span class="comment">// 消费资源</span></span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(s.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">sleep</span>(s.queue);  <span class="comment">// 使进程进入阻塞态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">V</span>(semaphore S) <span class="comment">// 产生资源</span></span><br><span class="line">&#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span>(s.value &lt;= <span class="number">0</span>) <span class="comment">// 表示等待队列中 还有进程在等待资源</span></span><br><span class="line">        <span class="built_in">wakeup</span>(s.queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h6><blockquote><p>互斥量： 信号量的值只能取 <code>1</code> 或  0  </p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex); <span class="comment">// P 操作</span></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex); <span class="comment">// v 操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h6><blockquote><p>让各并发进程按要求有序地推进</p><p>设置同步信号量 的 初始值 为 0</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220716193654857.png" alt="image-20220716193654857"></p><h3 id="生产者-消费者-问题"><a href="#生产者-消费者-问题" class="headerlink" title="生产者-消费者 问题"></a>生产者-消费者 问题</h3><blockquote><p>生产者进程： 每次生产一个产品放入缓冲区</p><p>消费者进程： 每次从缓冲区中取出一个产品并使用</p><p>（产品 &#x3D;&#x3D; 某种数据）</p></blockquote><ul><li><code>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则等待</code></li><li><code>只有缓冲区不空时，消费者才能从中取出产品。否则等待</code></li><li><code>缓冲区是临界资源，必须互斥访问</code></li></ul><h6 id="如何用信号量的P、V操作实现生产者-消费者问题"><a href="#如何用信号量的P、V操作实现生产者-消费者问题" class="headerlink" title="如何用信号量的P、V操作实现生产者-消费者问题"></a>如何用信号量的P、V操作实现生产者-消费者问题</h6><blockquote><p>分析： </p><ol><li>缓冲区满时，生产者进程必须等待  – 同步问题</li><li>缓冲区为空时，消费者进程必须等待 – 同步问题</li><li>缓冲区时临界资源，互斥方位 – 互斥问题</li></ol><p><code>三对PV操作</code></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semaphore mutes = <span class="number">1</span>;  <span class="comment">// 互斥信号量</span></span><br><span class="line">semaphore empty = n;  <span class="comment">// 同步信号量， 空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;  <span class="comment">// 同步信号量, 非空缓冲区的数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">producer</span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> item = <span class="built_in">produce_item</span>(); <span class="comment">// 生产一个产品</span></span><br><span class="line"><span class="built_in">P</span>(empty); <span class="comment">// 消耗一个空缓冲区</span></span><br><span class="line"><span class="built_in">P</span>(mutex); <span class="comment">// 互斥</span></span><br><span class="line"><span class="built_in">insert_item</span>(item); <span class="comment">// 把产品放入缓冲区</span></span><br><span class="line">        <span class="built_in">V</span>(mutex); <span class="comment">// 互斥</span></span><br><span class="line">        <span class="built_in">V</span>(full);  <span class="comment">//增加一个产品</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">consumer</span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">P</span>(full); <span class="comment">// 消耗一个产品</span></span><br><span class="line"><span class="built_in">P</span>(mutex); <span class="comment">// 互斥</span></span><br><span class="line"><span class="type">int</span> item = <span class="built_in">remove_item</span>();</span><br><span class="line"><span class="built_in">consume_itme</span>(item);</span><br><span class="line">        <span class="built_in">V</span>(mutex); <span class="comment">// 互斥</span></span><br><span class="line"><span class="built_in">V</span>(empty); <span class="comment">// 增加一个空闲缓冲区 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现互斥的P操作一定要在实现同步的P操作之后。</li><li>两个V操作顺序可以交换</li></ul><h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h5><p>设置一个COUNT 计数器来记录当前正在访问共享文件的进程数，</p><p>利用互斥信号量实现对count变量的检查和赋值不会被中断</p><blockquote><ol><li>允许多个读者同时对文件执行读操作</li><li>只允许一个写进程往文件中写信息</li><li>任一写进程在完成写操作之前，不允许其他读进程或写进程工作</li><li>写进程执行写操作之前，应让已有的读写进程全部退出</li></ol><p>分析：</p><ol><li>写进程之间互斥、写进程与读进程之间互斥   </li><li>读进程之间不互斥</li><li>读进程互斥访问count</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semaphore rw =<span class="number">1</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">//读进程互斥访问count</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前几个读进程在访问文件</span></span><br><span class="line"><span class="built_in">writer</span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">p</span>(rw);</span><br><span class="line"><span class="comment">//写文件</span></span><br><span class="line"><span class="built_in">v</span>(rw);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reader</span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">p</span>(mutex);</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">p</span>(rw); <span class="comment">// 第一个读进程负责 “加锁” </span></span><br><span class="line">         count ++;</span><br><span class="line"><span class="built_in">v</span>(mutex);</span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="built_in">p</span>(mutex);</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">v</span>(rw); <span class="comment">// 最后一个读进程负责解锁</span></span><br><span class="line">        <span class="built_in">v</span>(mutex);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读者优先 ， 写进程可能会饥饿</span></span><br><span class="line">semaphore w = <span class="number">1</span>; <span class="comment">// 用于实现写优先</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="http://picgo.wangeyi.ink/image-20220716204845429.png" alt="image-20220716204845429" style="zoom: 50%;" /><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><blockquote><p>管程：特殊的软件模块</p><pre><code>1. 局部于管程的共享数据结构说明。 // 临界资源（进程之间共享的数据）1. 对于该数据结构进行操作的`一组过程`。 //“函数”1. 对共享数据设置`初始值`的语句1. 管程有一个名字。</code></pre><p>“ 类似于类class”</p><p>基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问。</li><li>进程只能通过调用管程的过程才能访问管程的共享数据；</li><li><code>每次只允许一个进程在管程内执行某个管程过程。</code><ol><li>这种互斥特性是由编译器实现的</li></ol></li></ol><p>管程引入了   <strong>条件变量</strong>   以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220717172300260.png" alt="image-20220717172300260"></p><p>管程实现生产者-消费者问题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer </span><br><span class="line">    condition full, empty: <span class="comment">//交件交量用来实现同步（排队) ，条件变量</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//级冲区中的产品数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(Item item)</span> </span>&#123; <span class="comment">//把产品item放人續冲区 </span></span><br><span class="line">        <span class="keyword">if</span> (count == N)    <span class="comment">// 缓冲区满，</span></span><br><span class="line">            <span class="built_in">wait</span> (full); </span><br><span class="line">        count++: </span><br><span class="line">        <span class="built_in">insert_item</span> (item); </span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>)   <span class="comment">// 唤醒等待在empty 队列的进程</span></span><br><span class="line">            <span class="built_in">signal</span>(empty); </span><br><span class="line">    &#125; </span><br><span class="line"><span class="function">Item <span class="title">remove</span> <span class="params">()</span> </span>&#123; <span class="comment">//从银冲区中成盛一个产品 </span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) </span><br><span class="line">            <span class="built_in">wait</span> (empty); </span><br><span class="line">        count--; </span><br><span class="line">        <span class="keyword">if</span> (count == N<span class="number">-1</span>)  <span class="comment">// 缓冲区为满 唤醒生产者</span></span><br><span class="line">            <span class="built_in">signal</span>(full); </span><br><span class="line">        <span class="keyword">return</span> remove item):</span><br><span class="line">    &#125;</span><br><span class="line">end monitor;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p>并发环境下，多个进程因竞争资源而造成的一种<code>互相等待对方手里的资源</code>，导致各进程阻塞，都无法向前推进</p></blockquote><h6 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h6><ul><li>互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待</li><li>不可剥夺条件： 进程所获得的资源在未使用完之前，<code>不能由其他进程强行夺走</code>，只能主动释放</li><li>请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。  （进程已经保持了至少一个资源，但又提出了新的资源请求，对自身持有的资源保持不放）</li><li>循环等待条件： 存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。<ul><li><code> 注意！发生死锁时一定有循环等待，但是发生循环等 待时末必死锁 （循环等待是死锁的必要不充分条件）</code></li></ul></li></ul><h6 id="发生死锁"><a href="#发生死锁" class="headerlink" title="发生死锁"></a>发生死锁</h6><ul><li>对系统资源的竞争： 各进程对不可剥夺的资源的竞争可能引起死锁。</li><li>进程推荐的顺序非法， 请求和释放资源的顺序不当。</li><li>信号量的使用不当。</li></ul><p><code>对不可剥夺资源的分配不合理的使用，可能出现死锁</code></p><h6 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h6><ul><li><p>鸵鸟策略 ： 忽略死锁。</p><p><code>在死锁不会对用户操作过大影响，或者发生死锁的概率很低的情况下。</code></p></li><li><p>死锁预防：在<code>程序运行之前</code>预防发生死锁，破环四个必要条件的一个或多个。</p></li><li><p>死锁避免：在程序运行时避免发生死锁。</p></li><li><p>死锁的检测和解除:  检测到死锁发生时，采取措施进行恢复。</p></li></ul><h6 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h6><blockquote><p>静态策略</p><p>破环死锁产生的必要条件： 互斥条件、不可剥夺条件、请求和保持条件、循环等待条件。</p></blockquote><ul><li><p>破坏互斥条件：</p><p> 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程 <strong>SPOOLing 技术</strong></p></li><li><p>破环不可剥夺条件：</p><p>1。 某个进程请求新资源时得不到满足，必须释放保持的所有资源。  ———  主动释放，自己体面</p><p>2。 操作系统协助抢占资源，（进程优先级）。 ——— 帮它体面</p><p><code>缺点</code>  ：实现复杂，释放资源可能导致前一阶段的工作失效，</p><p>反复的申请、释放资源会增加系统开销，降低系统吞吐量。</p></li><li><p>破环请求和保持条件：</p><p><code>静态分配法</code> ：进程在运行之前一次性申请完它所需要的全部资源。</p><p><code>缺点：</code> 资源利用率极低，可能导致某种进程饥饿</p></li><li><p>破坏循环等待条件：</p><p><code>顺序资源分配法：</code>  给资源统一编号，进程只能按编号顺序来请求资源。</p><p><code>缺点</code> 不方便增加新设备，可能需要重新分配所有编号，导致资源浪费、用户编程麻烦。</p></li></ul><h6 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h6><blockquote><p>动态策略</p><p>银行家算法</p></blockquote><ul><li><p>安全状态（安全序列）：系统按照这种序列分配资源，则每个进程 都能顺利完成。安全序列可能有多个</p><p>安全状态： 一定不会发生死锁</p><p>不安全状态： 有可能发生死锁</p></li></ul><p><code>银行家算法：</code>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态。</p><p><img src="http://picgo.wangeyi.ink/image-20220717205455844.png" alt="image-20220717205455844"></p><h6 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h6><blockquote><p>死锁检测算法</p><p>死锁解除算法</p></blockquote><ul><li><p>死锁检测算法</p><p><code>数据结构</code> 资源分配图</p></li></ul><p><img src="http://picgo.wangeyi.ink/image-20220717210029820.png" alt="image-20220717210029820"></p><p><img src="http://picgo.wangeyi.ink/image-20220717210228789.png" alt="image-20220717210228789"></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h5 id="内存是什么"><a href="#内存是什么" class="headerlink" title="内存是什么"></a>内存是什么</h5><blockquote><p>内存是用于存放数据的硬件，程序执行之前需要先放到内存中才能被CPU处理</p></blockquote><h5 id="内存管理做什么"><a href="#内存管理做什么" class="headerlink" title="内存管理做什么"></a>内存管理做什么</h5><blockquote><ol><li>操作系统负责内存空间的分配和回收</li><li>提供某种技术从逻辑上对内存空间进行扩充</li><li>负责地址转换，逻辑地址-&gt; 物理地址</li><li>内存保护， 保证各进程在各自空间内独立运行，互不干扰<ol><li>设置上、下限寄存器，存放进程的上下限地址</li><li>重定位寄存器（基址寄存器 存放起始的物理地址）和界地址寄存器（限长寄存器 ，存放最大逻辑地址）</li></ol></li></ol></blockquote><h5 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h5><h6 id="逻辑地址vs物理地址"><a href="#逻辑地址vs物理地址" class="headerlink" title="逻辑地址vs物理地址"></a>逻辑地址vs物理地址</h6><blockquote><p>逻辑地址（相对地址）相对于进程在内存中的起始地址而言的地址</p><p>物理地址（绝对地址）内存中的实际位置</p></blockquote><h6 id="逻辑地址-gt-物理地址的转换-（重定位）"><a href="#逻辑地址-gt-物理地址的转换-（重定位）" class="headerlink" title="逻辑地址-&gt;物理地址的转换 （重定位）"></a>逻辑地址-&gt;物理地址的转换 （重定位）</h6><ul><li><p>静态重定位：可重定位装入</p><p>再程序执行之前进行重定位（把逻辑地址转换为物理地址）</p><p><code>作业装入内存：</code>必须为其分配要求的全部内存空间，否则不能装入</p><p><code>作业在运行期间就不能再移动</code></p></li><li><p>动态重定位：动态运行时装入</p><p>装入程序时不能进行重定位，<code>在程序运行时才进行地址转换</code></p><p><code>运行程序在内存中移动</code>， 能够动态分配内存</p></li></ul><h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><blockquote><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接</p></blockquote><ul><li><p>静态链接： <code>程序运行之前</code>， 把各目标模块以及所需的库函数链接成一个完整的可执行文件。</p><blockquote><p>在使用静态链接库的情况下，在编译链接可执行文件时，链接器会复制静态链接库中的<code>函数和数据</code>，与程序的其他模型组合创建可执行文件。</p></blockquote><p><code>空间浪费</code>： 由于每个可执行文件都需要一个静态链接库的副本，当出现多个程序依赖同一个静态链接库，就会出现在内存中存在多个副本的情况。</p><p><code>更新困难</code>：当修改了库函数的代码时，需要重新编译链接形成可执行晚间。</p><p><code>运行速度快</code>：可执行文件在运行前已经包含需要的所有函数和数据，在执行的时候运行速度快。</p></li><li><p>动态链接：程序执行过程中需要该目标模块时，才对它进行链接</p><p><code>共享库</code>： 就是即使每个程序都依赖于同一个库，也不会像静态链接库那样在内存中存在多个副本，而是这些程序共享同一个库文件</p><p><code>更新方便：</code> 更新只需替换原来的目标文件，不需要重新连接一遍，</p><p><code>性能损耗</code> 每次执行程序时都要进行连接，性能有一定损失。</p></li></ul><h5 id="内存空间扩充"><a href="#内存空间扩充" class="headerlink" title="内存空间扩充"></a>内存空间扩充</h5><blockquote><p>物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</p><p>​<code>覆盖技术</code> <code>交换技术  </code>虚拟内存技术 </p></blockquote><ul><li><p>覆盖技术：将程序分为多个段（模块），常用的段常驻内存，不常用的段需要时调入内存。</p><p>​常驻内存的段放在 “<code>固定区</code>”，调入就不再调出</p><p>​不常用的段放在 “<code>覆盖区</code>”，需要时调入内存，用不到时调出内存</p><p><code>缺点</code>：必须由用户声明覆盖结构，对用户不透明</p></li><li><p>交换技术：内存空间紧张的时候，系统将内存中某些进程暂时换出内存，把外存中具备运行条件的进程换入内存。PCB 会常驻内存</p></li></ul><h5 id="内存空间的分配于回收"><a href="#内存空间的分配于回收" class="headerlink" title="内存空间的分配于回收"></a>内存空间的分配于回收</h5><blockquote><p> 连续分配管理方式 ： 单一连续、固定分区、动态分区</p><p>​非连续分配管理：</p><p>区别： 连续分配：为用户进程分配的必须是连续的内存空间</p><p>​非连续： 为用户进程分配的可以是一些分散的内存空间</p><p><img src="http://picgo.wangeyi.ink/image-20220718204412405.png" alt="image-20220718204412405"></p></blockquote><h6 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h6><ul><li><p>单一连续分配 ： 内存分为<code>系统区</code> 和<code>用户区</code>，内存中只能有一道用户程序。</p><p><code>优点</code> 实现简单，无外部碎片</p><p><code>缺点</code> 只适用于单用户、单任务的操作系统，有内部碎片</p></li><li><p>固定分区分配： 用户空间划分为若干个<code>固定大小的分区</code>。每个分区只装入一道作业。</p><p><code>分区大小相等</code>  缺乏灵活性，适用于一台计算机控制<code>多个相同对象的场合</code></p><p><code>分区大小不等</code>增加了灵活性</p><p><code>优点</code> 实现简单，无外部碎片</p><p><code>缺点</code> 可能产生内部碎片，内存利用率低</p></li><li><p>动态分区分配：不会预先划分分区，在进程装土内存时根据进程的大小动态建立分区。</p></li></ul><p>​<code>没有内部碎片，但是有外部碎片</code>，外部碎片可以用”紧凑技术“来解决</p><hr><p>  <code>动态分区分配算法</code></p><blockquote><p>在动态分区分配方式中，当多个空闲分区都能满足需求时，应选择哪个分区进行分配</p></blockquote><ul><li><p>首次适应算法：<code>每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</code></p><p>空闲分区按照<code>地址递增</code>的次序排列，每次分配内存的时候顺序查找空闲分区链（表），找到大小能满足的第一个空闲分区</p><p><code>缺点</code> 每次查找都要从头查找，查找开销较大</p></li><li><p>最佳适应算法：<code>优先使用更小的分区</code>， </p><blockquote><p>因为动态分区是一种连续分配方式，分配的空间是连续整片区域，为了保证内存需求大的进程到来时能有足够大的连续空间，尽可能留下大片的空闲区。</p></blockquote><p>空闲分区按照<code>容量递增</code>的次序排列，每次分配内存时顺序查找空闲分区链（表），找到大小能够满足要求的第一个空闲分区。</p><p><code>缺点</code> 每次都使用最小分区进行分配，会产生越来越多不能使用的小内存快，这种方法会产生很多<code>外部碎片</code>。</p></li><li><p>最坏适应算法：<code>优先使用最大的连续空间</code>，为了解决最佳适应产生外部碎片的问题</p><p>空闲分区按照<code>容量递减</code>的次序排列，每次分配内存时顺序查找空闲分区链（表），找到大小能够满足要求的第一个空闲分区。</p><p><code>缺点</code>： 导致较大的连续空间迅速用完。</p></li><li><p>领近适应算法：<code>如果每次都从上次查找结束的位置开始检索</code></p><p>空闲分区以<code>地址递增</code>的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p></li></ul><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应</td><td>从头到尾找适合的分区</td><td>空闲分区以地址递增次序排列</td><td>综合看性能最好。<strong>算法开销小</strong>，回收分区后一.般不需要对空闲分区队列重新排序</td><td></td></tr><tr><td>最佳适应</td><td>优先使用更小的分区，以保留更多大分区</td><td>空闲分区以容量递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多太小的、难以利用的碎片;<strong>算法开销大</strong>，回收分区后可能需要对空闲分区队列重新排序</td></tr><tr><td>最坏适应</td><td>优先使用更大的分区，以防止产生太小的不可用的碎片</td><td>空闲分区以容量递减次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区容易被用完，不利于大进程;<strong>算法开销大</strong>(原因同上)</td></tr><tr><td>邻近适应</td><td>由首次适应演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增次序排列(可排列成循环链表)</td><td>不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong>(原因同首次适应算法)</td><td>会使高地址的大分区也被用完</td></tr></tbody></table><h6 id="非连续分配"><a href="#非连续分配" class="headerlink" title="非连续分配"></a>非连续分配</h6><blockquote><p>基本分页存储管理、基本分段存储管理、段页式存储管理</p></blockquote><h5 id="基本分页存储管理："><a href="#基本分页存储管理：" class="headerlink" title="基本分页存储管理："></a>基本分页存储管理：</h5><blockquote><p>把内存分为大小相等的分区（页框、页帧、内存块、物理块），将用户的进程的地址空间也分为于页框大小相等的 区域（页，页面）。</p></blockquote><p> <code>如何实现地址转换</code> ：</p><p> 逻辑地址对应的页号 -&gt; <code>页号对应页面在内存中的起始地址</code> -&gt; 逻辑地址在页面内的 <code>偏移</code> -&gt; 物理地址 &#x3D; 页面起始地址 + 偏移。</p><p><img src="http://picgo.wangeyi.ink/image-20220718213845792.png" alt="image-20220718213845792"></p><h6 id="页表-：-每个进程对应一个页表"><a href="#页表-：-每个进程对应一个页表" class="headerlink" title="页表 ： 每个进程对应一个页表"></a>页表 ： 每个进程对应一个页表</h6><blockquote><p>记录进程页面和实际存放的内存块之间的对应关系</p><ol><li>一个进程对应一张页表</li><li>进程的每一页对应一个页表项</li><li>每个页表项由 ”页号“ 和  ”块号“ 组成</li><li>记录进程页面和实际存放的内存块之间的对应关系</li></ol></blockquote><h6 id="基本地址转换"><a href="#基本地址转换" class="headerlink" title="基本地址转换"></a>基本地址转换</h6><p><img src="http://picgo.wangeyi.ink/image-20220721143136169.png" alt="image-20220721143136169"></p><blockquote><ol><li>CPU给出逻辑地址，由某个硬件计算得到页号、页内偏移</li><li>比较页号与页表长度，页号大于等于页表长度，则产生越界中断，否则继续执行</li><li>查询页表，找到页号对应的页表项，确定内存块号</li><li>用内存块号和页内偏移计算得到物理地址</li></ol></blockquote><h6 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h6><p><code>局部性原理</code></p><blockquote><p>分为时间局部性和空间局部性两种</p><p><code>时间局部性</code> 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(<em>因为程序中存在大量的循环</em>)</p><p><code>空间局部性</code>旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(<em>因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的</em>)</p></blockquote><p><code>快表（联想寄存器TLB）</code>  ：访问速度比内存快的高速缓冲寄存器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><h6 id="引入快表的地址转换过程"><a href="#引入快表的地址转换过程" class="headerlink" title="引入快表的地址转换过程"></a>引入快表的地址转换过程</h6><blockquote><p>1.CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p><p>2.如果快表命中，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后根据物理地址访问内存</p><p>3.如果快表没有命中，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，同时将这个页表项存入快表，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元</p></blockquote><h6 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h6><ul><li><p>单级页表的问题</p><blockquote><ol><li>页表必须连续存储，当页表很大时，需要占用很多个连续的页框</li><li>没必要让整个页表常驻内存</li></ol></blockquote></li><li><p>两级页表的原理、结构</p><p><img src="http://picgo.wangeyi.ink/image-20220721150054880.png" alt="image-20220721150054880"></p><p><code>逻辑地址的结构发生变化</code></p><p><img src="http://picgo.wangeyi.ink/image-20220721150130035.png" alt="image-20220721150130035"></p></li></ul><h5 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h5><blockquote><p>进程的地址空间： 按照程序<code>自身的逻辑关系</code>划分为若干个段，段的长度是取决于用户编写的程序。</p><p>内存分配： 以段为单位进行分配，每个段在内存中战连续空间，但各段之间可以不相邻</p></blockquote><p>分段系统的逻辑地址由<code>段号</code> 和<code>段内地址</code> 组成</p><h6 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h6><ul><li>记录逻辑段到实际存储位置的映射关系</li></ul><blockquote><ol><li>每个段对应一个段表项，记录起始位置（基址） 和段的长度</li><li>各个段表的长度是相同的，段号是隐含的，不占用存储空间</li></ol></blockquote><h6 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h6><p><img src="http://picgo.wangeyi.ink/image-20220721152213875.png" alt="image-20220721152213875"></p><h5 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h5><h6 id="分页、分段管理的优缺点"><a href="#分页、分段管理的优缺点" class="headerlink" title="分页、分段管理的优缺点"></a>分页、分段管理的优缺点</h6><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页</td><td>内存利用率高、不会产生外部碎片，只会有少量页内碎片</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段</td><td>方便按照逻辑模块实现信息的共享和保护</td><td>会产生外部碎片</td></tr></tbody></table><blockquote><p>将进程按照逻辑模块分段，再将各段分页</p><p>再将内存空间分为大小相同的内存块，</p><p>进程将各页面装入内存块中</p></blockquote><p><code>逻辑地址结构</code> 段号  + 页号 + 页内偏移</p><p><img src="http://picgo.wangeyi.ink/image-20220721153853558.png" alt="image-20220721153853558"></p><p>段表、页表</p><blockquote><p>一个进程对应一个段表，可能对应多个页表</p><p>段表中存放 ： 页表长度、 页表存放块号 （ 这个段对应页表的大小与在内存中存放的地址）</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220721154059737.png" alt="image-20220721154059737"></p><h6 id="地址转换-1"><a href="#地址转换-1" class="headerlink" title="地址转换"></a>地址转换</h6><blockquote><ol><li>根据逻辑地址得到段号、页号、页内偏移</li><li>判断段号是否越界</li><li>根据段号查询段表，找到对应的段表项（页表存放块）  – 第一次访存</li><li>检查页号是否越界</li><li>根据页表存放快、页号查询页表。找到对应的页表项  – 第二次访存</li><li>根据内存块号、 页内偏移得到物理地址</li><li>访问目标内存单元  – 第三次访存</li></ol><p>也可以引入快表</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220721154336798.png" alt="image-20220721154336798"></p><h5 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h5><blockquote><p>传统存储管理的特征</p><p>一次性：作业必须一次性装入内存才能开始运行</p><p>​导致多道程序并发性下降</p><p>驻留性：一旦作业被转入内存，就会一直驻留在内存中。</p><p>​浪费内存资源</p></blockquote><blockquote><p>高速缓冲器技术的思想: 将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速的存储器中。</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220722154035748.png" alt="image-20220722154035748"></p><p>虚拟内存有以下三个主要特征：</p><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li><li>对换性： 在作业运行时无需一直 常驻内存，而是允许在作业运行过程中，将作业换入换出</li><li>虚拟性:从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量。</li></ul><h5 id="虚拟内存的实现"><a href="#虚拟内存的实现" class="headerlink" title="虚拟内存的实现"></a>虚拟内存的实现</h5><blockquote><p>实现页面置换功能</p><p>​访问的信息不再内存中，操作系统负责将信息从外存调入内存</p><p>​将暂时用不到的信息调出外存</p></blockquote><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><h5 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h5><blockquote><p>实现 请求调页功能、页面置换功能</p></blockquote><h6 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h6><blockquote><ol><li>实现请求调页，需要知道页面是否已经调入内存，如果没有，需要知道页面在外存中的位置</li><li>覆盖外存中的旧数据。 - &gt; 记录各个页面是否被修改过的信息</li></ol></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220722155611826.png" alt="image-20220722155611826"></p><h6 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h6><blockquote><p>与当前执行的指令有关，输入内中断</p><p>一条指令在执行期间，可能产生多次缺页中断</p></blockquote><ul><li>当访问的页面不在内存时， 产生一个缺页中断</li><li>操作系统的缺页中断处理程序处理中断</li><li>此时缺页的进程阻塞，放入阻塞队列，调页完成后将其唤醒，放入就绪队列</li><li>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修 改页表中相应的页表项。 </li><li>如果内存中没有空闲块，则由<code>页面置换算法</code>选择一个页面淘汰，若该页面在内 存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</li></ul><h6 id="地址转换-2"><a href="#地址转换-2" class="headerlink" title="地址转换"></a>地址转换</h6><ul><li>请求调页 ： 在查到页表项时进行判断</li><li>页面置换： 需要调入页面时，但没有空闲内存块</li><li>修改请求页表中新增的表项</li></ul><h5 id="页面置换算法-1"><a href="#页面置换算法-1" class="headerlink" title="页面置换算法"></a>页面置换算法</h5><blockquote><p>决定该换出哪个页面</p></blockquote><ul><li><p><code>最佳置换算法opt</code> ： 每次选择淘汰的页面 将是<code>永不使用</code>，或者在最长时间内不被访问的页面</p><p><code>保证最低的缺页率， 理想化的算法， 在实际是无法实现的</code></p></li><li><p><code>先进先出转换（FIFO）</code> : 每次选择淘汰的页面是最早进入内存的页面</p><p><code>belady 异常  ：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</code></p><p><code>只有FIFO 算法 会产生belady 异常</code>，<code>算法性能查</code></p></li><li><p><code>LRU</code> <code>最近最久未使用</code> 每次淘汰的页面时最近最久未使用的页面</p><p><code>性能号，实现难度大，开销大</code></p></li><li><p><code>时钟置换算法CLOCK</code> </p><ul><li><blockquote><p><code>简单的时钟置换算法</code>：再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第- - ~轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描)</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-57-5.png"></p></blockquote></li><li><blockquote><p><code>改进型时钟算法：</code> 优先淘汰没有修改过的页面</p><p>算法规则:将所有可能被置换的页面排成–个循环队列 </p><p><code>第一轮</code>:从当前位置开始扫描到第一个(A &#x3D;0, M &#x3D; 0)的帧用于替换。表示该页面最近既未被访问，又未被修改，是最佳淘汰页<br><code>第二轮</code>:若第一轮扫描失败，则重新扫描，查找第一个(A &#x3D;1, M &#x3D; 0)的帧用于替换。本轮将所有扫描过的帧访问位设为0。表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。<br><code>第三轮</code>:若第二轮扫描失败，则重新扫描，查找第一个(A &#x3D;0, M &#x3D; 1)的帧用于替换。本轮扫描不修改任何标志位。表示该页面最近已被访问，但未被修改，该页有可能再被访问。<br><code>第四轮</code>:若第三轮扫描失败，则重新扫描，查找第一个A &#x3D;1, M &#x3D; 1)的帧用于替换。表示该页最近已被访问且被修改，该页可能再被访问。</p></blockquote><table><thead><tr><th></th><th>算法规则</th><th>优缺点</th></tr></thead><tbody><tr><td>OPT</td><td>优先淘汰最长时间内不会被访问的页面</td><td>缺页率最小，性能最好;但无法实现</td></tr><tr><td>FIFO</td><td>优先淘汰最先进入内存的页面</td><td>实现简单;但性能很差，可能出现Belady异常</td></tr><tr><td>LRU</td><td>优先淘汰最近最久没访问的页面</td><td>性能很好;但需要硬件支持，算法开销大</td></tr><tr><td>CLOCK (NRU)</td><td>循环扫描各页面 第一轮淘汰访问位&#x3D;0的，并将扫描过的页面访问位改为1。若第-轮没选中，则进行第二轮扫描。</td><td>实现简单，算法开销小;但未考虑页面是否被修改过。</td></tr><tr><td>改进型CLOCK (改进型NRU)</td><td>若用(访问位，修改位)的形式表述，则 第一轮:淘汰(0,0) 第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0) 第四轮:淘汰(0, 1)</td><td>算法开销较小，性能也不错</td></tr></tbody></table></li></ul></li></ul><h5 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h5><p><code>驻留集</code> ： 请求分页存储管理中给进程分配的物理块（内存）集合，驻留集大小一般小于进程的总大小</p><p><img src="http://picgo.wangeyi.ink/image-20220722164321322.png" alt="image-20220722164321322"></p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><blockquote><p>文件的属性</p><ul><li>文件名：同一目录下不允许有重名文件</li><li>标识符：系统内的各文件标识唯一</li><li>类型：指明文件的类型</li><li>位置：文件的存放的路径、在外存中存放的地址</li><li>大小：文件的大小</li><li>创建时间、上次修改时间</li><li>保护信息：对文件进行保护的访问控制信息</li></ul><p><code>“无结构文件”、“结构文件”</code>  ：文件内部的数据的组织形式</p><p>z</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220818144710478.png" alt="image-20220818144710478"></p><p><img src="http://picgo.wangeyi.ink/image-20220818145100392.png" alt="image-20220818145100392"></p><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><blockquote><ul><li><p>无结构文件</p><p>文件内部是一系列二进制流或着字符流组成，“流式文件”， txt文件</p></li><li><p>结构文件 “记录式文件”，由一组相似的记录组成，每条记录由若干数据项组成</p><ul><li>顺序结构</li><li>索引结构</li><li>索引顺序结构</li></ul></li></ul></blockquote><h5 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h5><p><code>文件中的记录一个接一个顺序排列</code>，在物理上可以是顺序存储或链式存储</p><ul><li><p>链式存储： 无法实现随机存储、每次只能从第一个记录开始依次往后查找</p></li><li><p>顺序存储：</p><p>​<code>可变长的记录</code>： 无法实现随机存储</p><p>​<code>定长记录</code>  ： 可实现随机存储、</p></li></ul><h5 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h5><p><img src="http://picgo.wangeyi.ink/image-20220818151353171.png" alt="image-20220818151353171"></p><h5 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h5><blockquote><p>索引文件的索引表可能会很大</p><p>“一组记录对应一个索引表项”</p></blockquote><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><p><img src="http://picgo.wangeyi.ink/image-20220818152334192.png" alt="image-20220818152334192"></p><ul><li>文件控制块</li></ul><blockquote><p>目录文件 ： 本身是一种有结构文件，由一条条记录组成，每一条记录对应存放在该目录下的文件</p><p>目录文件中的 <code>一条记录</code> 就是一个 文件控制块（FCB）</p></blockquote><p><code>FCB 实现文件名到文件之间的映射</code> ， 名字到物理存放地址之间的映射</p><ul><li>树形目录结构  ： 多级目录结构</li></ul><h4 id="文件分配方式"><a href="#文件分配方式" class="headerlink" title="文件分配方式"></a>文件分配方式</h4><blockquote><p>文件的逻辑地址空间也被分为一个一个的<code>文件块</code></p><p> — &gt;  文件的逻辑地址也可以表示为 逻辑块号  + 块内地址</p></blockquote><ul><li>连续分配： <code>每个文件在磁盘上占有一组连续的块</code> ,</li></ul><p>​文件的目录中记录存放的<code>起始块号</code>和<code>长度 （占用了几个块）</code></p><p>​<img src="http://picgo.wangeyi.ink/image-20220818155329356.png" alt="image-20220818155329356"></p><p>​ <code>顺序读写时的速度最快</code> 、 <code>不方便扩展</code> 、<code>存储利用率低，会产生难以利用的磁盘碎片</code> </p><ul><li><p>链接分配 ： <code>采取离散链接的方式</code></p><p><code>隐式链接</code>： <img src="http://picgo.wangeyi.ink/image-20220818155858826.png" alt="image-20220818155858826" style="zoom:67%;" /></p><p><code>只支持顺序访问、不支持随机访问，查找效率很低</code>、<code>方便拓展文件</code></p><p><code>显示链接</code> ： 链接文件各物理块的指针显示地存放在一张表中， (文件分配表)</p><img src="http://picgo.wangeyi.ink/image-20220818160238497.png" alt="image-20220818160238497" style="zoom:67%;" /><p><img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220818160545735.png" alt="image-20220818160545735"></p><p><code>链接分配总结</code></p><p><img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220818160650319.png" alt="image-20220818160650319"></p></li><li><p>索引分配： 允许文件离散地分配在各个磁盘块中 （<code>索引表，记录了文件各个逻辑块对应的物理块</code>）</p><blockquote><p>索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块</p></blockquote><p><img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220818160932364.png" alt="image-20220818160932364"></p><p><code>支持随机访问、文件拓展也容易实现</code></p><p><img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220818162130176.png" alt="image-20220818162130176"></p></li></ul><h4 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h4><p><img src="http://picgo.wangeyi.ink/image-20220822143817801.png" alt="image-20220822143817801"></p><ul><li><p><code>空闲表法</code> ： 适用于连续分配方式</p><p><img src="http://picgo.wangeyi.ink/image-20220822144235357.png" alt="image-20220822144235357"></p></li><li><p><code>空闲链表法</code>：离散分配和连续分配都适用</p><img src="http://picgo.wangeyi.ink/image-20220822144254035.png" alt="image-20220822144254035" style="zoom:50%;" /></li><li><p><code>位示图法</code>：离散分配和连续分配都适用</p><img src="http://picgo.wangeyi.ink/image-20220822144627197.png" alt="image-20220822144627197" style="zoom:50%;" /></li><li><p><code>成组链接法</code> ：</p></li></ul><blockquote><p>空闲表法、空闲链表法都不适用于大型文件系统，“空闲表和空闲链表可能会很大”</p></blockquote><p>  <img src="http://picgo.wangeyi.ink/image-20220822145114144.png" alt="image-20220822145114144"></p>  <img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220822145523458.png" alt="image-20220822145523458" style="zoom:50%;" /><h4 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h4><blockquote><p>系统调用实现</p></blockquote><ul><li><p>创建文件： <code>create系统调用</code>：</p><p>提供的参数:</p><ul><li>所需的外存空间大小</li><li>文件的存放路径</li><li>文件名</li></ul><p>操作系统处理create系统调用的两件事情：</p><ul><li>在外存中找到文件所需的空间</li><li>创建该文件对应的目录项</li></ul></li></ul><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p><img src="http://picgo.wangeyi.ink/image-20220822150159172.png" alt="image-20220822150159172"></p><p><img src="http://picgo.wangeyi.ink/image-20220822150253868.png" alt="image-20220822150253868"></p><h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><blockquote><p>口令保护、加密保护、访问控制</p></blockquote><p><img src="http://picgo.wangeyi.ink/image-20220822150616801.png" alt="image-20220822150616801"></p><p><img src="C:/Users/11769/AppData/Roaming/Typora/typora-user-images/image-20220822150752697.png" alt="image-20220822150752697"></p><p><img src="http://picgo.wangeyi.ink/image-20220822150947870.png" alt="image-20220822150947870"></p><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><h4 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h4><ul><li><p>磁盘、磁道和扇区</p><p><img src="http://picgo.wangeyi.ink/image-20220822151656208.png" alt="image-20220822151656208"></p></li><li><p>盘面、柱面</p><p><img src="http://picgo.wangeyi.ink/image-20220822151810139.png" alt="image-20220822151810139"></p></li></ul><blockquote><p>可用（柱面号、盘面号、扇区号）定义任意的“磁盘块”</p></blockquote><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><ul><li><p>磁盘读&#x2F;写操作的时间</p><p><code>寻道时间TS</code> ：  启动磁头臂的时间、移动磁头的时间</p><p><code>延迟时间TR</code>:  通过旋转磁盘，使磁头定位到目标扇区的时间</p><p><code>传输时间Tt</code> ： 读出&#x2F;写入数据所经历的时间</p></li></ul><blockquote><p>操作系统的磁盘调度算法会直接影响寻道时间</p></blockquote><ul><li><p>先来先服务算法（FCFS）</p><p>优点：<code>公平： 如果请求访问的磁道比较集中的话，算法性能还算过的去</code> </p><p>缺点：<code>如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</code></p></li><li><p>最短寻找时间优先（sstf）</p><p><code>优先处理的磁道时与当前磁头最近的磁道</code>，保证每次的寻道时间最短</p><p>优点： 性能较好、平均寻道时间短</p><p>缺点：<code>可能产生饥饿现象</code></p></li><li><p>扫描算法（SCAN）</p><p><img src="http://picgo.wangeyi.ink/image-20220822153305264.png" alt="image-20220822153305264"></p></li><li><p>LOOK算法</p><p><img src="http://picgo.wangeyi.ink/image-20220822153521836.png" alt="image-20220822153521836"></p></li><li><p>循环扫描算法（C-SCAN）</p><p><img src="http://picgo.wangeyi.ink/image-20220822153731724.png" alt="image-20220822153731724"></p></li><li><p>C-LOOK 算法</p><p><img src="http://picgo.wangeyi.ink/image-20220822153834768.png" alt="image-20220822153834768"></p></li></ul><h5 id="减少磁盘延迟时间的"><a href="#减少磁盘延迟时间的" class="headerlink" title="减少磁盘延迟时间的"></a>减少磁盘延迟时间的</h5><ul><li><p>交替编号 ： 让逻辑上相邻的扇区在物理上有一定的间隔</p><blockquote><p> 读入扇区后需要一小段时间处理，无法连续不断地读入相邻扇区，需要很长的”延迟时间“</p></blockquote></li></ul><blockquote><p>为什么柱面号要在盘面号之前？</p><p>读取地址连续的磁盘块时，采用（柱面号、盘面号、扇区号）可以减少磁头移动的时间</p></blockquote><ul><li><p>错位命名： 盘面的扇区编号是错开的</p><p><img src="http://picgo.wangeyi.ink/image-20220822155405903.png" alt="image-20220822155405903"></p></li></ul><h4 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h4><ul><li><code>磁盘初始化</code>： 进行低级格式化（物理格式化）： 将磁道划分位扇区</li><li><code>磁盘分区</code>： 每个分区由若干个柱面组成（C\D\F盘）</li><li><code>逻辑格式化</code>，创建文件系统、根目录、初始化存储空间管理所用的数据结构</li></ul><h5 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h5><p><img src="http://picgo.wangeyi.ink/image-20220822155928895.png" alt="image-20220822155928895"></p><p><img src="http://picgo.wangeyi.ink/image-20220822160038438.png" alt="image-20220822160038438"></p>]]></content>
    
    
    <summary type="html">os</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="os" scheme="http://blog.wangeyi.ink/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>同构式主手演示</title>
    <link href="http://blog.wangeyi.ink/2022/06/20/%E5%90%8C%E6%9E%84%E5%BC%8F%E4%B8%BB%E6%89%8B%E6%BC%94%E7%A4%BA/"/>
    <id>http://blog.wangeyi.ink/2022/06/20/%E5%90%8C%E6%9E%84%E5%BC%8F%E4%B8%BB%E6%89%8B%E6%BC%94%E7%A4%BA/</id>
    <published>2022-06-20T15:10:37.000Z</published>
    <updated>2022-06-20T15:41:59.307Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主从同构式数字孪生<div id="dplayer0" class="dplayer" style="margin-bottom: 20px;"></div><script>var dplayer0 = new DPlayer({"element":document.getElementById("dplayer0"),"autoplay":0,"theme":"#FADFA3","loop":1,"video":{"url":"http://picgo.wangeyi.ink/iRobot_ar%20-%20SampleScene%20-%20PC%2C%20Mac%20%26%20Linux%20Standalone%20-%20Unity%202020.3.14f1c1%20Personal_%20_DX11_%202022-05-25%2020-28-39.mp4"}});</script><!-- dplayer used1 --></li></ul>]]></content>
    
    
    <summary type="html">演示视频</summary>
    
    
    
    <category term="项目视频" scheme="http://blog.wangeyi.ink/categories/%E9%A1%B9%E7%9B%AE%E8%A7%86%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>一些</title>
    <link href="http://blog.wangeyi.ink/2022/06/20/%E4%B8%80%E4%BA%9B/"/>
    <id>http://blog.wangeyi.ink/2022/06/20/%E4%B8%80%E4%BA%9B/</id>
    <published>2022-06-20T13:02:28.000Z</published>
    <updated>2022-08-22T08:05:47.035Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><p>类型安全</p><ul><li>如果执行一个编写好的程序不可能表现出**未定义的行为,**我们称之为良好定义的程序。-&gt;</li><li>如果一个语言的类型系统可以<strong>保证</strong>每个程序都是良好定义的,我们说这个语言是类型安全的。</li></ul></li><li><p>C++ 是不是类型安全的：</p><ul><li><p>不是，两个不同类型的指针之间可以强制转化（同一段内存用不用的数据类型解释）</p></li><li><p>0 解释成 false（bool）， 数字0（int）</p></li><li><p>&#96;&#96;&#96;c++<br>int i &#x3D; 5;<br>void* pInt &#x3D; &amp;i;<br>double d &#x3D; (<em>(double</em>)pInt);<br>cout &lt;&lt; d &lt;&lt; endl;<br>&#x2F;&#x2F; vs2017输出 ：-9.25596e+61</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 浮点型的加法交换律</span><br><span class="line"></span><br><span class="line">  - 浮点型的表示：</span><br><span class="line">  - ![image-20220620220254210](http://picgo.wangeyi.ink/image-20220620220254210.png)</span><br><span class="line">  - </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">int printf ( const char * format, ... );</span><br><span class="line">//返回值： 正确返回输出的字符总数 不包含 ’\0‘</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>函数参数的入栈顺序，从右到左；</p><p>栈的存储是从高地址到低地址。</p></blockquote>]]></content>
    
    
    <summary type="html">——</summary>
    
    
    
    <category term="知识点" scheme="http://blog.wangeyi.ink/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>学学排序</title>
    <link href="http://blog.wangeyi.ink/2022/06/20/%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.wangeyi.ink/2022/06/20/%E6%8E%92%E5%BA%8F/</id>
    <published>2022-06-19T16:00:00.000Z</published>
    <updated>2022-06-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>稳定和非稳定：</p><p>稳  定 排 序：排序前后两个相同的数之间的相对位置不发生改变，则<strong>算法稳定</strong></p><p>​（插入排序、冒泡排序、归并排序）</p><p>非稳定排序：…………相对位置发生改变，则算法不稳定</p><p>​（希尔排序、直接选择排序、堆排序、快速排序）</p><p>ps： 判断一个排序是否稳定要看<strong>算法中每一次循环比较的步长，如果步长大于1，就是不稳定的，否则就是稳定的。</strong>非比较排序是稳定的。</p></blockquote><table><thead><tr><th>排序方法</th><th>平均时间复杂度</th><th>时间复杂度（最坏）</th><th>时间复杂度（最好）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>插入排序</td><td>o(n<em>2</em>)</td><td>o(n<em>2</em>)</td><td>o(n)</td><td>o(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>o(n<em>2</em>)</td><td>o(n)</td><td>o(1)</td><td>不稳定</td></tr><tr><td>选择排序</td><td>o(n<em>2</em>)</td><td>o(n<em>2</em>)</td><td>o(n<em>2</em>)</td><td>o(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>o(nlogn)</td><td>o(nlogn)</td><td>o(nlogn)</td><td>o(1)</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>o(n<em>2</em>)</td><td>o(n<em>2</em>)</td><td>o(n)</td><td>o(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>o(nlogn)</td><td>o(n<em>2</em>)</td><td>o(nlogn)</td><td>o(nlogn)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>o(nlogn)</td><td>o(nlogn)</td><td>o(nlogn)</td><td>o(n)</td><td>稳定</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>计数排序</td><td>o(n + k)</td><td>o(n + k)</td><td>o(n + k)</td><td>o(n + k)</td><td>稳定</td></tr><tr><td>桶排序</td><td>o(n + k)</td><td>o(n<em>2</em>)</td><td>o(n)</td><td>o(n + k)</td><td>稳定</td></tr><tr><td>基数排序</td><td>o(n*k)</td><td>o(n*k)</td><td>o(n*k)</td><td>o(n + k)</td><td>稳定</td></tr></tbody></table><hr><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul><li><p>基本思想：构建有序序列，每一趟排序将一个未排序的数据按照其关键字的大小插入到有序序列的合适的位置上，直到未排序数据全部插入为止。</p></li><li><p>时间复杂度：</p><ul><li>最坏情况 ：每趟排序都需遍历一遍有序序列（插入位置在开头）<ul><li>外层循环 <code>n - 1</code>次 ，内层循环 <code>(n-2)(n-1)/2</code> ： o(n2)</li></ul></li><li>最好情况：已经有序：插入位置为结尾<ul><li>o(n)</li></ul></li></ul></li><li><p>空间复杂度：o(1)</p></li><li><p>实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> * _data, <span class="type">int</span> _size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; _data[j + <span class="number">1</span>] &lt; _data[j]; --j) &#123;</span><br><span class="line">std::<span class="built_in">swap</span>(_data[j], _data[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i) &#123;</span><br><span class="line">std::cout &lt;&lt; _data[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="type">int</span> data[<span class="number">11</span>] = &#123; <span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">10</span>      <span class="number">9</span>       <span class="number">8</span>       <span class="number">7</span>       <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">9</span>       <span class="number">10</span>      <span class="number">8</span>       <span class="number">7</span>       <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">7</span>       <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul><li><p>基本思想：是对直接插入排序的优化，也称为缩小增量排序，其原理是将待排序的序列按下标的一定增量分组，对每组进行直接插入排序。直到增量为1，进行最后一次直接插入排序。</p></li><li><p>时间复杂度:</p><ul><li>最坏情况： <code>O(nlog2n)</code></li><li>最好情况： 有序序列，需要进行<code>n - 1</code> 次排序： <code>O(n)</code></li></ul></li><li><p>空间复杂度：<code>o(1)</code></p></li><li><p>实现：</p></li></ul>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> * _data, <span class="type">int</span> _size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = _size / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>) &#123;  <span class="comment">// 增量分组</span></span><br><span class="line"><span class="comment">// 按照增量进行直接插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; _size; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; _data[j] &gt; _data[j + d]; j -= d)&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(_data[j], _data[j + d]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;增量： &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i) &#123;</span><br><span class="line">std::cout &lt;&lt; _data[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="type">int</span> data[<span class="number">11</span>] = &#123; <span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">增量： <span class="number">5</span></span><br><span class="line"><span class="number">0</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">5</span>       <span class="number">9</span>       <span class="number">8</span>       <span class="number">7</span>       <span class="number">6</span>       <span class="number">10</span></span><br><span class="line">增量： <span class="number">2</span></span><br><span class="line"><span class="number">0</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">5</span>       <span class="number">7</span>       <span class="number">6</span>       <span class="number">9</span>       <span class="number">8</span>       <span class="number">10</span></span><br><span class="line">增量： <span class="number">1</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br></pre></td></tr></table></figure><hr><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul><li><p>基本思想：每一趟在未排序序列中找到最小元素，和未排序序列的首个元素交换，在剩余序列中重复操作直到所有元素排序完成。</p></li><li><p>时间复杂度：<code>o(n2)</code></p></li><li><p>实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> * _data, <span class="type">int</span> _size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i) &#123;</span><br><span class="line"><span class="type">int</span> minindex = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; _size; ++j) &#123;</span><br><span class="line">minindex = _data[j] &gt; _data[minindex] ? minindex : j;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">swap</span>(_data[i], _data[minindex]);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i) &#123;</span><br><span class="line">std::cout &lt;&lt; _data[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试：</span></span><br><span class="line"><span class="type">int</span> data[<span class="number">11</span>] = &#123; <span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">0</span>       <span class="number">9</span>       <span class="number">8</span>       <span class="number">7</span>       <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">8</span>       <span class="number">7</span>       <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">7</span>       <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul><li><p>基本思想：将待排序序列看成一个树状数组，构建二叉树堆，通过堆这种数据结构对序列中的每个元素进行插入，实现排序工作。</p></li><li><p>时间复杂度：<code>O(nlogn)</code>，空间复杂度<code>o(1)</code></p></li><li><p>实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建队，维护d</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myheap_base::buildheap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> size = data.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">heapify</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 维护堆的性质</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myheap_base::heapify</span><span class="params">(<span class="type">size_t</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;data.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">int</span> lastgest = i; <span class="comment">// 维护value最大的下标</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">left</span>(i) &lt; <span class="keyword">this</span>-&gt;datasize &amp;&amp; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(<span class="built_in">left</span>(i)) &gt; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(i)) <span class="comment">// 左子树</span></span><br><span class="line">lastgest = <span class="built_in">left</span>(i);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">right</span>(i) &lt; <span class="keyword">this</span>-&gt;datasize &amp;&amp; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(<span class="built_in">right</span>(i)) &gt; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(lastgest)) <span class="comment">// 右子树</span></span><br><span class="line">lastgest = <span class="built_in">right</span>(i);</span><br><span class="line"><span class="keyword">if</span> (lastgest != i) &#123; <span class="comment">//如果最下标不是根结点，交换，同时维护换下去的结点的性质</span></span><br><span class="line">std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;data[i], <span class="keyword">this</span>-&gt;data[lastgest]);</span><br><span class="line">i = lastgest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myheap_base::heapsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">buildheap</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = datasize - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;data[i], <span class="keyword">this</span>-&gt;data[<span class="number">0</span>]); <span class="comment">// 将大根堆顶（最大值）交换到序列末尾</span></span><br><span class="line"><span class="keyword">this</span>-&gt;datasize -= <span class="number">1</span>;<span class="comment">// 待排序序列长度相应减少</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">heapify</span>(<span class="number">0</span>);<span class="comment">// 维护堆顶元素的性质（保证时待排序序列中的最大值）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li><p>基本思想：比较相邻的元素，将值较小&#x2F;大的元素交换到前面，对序列中的每一组相邻元素都进行相同的比较交换。</p></li><li><p>时间复杂度：<code>o(n2)</code></p></li><li><p>实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> * _data, <span class="type">int</span> _size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = _size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (_data[j] &lt; _data[j - <span class="number">1</span>])</span><br><span class="line">std::<span class="built_in">swap</span>(_data[j - <span class="number">1</span>], _data[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i) &#123;</span><br><span class="line">std::cout &lt;&lt; _data[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试：</span></span><br><span class="line"><span class="type">int</span> data[<span class="number">11</span>] = &#123; <span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">9</span>       <span class="number">8</span>       <span class="number">7</span>       <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span>       <span class="number">10</span></span><br><span class="line"><span class="number">8</span>       <span class="number">7</span>       <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">7</span>       <span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">6</span>       <span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">5</span>       <span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">4</span>       <span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">3</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>       <span class="number">0</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">1</span>       <span class="number">0</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li><p>基本思想：随机选择基准元素，通过一趟排序将数据分成独立的两个部分，一部分小于基准元素，一部分大于等于基准元素，再按照相同的方法递归处理两部分数据。</p></li><li><p>时间复杂度：o(nlogn),空间复杂度 O(logn)。</p></li><li><p>实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Esort::QuickSort</span><span class="params">(std::vector&lt;T&gt; &amp; data)</span> </span>&#123;</span><br><span class="line"><span class="built_in">QuickSort</span>(data, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Esort::QuickSort</span><span class="params">(std::vector&lt;T&gt; &amp; data,<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> indestandvalue = <span class="built_in">adjustarray</span>(data, l, r);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort</span>(data, l, indestandvalue - <span class="number">1</span>); <span class="comment">// 递归处理两个子数组</span></span><br><span class="line"><span class="built_in">QuickSort</span>(data, indestandvalue + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">Esort::adjustarray</span><span class="params">(std::vector&lt;T&gt; &amp; data, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ptr = left, qtr = right;</span><br><span class="line"><span class="type">int</span> standvalue = data[left];  <span class="comment">// 选定标准， 按照标准分为两部分</span></span><br><span class="line"><span class="keyword">while</span> (ptr &lt; qtr) &#123;</span><br><span class="line"><span class="keyword">while</span> (ptr &lt; qtr &amp;&amp; data[qtr] &gt;= standvalue)qtr--; <span class="comment">//从右往左找到比标准值小的下标</span></span><br><span class="line"><span class="keyword">if</span> (ptr &lt; qtr) &#123;</span><br><span class="line">data[ptr++] = data[qtr];  <span class="comment">//换到标准值前面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ptr &lt; qtr &amp;&amp; data[ptr] &lt; standvalue)ptr++;</span><br><span class="line"><span class="keyword">if</span> (ptr &lt; qtr) &#123;</span><br><span class="line">data[qtr--] = data[ptr];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">data[ptr] = standvalue;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">std::ostream &amp;  Esort::<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, std::vector&lt;T&gt; data) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> T &amp; d : data) &#123;</span><br><span class="line">os &lt;&lt; d &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::ends;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul><li><p>基本思想：采用分治法，将待排序序列分为两个更小规模的部分，分别对两部分进行递归排序，最后合并两个有序的部分。</p></li><li><p>描述：</p><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul></li><li><p>排序算法稳定，时间复杂度都为 O(nlogn)，空间复杂度为 O(n)。</p></li><li><p>实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归处理两个部分[left,mid)、[mid,right)</span></span><br><span class="line"><span class="built_in">MergeSort</span>(nums, left, mid);</span><br><span class="line"><span class="built_in">MergeSort</span>(nums, mid, right);</span><br><span class="line"><span class="comment">// 合并两部分</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(right - left)</span></span>; <span class="comment">//临时数组存在合并好的序列</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> index1 = left, index2 = mid;</span><br><span class="line"><span class="keyword">while</span> (index1 &lt; mid &amp;&amp; index2 &lt; right) &#123;</span><br><span class="line">temp[index++] = nums[index1] &lt; nums[index2] ? nums[index1++] : nums[index2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (index1 &lt; mid) &#123;</span><br><span class="line">temp[index++] = nums[index1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (index2 &lt; right) &#123;</span><br><span class="line">temp[index++] = nums[index2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; ++i) &#123;</span><br><span class="line">nums[left + i] = temp[i];</span><br><span class="line">std::cout &lt;&lt; nums[left + i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temoooo = &#123; <span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">MergeSort</span>(temoooo, <span class="number">0</span>, temoooo.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序"></a>线性时间排序</h3><blockquote><p> 非比较排序</p></blockquote><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul><li><p>基本思想：对于每个输入的元素<em>x</em>，确定小于等于<em>x</em>的元素的个数index， 于是可以把x之间放在排完序的数字中的正确位置上。</p><ul><li>假设待排序的序列都是<strong>整数</strong>， 且都位于区间<code>[0,k]</code>之间。</li><li>若 <code>k</code> (待排序列的最大值) 过大，会引起较大的空间复杂度。– 一般是用来排序 0 到 100 之间的数字的最好的算法。</li></ul></li><li><p>描述：</p><ul><li>找出待排序序列的最大值，开辟临时空间存 <code>“小于等于*x*的元素的个数”</code> <code>c[0……k]</code></li><li>统计数组中每个值为 <code>i</code> 的元素出现的次数，将其存放在 <code>c[i]</code></li><li>累加每个元素的计数值，（统计小于等于<code>i</code>的元素的个数）</li><li>填充数组，将<code>i</code>放在相应位置，同时计数值减1</li></ul></li><li><p>实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> veclength = *std::<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">veccount</span><span class="params">(veclength + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;digit : nums) &#123;</span><br><span class="line">veccount[digit]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= veclength; ++i) &#123;</span><br><span class="line">veccount[i] += veccount[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">temp[--veccount[nums[i]]] = nums[i];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; it : temp) &#123;</span><br><span class="line">std::cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">nums[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; temoooo = &#123; <span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">CountSort</span>(temoooo);</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul><li><p>基本思想：假设数组均匀独立第分布在一个范围内，将这个范围分为几个子范围（桶），然后将数据按照某种映射关系存入桶中。</p><ul><li>对每个桶的元素进行<em>比较排序</em></li><li>依次枚举输出每个桶中的元素，即是一个有序序列。</li></ul></li><li><p>描述：</p><ul><li>设置一个定量的数组当作空桶子。</li><li>寻访序列，并且把项目一个一个放到对应的桶子去。</li><li>对每个不是空的桶子进行排序。</li><li>从不是空的桶子里把项目再放回原来的序列中</li></ul></li><li><p>实现</p><p>这里直接贴这个博客的代码：<a href="https://zhuanlan.zhihu.com/p/125737294">【算法】排序算法之桶排序 - 知乎 (zhihu.com)</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUCKET_NUM = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ListNode</span><span class="params">(<span class="type">int</span> i=<span class="number">0</span>)</span>:mData(i),mNext(NULL)&#123;</span>&#125;</span><br><span class="line">ListNode* mNext;</span><br><span class="line"><span class="type">int</span> mData;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">ListNode dummyNode;</span><br><span class="line">ListNode *newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">ListNode *pre,*curr;</span><br><span class="line">dummyNode.mNext = head;</span><br><span class="line">pre = &amp;dummyNode;</span><br><span class="line">curr = head;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span>!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;</span><br><span class="line">pre = curr;</span><br><span class="line">curr = curr-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;mNext = curr;</span><br><span class="line">pre-&gt;mNext = newNode;</span><br><span class="line"><span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode *head1,ListNode *head2)</span></span>&#123;</span><br><span class="line">ListNode dummyNode;</span><br><span class="line">ListNode *dummy = &amp;dummyNode;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span>!=head1 &amp;&amp; <span class="literal">NULL</span>!=head2)&#123;</span><br><span class="line"><span class="keyword">if</span>(head1-&gt;mData &lt;= head2-&gt;mData)&#123;</span><br><span class="line">dummy-&gt;mNext = head1;</span><br><span class="line">head1 = head1-&gt;mNext;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dummy-&gt;mNext = head2;</span><br><span class="line">head2 = head2-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">dummy = dummy-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>!=head1) dummy-&gt;mNext = head1;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>!=head2) dummy-&gt;mNext = head2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line"><span class="function">vector&lt;ListNode*&gt; <span class="title">buckets</span><span class="params">(BUCKET_NUM,(ListNode*)(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="type">int</span> index = arr[i]/BUCKET_NUM;</span><br><span class="line">ListNode *head = buckets.<span class="built_in">at</span>(index);</span><br><span class="line">buckets.<span class="built_in">at</span>(index) = <span class="built_in">insert</span>(head,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">ListNode *head = buckets.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;BUCKET_NUM;++i)&#123;</span><br><span class="line">head = <span class="built_in">Merge</span>(head,buckets.<span class="built_in">at</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">arr[i] = head-&gt;mData;</span><br><span class="line">head = head-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li>基本思想: 将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。<ul><li><strong>MSD</strong>：先从高位开始进行排序，在每个关键字上，可采用计数排序</li><li><strong>LSD</strong>：先从低位开始进行排序，在每个关键字上，可采用桶排序</li></ul></li><li></li></ul>]]></content>
    
    
    <summary type="html">排序算法</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="排序" scheme="http://blog.wangeyi.ink/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://blog.wangeyi.ink/2022/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.wangeyi.ink/2022/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2022-06-19T09:01:22.000Z</published>
    <updated>2022-07-07T09:29:19.617Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><h5 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h5><ul><li>栈 -后进先出（<strong>LIFO</strong>）<ul><li>栈下溢：对空栈进行弹出操作</li><li>栈上溢：栈顶超出集容量<ul><li><a href="#%E5%8D%95%E8%B0%83%E6%A0%88">单调栈</a></li></ul></li></ul></li><li>队列-先进先出（<strong>FIFO</strong>）<ul><li><a href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">单调队列</a></li></ul></li></ul><p><code>std::stack</code>、<code>std:: queue</code>  <!--详见STL.md--> </p><p><em><strong>例：</strong></em> 225. 用队列实现栈、 232. 用栈实现队列</p><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><ul><li>单向、双向、循环、非循环</li><li>哨兵：简化边界条件的处理： <ul><li>设置哨兵 <code>L</code>对于链表中指向<code>nullptr</code>的指针，都以指向 <code>L</code>取代，<code>L</code>的next 指向头节点</li></ul></li></ul><p><code>std::List</code><!--详见STL.md--> </p><p><em><strong>例：</strong></em>设计链表</p><p>例： 相交链表： 双指针</p><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><ul><li>（Hash table 哈希表）：根据关键码值(Key value)而直接进行访问的数据结构</li></ul><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p><strong>直接寻址法</strong>：<em>取关键字或关键字的某个线性函数值为散列地址。</em></p><p>数字分析法：<em>通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</em></p><p><strong>平方取中法</strong>：<em>当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</em></p><p><strong>取随机数法</strong>：<em>使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</em></p><p><strong>除留取余法</strong>：<em>取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。</em></p><h5 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h5><h6 id="链接法"><a href="#链接法" class="headerlink" title="链接法"></a>链接法</h6><p><strong>基本思想:</strong> </p><ul><li>将所有哈希地址为<code>i</code>的元素构成一个称为同义词链的链表，并将链表的头指针存在哈希表的第<code>i</code>个单元中，同义词链表可以是单链表，也可以是双链表</li><li>查找、插入和删除主要在同义词链中进行。适用于经常进行插入和删除的情况。</li></ul><p><img src="/223_a.gif"></p><p><strong>代码实现：<a href="#%E9%93%BE%E6%8E%A5%E6%B3%95">这里</a></strong></p><p><code>std::unordered_map</code>、<code>std::unordered_set</code> <!--详见STL--></p><p><em><strong>例</strong></em>： <a href="https://leetcode-cn.com/problems/design-hashset/">设计哈希集合</a>、<a href="https://leetcode-cn.com/problems/design-hashmap">设计哈希映射</a></p><h4 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h5><p>递归，<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3">迭代</a>, <a href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</a></p><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><ul><li>一颗二叉树只有度为0的结点和度为2的结点，且度为0 的结点都在同一层上</li></ul><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><ul><li>在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h 层，则该层包含 1~ 2^h -1个节点。</li><li>用数组存完全二叉树时，不会浪费空间</li></ul><h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>二叉搜索树是一种节点值之间具有一定数量级次序的二叉树，对于任意树节点：</p><ul><li>若其左子树存在，则其左子树中的每个节点值都不大于该节点值</li><li>若其右子树存在，则其右子树中的每个节点值都不小于该节点值</li></ul><h6 id="动态集合的操作"><a href="#动态集合的操作" class="headerlink" title="动态集合的操作"></a>动态集合的操作</h6><p><em>查询、插入和删除、构建</em></p><h6 id="查询-代码"><a href="#查询-代码" class="headerlink" title="查询-代码"></a>查询-<a href="#binaryseachtree">代码</a></h6><p>关键字K：从根结点开始，比较K和结点的值，k小于x：在左子树中查找，k大于x：在右子树中查找</p><ul><li>二叉搜索树的查询复杂度为 <code>O(logn)~o(n)</code><em>完全二叉树和每层只有一个结点两种情况</em></li></ul><h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><p>比较元素值大小，迭代查找左右子树，直到找到子节点为空，插入相应位置</p><h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><ul><li>删除的叶子结点、节点度为零： 可以直接删除</li><li>删除的节点度为一：需要将删除节点的左子树或者右子树上移到删除节点的位置，以保证二叉搜索树的结构性</li><li>删除的节点都为二：将删除节点的左子树中的最大值节点（删除节点的后继节点）移动到删除节点的位置，同<ul><li>则将删除节点的左⼦树头结点（左孩⼦）放到删除节点的右⼦树<br>的最左⾯节点的左孩⼦上，返回删除节点右孩⼦为新的根节点。</li></ul></li></ul><h6 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h6><p><em><strong>例：</strong></em><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p><h5 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h5><ul><li>⼜被称为AVL（<code>Adelson-Velsky and Landis</code>）树，且具有以下性质：它是⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树.</li></ul><h5 id="二叉搜索树的前驱和后继"><a href="#二叉搜索树的前驱和后继" class="headerlink" title="二叉搜索树的前驱和后继"></a>二叉搜索树的前驱和后继</h5><h6 id="前驱：x结点的前驱，-val值小于-x-gt-val-的所有结点中最大的一个"><a href="#前驱：x结点的前驱，-val值小于-x-gt-val-的所有结点中最大的一个" class="headerlink" title="前驱：x结点的前驱， val值小于 x-&gt;val 的所有结点中最大的一个"></a>前驱：x结点的前驱， <code>val</code>值小于 <code>x-&gt;val</code> 的所有结点中最大的一个</h6><ul><li>x结点有左子树：x结点的前驱是左子树的<code>val</code>值最大的元素 : <code>x-&gt;pre = TREE_MAXMUM(x-&gt;left)</code></li><li>x结点没有左子树<ul><li>x结点是其父结点的<em><strong>右子树</strong></em>，则x结点的前驱是其父结点</li><li>x节点是其父结点的<em><strong>左子树</strong></em>，则</li></ul></li></ul><h6 id="后继：x结点的后继，-val值大于-x-gt-val-的所有结点中最小的一个"><a href="#后继：x结点的后继，-val值大于-x-gt-val-的所有结点中最小的一个" class="headerlink" title="后继：x结点的后继， val值大于 x-&gt;val 的所有结点中最小的一个"></a>后继：x结点的后继， <code>val</code>值大于 <code>x-&gt;val</code> 的所有结点中最小的一个</h6><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h4 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h4><h5 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h5><blockquote><p>对于图G &#x3D;  (V , E)  V: 节点，E：边</p></blockquote><ul><li>邻接链表：以所有节点 <code>u ∈ V</code>为头节点的链表组成数组 <code>adj</code>，每个链表包含所有与 <code>u</code>节点相邻的节点，即： <code>adj[u]</code> <ul><li>无向图：对于边<code>（u，v）</code>， <code>adj[u]</code>中包含节点 v， <code>adj[v]</code>中包含节点 u。<em><strong>（所有邻接链表的长度为 2 E）</strong></em></li><li>有向图：对于边<code>（u，v）</code>， <code>adj[u]</code>中包含节点 v 。<em><strong>（所有邻接链表的长度为  E）</strong></em></li><li>边的权值 存在节点中</li></ul></li><li>邻接矩阵：<code>|V| *|V|</code>的矩阵表示，<ul><li>无向图： 对称矩阵</li><li>有向图：……</li><li>边（u，v）的权值 记录在矩阵 <code>第u行v列</code>的位置上</li></ul></li></ul><p></p><h5 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h5><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p><ul><li>堆中某个结点的值总是不大于或不小于其父结点的值；<ul><li>最大堆：父结点的值最大 ：（算法导论用于堆排序）</li><li>最小堆：父结点的值最小：（构造优先队列）</li></ul></li><li>堆总是一棵完全二叉树。</li></ul><h5 id="维护堆的性质"><a href="#维护堆的性质" class="headerlink" title="维护堆的性质"></a>维护堆的性质</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 维护堆的性质</span></span><br><span class="line"><span class="comment">// 从data[i] (根结点)， data[left(i)]、data[right(i)] 中找出最大值，记录最大值的下标lagerst</span></span><br><span class="line"><span class="comment">// 如果当前已经满足 堆的性质（i==lagerst）返回， 否则交换i 和 lagerst ， 并维护 lagerst 结点的堆的性质</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeap::heapify</span><span class="params">(<span class="type">size_t</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;data.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">int</span> lastgest = i;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">left</span>(i) &lt; <span class="keyword">this</span>-&gt;datasize &amp;&amp; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(<span class="built_in">left</span>(i)) &gt; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(i))</span><br><span class="line">lastgest = <span class="built_in">left</span>(i);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">right</span>(i) &lt; <span class="keyword">this</span>-&gt;datasize &amp;&amp; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(<span class="built_in">right</span>(i)) &gt; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(lastgest))</span><br><span class="line">lastgest = <span class="built_in">right</span>(i);</span><br><span class="line"><span class="keyword">if</span> (lastgest != i) &#123;</span><br><span class="line">std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;data[i], <span class="keyword">this</span>-&gt;data[lastgest]);</span><br><span class="line">i = lastgest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//建堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeap::buildheap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = data.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">heapify</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeap::heapsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">buildheap</span>(); <span class="comment">//建立最大堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = datasize - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;data[i], <span class="keyword">this</span>-&gt;data[<span class="number">0</span>]); <span class="comment">// 交换堆顶元素和末尾元素</span></span><br><span class="line"><span class="keyword">this</span>-&gt;datasize -= <span class="number">1</span>; <span class="comment">// 末尾元素已经是排好序了</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">heapify</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Esort::QuickSort</span><span class="params">(std::vector&lt;T&gt; &amp; data,<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> indestandvalue = <span class="built_in">adjustarray</span>(data, l, r);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort</span>(data, l, indestandvalue - <span class="number">1</span>); <span class="comment">// 递归处理两个子数组</span></span><br><span class="line"><span class="built_in">QuickSort</span>(data, indestandvalue + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">Esort::adjustarray</span><span class="params">(std::vector&lt;T&gt; &amp; data, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ptr = left, qtr = right;</span><br><span class="line"><span class="type">int</span> standvalue = data[left];  <span class="comment">// 选定标准， 按照标准分为两部分</span></span><br><span class="line"><span class="keyword">while</span> (ptr &lt; qtr) &#123;</span><br><span class="line"><span class="keyword">while</span> (ptr &lt; qtr &amp;&amp; data[qtr] &gt;= standvalue)qtr--; <span class="comment">//从右往左找到比标准值小的下标</span></span><br><span class="line"><span class="keyword">if</span> (ptr &lt; qtr) &#123;</span><br><span class="line">data[ptr++] = data[qtr];  <span class="comment">//换到标准值前面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ptr &lt; qtr &amp;&amp; data[ptr] &lt; standvalue)ptr++;</span><br><span class="line"><span class="keyword">if</span> (ptr &lt; qtr) &#123;</span><br><span class="line">data[qtr--] = data[ptr];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">data[ptr] = standvalue;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li>基数排序(Radix Sort)属于分配式排序，又称”桶子法”(Bucket Sort或Bin Sort)，将要排序的元素分配到某些”桶”中，以达到排序的作用。基数排序属于稳定的排序，其时间复杂度为nlog(r)m (其中r为的采取的基数,m为堆数)，基数排序的效率有时候高于其它比较性排序。</li><li><strong>最低位优先LSD（Least sgnificant digital）法</strong>  : 键值最右边开始</li><li><strong>最高位优先MSD（Most sgnificant digital）法</strong></li></ul><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp; num)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;原数组：\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; it : num) &#123;</span><br><span class="line">cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> size = num.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> digit = <span class="built_in">GetMaxBits</span>(num);</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(size)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 0 ~9 的桶</span></span><br><span class="line"><span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= digit; ++i) &#123; <span class="comment">// 1 到最高位 进行排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;</span><br><span class="line">count[j] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// 清除计数器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; ++j) &#123;</span><br><span class="line">count[(num[j] / radix) % <span class="number">10</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">count[j] += count[j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = size - <span class="number">1</span>; j &gt;= <span class="number">0</span> ; --j) &#123;</span><br><span class="line">temp[count[(num[j] / radix) % <span class="number">10</span>] - <span class="number">1</span>] = num[j];</span><br><span class="line">count[(num[j] / radix) % <span class="number">10</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">radix *= <span class="number">10</span>;</span><br><span class="line">num = std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><blockquote><p>程序调用自身，函数作为自身的子例程调用</p><p>需要根据递推关系调用函数本身，直到其抵达基本情况</p></blockquote><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>把一个大型复杂的原问题转化为规模更小的子问题，直到子问题无需进一步递归就能得到解</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>基本案例（bottom case）：规模最小的子问题，能够不适用递归得到解</li><li>递推关系（recurrence relation）： 将其他问题拆分到基本案例</li></ul><h4 id="递归算法的三要素"><a href="#递归算法的三要素" class="headerlink" title="递归算法的三要素"></a>递归算法的三要素</h4><ul><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归逻辑</li></ul><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>​纯暴力搜索方式：<em>递归和回溯是相辅相成的，解决问题： 组合问题、切割问题（字符串切割方式）、子集问题、排列问题、棋盘问题（N皇后）</em></p><blockquote><p>决策树的遍历过程</p></blockquote><ul><li><strong>路径</strong>：记录我们做出了的选择(走过的决策树上的路径，我们一般都是在最后的叶子节点上去收集结果)；【比如我们选的123,124】;</li><li><strong>选择列表</strong>：当前情况下我们可以做出的选择；【比如在第三步我们可以选3.4.5】</li><li><strong>结束条件</strong>：也就是到达了决策树的底层叶子节点，选择列表为空了，无法再做出别的选择了。【比如我们的树选完了123达到题目中的要求3个元素了，就不能够再做选择了】</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ans; <span class="comment">//结果集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(^)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="comment">/*终止条件*/</span>) &#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(结果);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(选择列表)&#123;</span><br><span class="line">处理结点;   \递归前做出选择,递归结束后<span class="function">c</span></span><br><span class="line"><span class="function">        <span class="title">backtracking</span><span class="params">(^)</span></span>;</span><br><span class="line">        回溯，撤销处理结点;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><em><strong>查找空间：</strong></em>具有指定左、右索引的连续序列（有序）。</p><p><em><strong>算法流程：</strong></em>维护查找空间的左、右、中索引，将序列中间值应用于<em><strong>查找条件</strong></em>，清除 <em>查找目标</em> 不存在的一半序列，直到成功为止。 <!--即：每次比较后将查找空间一分为二。--></p><p><em><strong>组成：</strong></em> 1. <em>预处理</em> —查找空间有序化。</p><p>​ 2.<em>二分查找</em>—使用循环或者递归在每次比较之和将查找空间一分为二</p><p>​ 3.<em>后处理</em>—在剩余的查找空间中确定可行的候选者</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a><em>模板</em></h4><h5 id="模板-1："><a href="#模板-1：" class="headerlink" title="模板 1："></a><em><strong>模板 1：</strong></em></h5><blockquote><p>&lt;–查找空间为闭合区间, 包含i &#x3D;&#x3D; j 的空间–&gt;</p><p>​&lt;–无需后处理，每步中均检查是否找到目标–&gt;</p><p>​&lt;– 循环结束（j &#x3D; i - 1），目标值存在于开区间(var[j], var[i])之间–&gt;</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target) &#123; </span><br><span class="line">        <span class="keyword">return</span> mid; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; </span><br><span class="line">        left = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        right = mid - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// End Condition: left &gt; right</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>例 1：搜索旋转排序数组</strong></em> </p><!--解一logn--><ul><li>数组<code>vector&lt;T&gt; var</code>分为左右两个递增区间<code>[left,k],[k+1,right]</code>。<ul><li>中间值为目标值，结束查找。</li><li>中间值位于左区间 —*<code>var[left] &lt;= var[mid]</code>*<ul><li>目标值存在于区间<code>[left,mid]</code>，查找空间变为<code>[left,mid]</code>。—<code>var[left] &lt;= target &lt;= var[mid]</code>* </li><li>目标值存在于区间<code>[mid + 1,right]</code> ，查找空间变为<code>[mid + 1,right]</code>。—*<code> target &gt; var[mid]</code>*</li></ul></li><li>中间值位于右区间 —*<code>var[left] &gt; var[mid]</code>*<ul><li>目标值存在于区间<code>[mid,right]</code>，查找空间变为<code>[mid,right]</code>。—<code>var[mid] &lt;= target &lt;= var[right]</code>* </li><li>目标值存在于区间<code>[left,mid - 1]</code> ，查找空间变为<code>[left,mid - 1]</code>。—*<code> target &lt; var[mid]</code>*</li></ul></li></ul></li><li>循环结束，目标值不存在</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;=nums[right])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    right = mid - <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!--解二：找断点，判断目标位于哪个区间，再进行二分查找--><h5 id="模板-2："><a href="#模板-2：" class="headerlink" title="模板 2："></a><em><strong>模板 2：</strong></em></h5><blockquote><p>&lt;–查找空间为开区间，不包含right–&gt;</p><p>​ &lt;–保证每一步中查找空间至少存在两个元素–&gt;</p><p>​  &lt;–循环结束，i&#x3D;j，需要判断是否为目标值–&gt;&lt;–注意溢出–&gt;</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)&#123; <span class="keyword">return</span> mid; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; right = mid; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post-processing:</span></span><br><span class="line">  <span class="comment">// End Condition: left == right</span></span><br><span class="line">  <span class="keyword">if</span>(left != nums.<span class="built_in">size</span>() &amp;&amp; nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>例：寻找峰值 or 第一个错误的版本：</strong></em> 开区间二分：查找结束的<code>left = right</code>所在的位置就是第一个使查找条件<strong>转变</strong>的目标。</p><p><em><strong>例：寻找旋转排序数组中的最小值</strong></em></p><ul><li>查找空间：目标值存在于右半递增区间中<ul><li>二分空间：  中值位于左区间:<code>left = mid + 1</code> , 中值位于右区间：<code>right = mid</code>。</li><li>查找空间为递增区间，返回递增区间的第一个值</li><li>倒数第二次循环： <code>[left, left + 1]</code> 两个值是递增区间 or 递减。<code>mid = （i + j） / 2 = i</code>, </li><li>查找结束，<code>left = mid + 1 = right</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt; nums[right])</span><br><span class="line">                <span class="keyword">return</span> nums[left];</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="模板三："><a href="#模板三：" class="headerlink" title="模板三："></a><em><strong>模板三：</strong></em></h5><blockquote><p> &lt;–查找空间为[left.right]–&gt;</p><p>&lt;–每一步循环查找中至少包含三个元素–&gt;</p><p>&lt;–查找结束，区间为[left,right],需要判断是否存在目标值–&gt;</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a><em>例题</em></h4><p><em><strong>例：寻找排序数组中目标值第一个和最后一个位置：</strong></em>判断查找结束时左右指针的值</p><p><em><strong>例：</strong></em><a href="https://leetcode-cn.com/problems/find-k-closest-elements/"><em><strong>找到 K 个最接近的元素</strong></em></a>  <em>有序数组中找到最靠近 目标<code>x</code>的 <code>k</code> 个数</em></p><!--二分查找+双指针--><ul><li>目标值 <code>x</code> 小于等于有序数组的首元素： <code>x &lt;= nums[0]</code><ul><li>解为有序数组的前 <code>k</code> 个元素</li></ul></li><li>目标值 <code>x</code> 大于等于有序数组的最后一个元素： <code>x &gt;= nums[nums.size() - 1]</code><ul><li>解为有序数组的后 <code>k</code> 个元素</li></ul></li><li>其他：<ul><li>找出大于目标值最小的索引位置 <code>index</code>，解存在于 <code>[index- k-1, index + k -1]</code>之间 <em><u>二分查找<code>o(logn)</code></u></em></li><li>双指针缩小解的范围至k, 解 <code>[low = index-k-1, high = index + k-1]</code>， <em><u>判断区间范围的合法性</u></em><ul><li><code>low</code> 的元素比 <code>high</code> 靠近x, 缩小 <code>high</code></li><li><code>high &gt; size </code> or   <code>high</code> 的元素比 <code>low</code> 靠近x, 缩小 <code>low</code></li></ul></li><li>知道 <code>high - low = k - 1</code></li></ul></li></ul><!--做题时的问题--><ul><li><code>high = mid + k - 1 &gt; arr.size()-1 ? arr.size()-1: mid + k - 1;</code>  <em><u>取值写反</u></em></li><li><code>if(abs(arr[low] - x) &lt;= abs(arr[high] - x))</code> <em><u>条件判断 写成 <code>low == 0 || ……</code></u></em></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( x &lt;= arr.<span class="built_in">front</span>())   <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (arr.<span class="built_in">begin</span>(),arr.<span class="built_in">begin</span>()+ k);</span><br><span class="line">        <span class="keyword">if</span>( x &gt;= arr.<span class="built_in">back</span>()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (arr.<span class="built_in">end</span>() - k, arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = arr.<span class="built_in">size</span>(), mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( x &lt;= arr[mid])</span><br><span class="line">                high  = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = low;</span><br><span class="line">        low = <span class="built_in">max</span>(mid - k - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        high = mid + k - <span class="number">1</span> &gt; arr.<span class="built_in">size</span>()<span class="number">-1</span> ? arr.<span class="built_in">size</span>()<span class="number">-1</span>: mid + k - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(high - low &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[low] - x) &lt;= <span class="built_in">abs</span>(arr[high] - x))</span><br><span class="line">                high--; </span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (arr.<span class="built_in">begin</span>() + low, arr.<span class="built_in">begin</span>() + high + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em><strong>例：寻找重复数</strong></em></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><em><strong>Dynamic programming</strong></em> DP </p><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a><em><strong>基本思想</strong></em></h5><p>：原问题分解成子问题进行求解，也就是分治的思想。应用于<strong>子问题重叠</strong>的情况，求解最优化问题。</p><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a><em><strong>性质</strong></em></h5><ul><li><p>子问题重叠：具有公共的子问题</p></li><li><p>最优子结构：能够由子问题的最优解得到更大规模的问题的最优解   || <strong><u><em>子问题之间相互独立、互不干扰</em></u></strong></p><ul><li>最优解涉及几个子问题？</li><li>确定最优解适用哪些子问题，考虑子问题的选择</li></ul></li><li><p>无后效性：某个阶段的最优解一旦求出就不会再变化。</p></li><li><p>base case : 最简单的情况</p></li><li><p>问题 有什么“状态”</p></li><li><p>“状态” 通过什么 “选择” 发生改变 </p><ul><li>状态转移方程的遍历顺序 ：“ <strong>状态转移所依赖的状态必须被提前计算出来</strong> (<strong>根据 base case 和最终状态进行推导</strong>)</li></ul></li><li><p>如何定义dp 数组</p></li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><em><strong>步骤</strong></em></h5><ul><li>定义状态（子问题）,求解问题的自变量</li><li>状态转移方程（子问题之间的联系）</li><li>边界条件（初始值）</li><li>返回值</li></ul><h4 id="经典模型"><a href="#经典模型" class="headerlink" title="经典模型"></a><em><strong>经典模型</strong></em></h4><p><em>线性模型</em>、<em>区间模型</em>、背包模型</p><ul><li><p>线性模型</p><ul><li><p>输出最优解的路径&#x2F;编号</p></li><li><p>实例198. 打家劫舍： 金额向量M[n], 子问题结果DP[n]，路径IND[]</p></li></ul></li><li><p>区间模型</p></li><li><p>背包模型</p></li></ul><h5 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h5><ul><li><p>状态： 背包容量、可选择的物品</p></li><li><p><code>dp</code>数组的定义： <code>dp[i][j]</code>  ： 对于前 <code>i</code>个物品，背包容量为 j ，这种情况下的最大价值为 <code>dp[i][j]</code></p><ul><li>Base case ： <code>dp[i][0] = dp[0][j] = 0</code></li><li>转移：选择第 i 个物品与否<ul><li>不选 ： <code>dp[i][j] = dp[i - 1][j]</code>, 由前一个物品转移而来</li><li>选择：<code>dp[i][j] = dp[i - 1][j - w[i - 1]] + val[i]</code>,</li></ul></li><li>例题：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集 - 力扣（LeetCode） (leetcode-cn.com)</a></li></ul></li></ul><h5 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h5><p>ssss</p><h5 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h5><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a><em>形式</em></h4><p><em><strong>带备忘的自顶向下法</strong></em>：按照递归形式编写，过程中保存子问题的解。</p><p><em><strong>自底向上</strong></em>：将子问题按由小到大顺序进行求解。</p><p><em><strong>状态压缩（空间优化）：</strong></em>滚动数组</p><p><em><strong>dp数组的遍历方向</strong></em> <strong>:</strong>  所需的状态必须是已经计算出来的 | 遍历的终点是存储结果的位置  </p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a><em>例题</em></h4><h5 id="例：-LIS"><a href="#例：-LIS" class="headerlink" title="例： LIS"></a><em><u>例： LIS</u></em></h5><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="例：最大子序和"><a href="#例：最大子序和" class="headerlink" title="例：最大子序和"></a><em><strong>例：</strong></em>最大子序和</h5><ul><li>定义状态：<code>dp[i]</code>为以<code>i</code>结尾的子数组的最优解：</li><li>状态转移：<ul><li><code>dp[i] &gt;= 0 : dp[i + 1]  = dp[i] + nums[i + 1]</code></li><li><code>dp[i] &lt; 0 : dp[i + 1]  = nums[i] </code><!--连续子数组，重头开始--></li><li><code>dp[i + 1] = max(dp[i] + nums[i + 1], dp[i])</code></li></ul></li><li>边界：<code>dp[0] = nums[0]</code></li></ul><h5 id="例：338-比特位计数"><a href="#例：338-比特位计数" class="headerlink" title="例：338. 比特位计数"></a><em><strong>例：</strong></em>338. 比特位计数</h5><p>最高有效位：对于正整数 x<em>x</em>，如果可以知道最大的正整数 y，使得 <code>y ≤ x</code> 且 y 是 2 的整数次幂。</p><ul><li>定义状态：<code>dp[i]</code> 表示正整数<code>i</code>的“一比特数”</li><li>状态转移：<ul><li><code>i</code>为偶数：<code>dp[i] = dp[i / 2]</code> or<code>dp[i] = dp[i &gt;&gt; 1]</code></li><li><code>i</code>为奇数：<code>dp[i] = dp[i / 2] + 1</code>  or<code>dp[i] = dp[i &gt;&gt; 1] + 1</code></li><li><code>dp[i] = dp[i &gt;&gt; 1] + (i &amp; 1)</code></li></ul></li><li>边界：<code>dp[0] = 0, dp[1] = 1</code></li></ul><h5 id="例：剑指-Offer-47-礼物的最大价值"><a href="#例：剑指-Offer-47-礼物的最大价值" class="headerlink" title="例：剑指 Offer 47. 礼物的最大价值"></a><em>例：</em>剑指 Offer 47. 礼物的最大价值</h5><p><em><strong>例：</strong></em> <strong>322.零钱兑换</strong></p><ul><li>定义状态：<code>dp[i] </code>表示总金额为<code>i</code>时所需最少的金币数</li><li>状态转移: <ul><li><code>i &gt; coint[i]</code>:<code>dp[i] = min(dp[i - coint[0]],……dp[i - coint[n]]) + 1</code></li><li><code>i = coint[i]</code>:<code>dp[i] = min(dp[i - coint[0]],……dp[i - coint[n]]) + 1 = 1</code></li><li><code>i &lt; coint[i]</code>: 表示没有硬币组合能组成总金额“-1”，用<code>INT_MAX -1</code>表示</li></ul></li><li>边界：<code>dp[0] = 0</code></li><li>改写为：<code>dp[i] = min(dp[i], dp[i - coint[0：n] + 1])</code></li></ul><p><em><strong>例：最长公共子序列 LCS与LIS</strong></em></p><h5 id="最长公共子序列问题-LCS"><a href="#最长公共子序列问题-LCS" class="headerlink" title="最长公共子序列问题 LCS"></a>最长公共子序列问题 LCS</h5><p>定义 <code>c[i][j]</code> 为序列 <code>Xi , Yi</code>的LCS的长度：<br>$$<br>\begin{cases} 0  \space\space\space\space\space\space\space<br>\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space<br>                    if \space i &#x3D; 0 \space or \space j &#x3D; 0<br>           \c[i-1][j-1] + 1 \space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space if \space xi &#x3D; yi\space and \space i,j &gt; 0<br>           \ max(c[i-1][j],c[i][j-1])\space\space if \space xi !&#x3D; yi<br>\end{cases}<br>$$</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCS_base::lcslength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(size_X + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size_Y + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">subdp</span>(size_X + <span class="number">1</span>, <span class="built_in">vector</span>&lt;string&gt;(size_Y + <span class="number">1</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">//边界为零；</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= size_X; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= size_Y; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (sequence_X[i - <span class="number">1</span>] == sequence_Y[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">subdp[i][j] = subdp[i - <span class="number">1</span>][j - <span class="number">1</span>] + sequence_X[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">subdp[i][j] = subdp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">subdp[i][j] = subdp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp; ii : dp[i]) &#123;</span><br><span class="line">cout &lt;&lt; ii &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;subsequence_Z = subdp[size_X][size_Y]; <span class="comment">// 子序列</span></span><br><span class="line"><span class="keyword">return</span> dp[size_X][size_Y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h5><p><img src="/image-20211227195747538.png" alt="image-20211227195747538"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> row = word1.<span class="built_in">size</span>(), col = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(row + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col + <span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= row; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= col; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= col; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> left = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; </span><br><span class="line">                <span class="keyword">if</span>(word2[j - <span class="number">1</span>] != word1[i - <span class="number">1</span>])</span><br><span class="line">                   left += <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(left,dp[i][j - <span class="number">1</span>] + <span class="number">1</span>),dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li>思想：局部最优解构造全局最优解</li><li>算法设计步骤<ul><li>对于最优化问题： 转化位 对其做出一次选择之后，只剩下一个子问题</li><li>证明做出贪心选择后，原问题总是存在最优解</li><li>证明：剩余子问题的最优解的组合 能够 得到原问题的最优解</li></ul></li></ul><h5 id="例-：哈夫曼编码"><a href="#例-：哈夫曼编码" class="headerlink" title="例 ：哈夫曼编码"></a>例 ：哈夫曼编码</h5><p>思想：<img src="http://picgo.wangeyi.ink/image-20211228212326955.png" alt="image-20211228212326955"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><ul><li>解决 在数组中选择出第K大|小的数 的问题</li></ul><h4 id="快速选择算法"><a href="#快速选择算法" class="headerlink" title="快速选择算法"></a>快速选择算法</h4><ul><li><p>：基于快速排序:( 当标准值下标为 目标值时返回， 否则递归处理左右子数组)</p><ul><li>例：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/">数组中的第K个最大元素 </a></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 第k大</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QuickSelect</span>(nums,k,<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">QuickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> k,<span class="type">int</span> left,<span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lp = left,rp = right;</span><br><span class="line">        <span class="type">int</span> standval = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(lp &lt; rp) &#123;</span><br><span class="line">            <span class="keyword">while</span>(lp &lt; rp &amp;&amp; nums[rp] &lt; standval) rp--; <span class="comment">// 前面是比nums[kindex] 小的</span></span><br><span class="line">            <span class="keyword">if</span>(rp &gt; lp) &#123;</span><br><span class="line">                nums[lp] = nums[rp];</span><br><span class="line">                lp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(lp &lt; rp &amp;&amp; nums[lp] &gt;= standval) lp++;</span><br><span class="line">            <span class="keyword">if</span>(lp &lt; rp) &#123;</span><br><span class="line">                nums[rp] = nums[lp];</span><br><span class="line">                rp--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[lp] = standval;</span><br><span class="line">        <span class="keyword">if</span>(lp == k - <span class="number">1</span>) &#123; <span class="comment">// 当前位置就是 第 k 大元素</span></span><br><span class="line">            <span class="keyword">return</span> standval;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(lp &lt; k - <span class="number">1</span>)&#123;  <span class="comment">// 当前位置比 第 k 大元素 小， </span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">QuickSelect</span>(nums,k,lp + <span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">QuickSelect</span>(nums,k,left,lp - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迭代</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="基于堆排序"><a href="#基于堆排序" class="headerlink" title="基于堆排序"></a>基于堆排序</h4><ul><li><p>建立一个大根堆，做 k - 1<em>k</em>−1 次删除操作后堆顶元素就是我们要找的答案</p></li><li><p>考察知识点 <em><strong>建堆</strong></em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bulidheap</span>(nums);</span><br><span class="line">    <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>],nums[size - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums,<span class="number">0</span>,--size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bulidheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = nums.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums,i,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//维护堆的性质</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> i,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> left = [](<span class="type">const</span> <span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> right = [](<span class="type">const</span> <span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;&#125;;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">left</span>(i) &lt; size &amp;&amp; nums[<span class="built_in">left</span>(i)] &gt; nums[largest]) &#123;</span><br><span class="line">            largest = <span class="built_in">left</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">right</span>(i) &lt; size &amp;&amp; nums[<span class="built_in">right</span>(i)] &gt; nums[largest]) &#123;</span><br><span class="line">            largest = <span class="built_in">right</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(largest == i)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[largest]);</span><br><span class="line">        i = largest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul><li>AOV(Activity On Vertex Network) : 有向无环图 的线下序列</li><li>要点： 每次删除入度边数为0 的结点，并刷新其他点的入度边数</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串匹配算法</p><h5 id="例：-10-正则表达式匹配"><a href="#例：-10-正则表达式匹配" class="headerlink" title="例： 10. 正则表达式匹配 "></a><em><strong><a href="https://leetcode-cn.com/problems/regular-expression-matching/">例： 10. 正则表达式匹配 </a></strong></em></h5><blockquote><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元、</li></ul><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>&#x2F;&#x2F;动态规划？</p></blockquote><ul><li>每次从字符串 <code>p</code> 取出一个字符 或 字符 + <code>*</code>的组合<ul><li><code>p</code>中的一个字符 ： 匹配<code>s</code>中一个字符</li><li><code>p</code>中的一个字符 + <code>*</code> 组合： 匹配 <code>s</code> 中任意个数的字符</li></ul><p></p></li><li>状态 <code>dp</code> ： <code>dp[i][j]</code> 表示 <code>s</code> 的前<code>i</code>个字符能够被 <code>p</code>的前 <code>j</code> 个字符匹配。</li><li>转移方程：  从 <code>s[i]、p[j]</code> 入手<ul><li><code>s[i]、p[j]</code> 能够匹配上，需要看前面 <code>s 的前 i - 1 字符 与 p 的前 j - 1个 字符是否匹配</code><ul><li><code>p[j] == s[i] || p[j] == &#39;.&#39;</code>   则   <code>dp[i][j] = dp[i - 1][j -1]</code></li></ul></li><li><code>p[j] == &#39;*&#39;</code>:   匹配任意自然数前一个字符 <code>p[j - 1]</code><ul><li><code>p[j - 1] != s[i]</code> ： 要看 <code>s[i]</code> 和  <code>p[j - 2] 是否匹配</code> ，  * 匹配零个字符，相当于去掉  <code>p[j]、p[j -1] 两个字符</code><ul><li><code>dp[i][j] = dp[i][j - 2]</code></li></ul></li><li><code>p[j - 1] == s[i] || p[j - 1] == &#39;.&#39;</code>：   <code>*</code> 前面一个字符能够匹配上  <code>###b  和 ###b*</code>  <ul><li><code>dp[i][j] = dp[i - 1][j] </code> :  看   <code>###</code>  和 <code>###b*</code> 能否匹配 </li><li>or <code>dp[i][j] = dp[i][j - 2] </code> :  看   <code>###b</code>  和 <code>###</code> 能否匹配, 去掉 b*</li></ul></li></ul></li><li>总结： 边界 ：<code>dp[0][0] = true; 空串能匹配上，dp[i][0] = false; </code></li></ul></li></ul><h4 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h4><blockquote><p>线性时间内求出以每个位置为<strong>回文</strong>中心的回文半径</p></blockquote><ul><li><p>奇数偶数子串：每个字符间插入**”#”**（<u>原串中不存在的字符</u>），并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 <u>“^” 和 “$”</u></p></li><li><p><img src="/image-20220404150637719.png" alt="image-20220404150637719"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="title function_">longestPalindrome</span><span class="params">(string s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty() || s.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对原始字符串做处理，将abc变成#a#b#c#</span></span><br><span class="line">        <span class="type">string</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s) &#123;</span><br><span class="line">            tmp += c;</span><br><span class="line">            tmp += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tmp.size();</span><br><span class="line">        <span class="comment">//right表示目前计算出的最右端范围，right和左边都是已探测过的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//center最右端位置的中心对称点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//p数组记录所有已探测过的回文半径，后面我们再计算i时，根据p[i_mirror]计算i</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="title function_">p</span><span class="params">(n, <span class="number">0</span>)</span>;</span><br><span class="line">        <span class="comment">//从左到右遍历处理过的字符串，求每个字符的回文半径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">//根据i和right的位置分为两种情况：</span></span><br><span class="line">            <span class="comment">//1、i&lt;=right利用已知的信息来计算i</span></span><br><span class="line">            <span class="comment">//2、i&gt;right，说明i的位置时未探测过的，只能用中心探测法</span></span><br><span class="line">            <span class="keyword">if</span>(right &gt;= i) &#123;</span><br><span class="line">                <span class="comment">//这句是关键，不用再像中心探测那样，一点点的往左/右扩散，根据已知信息</span></span><br><span class="line">                <span class="comment">//减少不必要的探测，必须选择两者中的较小者作为左右探测起点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">minArmLen</span> <span class="operator">=</span> min(right - i, p[<span class="number">2</span> * center - i]);</span><br><span class="line">                p[i] = expand(tmp, i - minArmLen, i + minArmLen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//i落在right右边，是没被探测过的，只能用中心探测法</span></span><br><span class="line">                p[i] = expand(tmp, i, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//大于right，说明可以更新最右端范围了，同时更新center</span></span><br><span class="line">            <span class="keyword">if</span>(i + p[i] &gt; right) &#123;</span><br><span class="line">                center = i;</span><br><span class="line">                right = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到了一个更长的回文半径，更新原始字符串的start位置</span></span><br><span class="line">            <span class="keyword">if</span>(p[i] &gt; maxLen) &#123;</span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                start = (i - p[i]) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据start和maxLen，从原始字符串中截取一段返回</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//以left和right为起点，计算回文半径，由于while循环退出后left和right各多走了一步</span></span><br><span class="line">    <span class="comment">//所以在返回的总长度时要减去2</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">expand</span><span class="params">(string s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right - left - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LRU-最近最少使用"><a href="#LRU-最近最少使用" class="headerlink" title="LRU (最近最少使用)"></a>LRU (最近最少使用)</h3><ul><li>哈希链表实现，借助链表的有序性（一直在链表头部插入数据，维护数据按照时间排列的性质）</li><li>借助哈希表的常数访问时间，可以以o(1) 的时间复杂度访问链表的任意元素</li></ul><h3 id="LFU-最不经常使用"><a href="#LFU-最不经常使用" class="headerlink" title="LFU(最不经常使用)"></a>LFU(最不经常使用)</h3><ul><li><p>把数据按照访问频次进行排序，淘汰频次最少（最久未使用的）</p></li><li><p>基本数据结构:</p></li><li><pre><code class="c++">unordered_map&lt;int.int&gt; keyToval;   // key、 val 的映射unordered_map&lt;int.int&gt; keyTofreq; // key、 freq 的映射int minfreq; // 最少的频数unordered_map&lt;int,listedMap&lt;int&gt;&gt;freaqTokeys;// 频数对应的 键列表listedMap&lt;int&gt;// 哈希链表<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 框架：</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  // get:</span><br><span class="line">  //返回key对用的val。 增加key 对应的 freq</span><br><span class="line">  int get(int key) &#123;</span><br><span class="line">  if(keyToval.find(key) == keyToval.end())</span><br><span class="line">          return -1;</span><br><span class="line">      increaseFreq(key);</span><br><span class="line">      return keyToval[key];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //put:</span><br><span class="line">  //1.key 已存在： </span><br><span class="line">  //修改key 对应的值、 增加key对用freq</span><br><span class="line">  //2. key 不存在：</span><br><span class="line">  //容量已满：</span><br><span class="line">  //淘汰freq 最小的key； </span><br><span class="line">  //容量为满：</span><br><span class="line">  //插入键值对（key，val）。key 对应的freq = 1</span><br><span class="line">  void put(int key,int val) &#123;</span><br><span class="line">  // 已存在：</span><br><span class="line">      if(keyToval.find(key) != keyToval.end()) &#123;</span><br><span class="line">  keyToval[key] = val;</span><br><span class="line">          increaseFreq(key);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      // 不存在：</span><br><span class="line">      if(ketToval.size() &gt;= this-&gt;cap)&#123;</span><br><span class="line">  removeMinFreq();</span><br><span class="line">      &#125;</span><br><span class="line">      // 插入新键值对</span><br><span class="line">      keyToval[key] = val;</span><br><span class="line">      keyToFreq[key] = 1;</span><br><span class="line">      // fk</span><br><span class="line">      if(freqTokeys.find(1) == freqTokeys.end())</span><br><span class="line">          freqTokeys[1] = new listedMap&lt;int&gt;();</span><br><span class="line">      freqTokeys[1].insert(key);</span><br><span class="line">      this-&gt;minfreq = 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>核心：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="算法技巧"><a href="#算法技巧" class="headerlink" title="算法技巧"></a>算法技巧</h3><h4 id="位运算。。"><a href="#位运算。。" class="headerlink" title="位运算。。"></a>位运算。。</h4><ul><li>二进制中最低的一位 ： <code>A &amp; -A</code></li><li>二的幂 ： <code>A &amp; (A - 1) == 0</code><ul><li>A 是 二的幂： 二进制只有一个 <code>1</code>位 <em><strong>例（1000）</strong></em>， A - 1 为 ：<em><strong>例(0111)</strong></em> , 逻辑与的结果为零</li></ul></li><li>迭代式： <code> x = x &amp; (x-1) 统计1的个数，x = x | (x + 1) 统计0的个数</code></li></ul><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><p><em><strong>定义</strong></em> </p><p><em>数组的某个索引及这个索引前面的所有元素之和</em></p><p><em><strong>一维：</strong></em> </p><ul><li><p>一维数组 <code>x</code> 和*<u>一维前缀和数组</u>* <code>y</code> 满足： <code>y0 = x0, y1 = x0 + x1, y2 = x0 + x1 + x2, …… yn = x0 + x1 +x2 +…… +xn   </code></p></li><li><p>得到前缀和：<code>yn = xn + yn-1</code>   <!--计算前缀和数组O(n)--></p></li></ul><h5 id="二维："><a href="#二维：" class="headerlink" title="二维："></a><em><strong>二维：</strong></em></h5><ul><li>二维数组 a 和 前缀和数组 <img src="/image-20210910142333574.png" alt="image-20210910142333574"></li><li>前缀和公式：<ul><li><code>0,0</code>： <code>b0,0 = a0,0</code></li><li><code>0,j </code>:   <code>b0,j = b0,j-1 + a0,j</code></li><li><code>i,0</code>:  <code>bi,0 = bi-1,0 + ai,0</code></li><li><code>i,j</code>: <code>bi,j = bi-1,j + bi-1,j - bi-1.j-1 +ai,j </code></li></ul></li></ul><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><em>作用</em></h5><p>前缀和是一种预处理，用于降低查询时的时间复杂度, [L,R] 之间的值为  ： <code>y[R] - y[L-1]</code></p><h5 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a><em>例题</em></h5><p><em><strong>例：</strong></em>209. 长度最小的子数组<!--前缀和 + 二分查找--></p><ul><li>正整数数组： 前缀和数组递增。对于每个下标，利用二分查找满足 <code>Y[j] - Y[i - 1] &gt;= target</code></li><li>维护 结果 <code>ret =min(ret,j - i + 1) </code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">yn</span><span class="params">(nums.size() + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; yn.<span class="built_in">size</span>(); i++)</span><br><span class="line">            yn[i] = yn[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; yn.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> start = i, end = yn.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">                m = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(yn[m] - yn[i - <span class="number">1</span>]  &lt; target)</span><br><span class="line">                    start = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    end = m; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start &lt; yn.<span class="built_in">size</span>())</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, start - i + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em><strong>例：</strong></em>238. 除自身以外数组的乘积(<em>使用除法很简单</em>)</p><ul><li>数组<code>nums</code>，前缀乘积 <code>fnums</code>, 后缀乘积 <code>bnums</code>， 结果 <code>ans</code></li><li><code>fnums[i] = fnums[i - 1] * nums[i]</code>, </li><li><code>ans[i] = fnums[i - 1] * bnums[i + 1]</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fnums</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span>, <span class="title">bnums</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fnums[i + <span class="number">1</span>] = fnums[i] * nums[i];</span><br><span class="line">            bnums[n - i - <span class="number">1</span>] = bnums[n - i] * nums[n - i - <span class="number">1</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = fnums[i] * bnums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em><strong>例：</strong></em>304. 二维区域和检索 - 矩阵不可变</p><ul><li>计算二维数组的前缀和，<code>sums[R][C]</code></li><li>结果: <code>ans = sums[r2][c2] - sums[r2][c1 - 1] - sums[r1 - 1][c2] + nums[r1-1][c1-1]</code>  <!--注意数组越界 --></li></ul><h4 id="双指针与滑动窗口"><a href="#双指针与滑动窗口" class="headerlink" title="双指针与滑动窗口"></a>双指针与滑动窗口</h4><h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a><em><strong>快慢指针</strong></em></h5><ul><li>主要解决链表中的问题： 一般初始化指向链表的头节点，前进时快指针在前，慢指针在后。</li></ul><p><em><strong>例</strong></em>：141. 环形链表</p><ul><li>如果不含有环，跑得快的指针最终会指向null，</li><li>如果含有环，快指针会套圈与慢指针相遇</li></ul><p><em><strong>例：</strong></em>剑指 Offer II 022. 链表中环的入口节点</p><ul><li>快慢指针相遇时，慢指针走了<code>K</code>步，快指针走了<code>2k</code>步</li><li>相遇点到入环点的距离 <code>K-M</code> 与起点到入环点的距离相等。</li></ul><p><em><strong>例：</strong></em> 寻找链表的中点、链表的倒数第K个元素</p><p><em><strong>例： 相交链表</strong></em></p><h5 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a><em><strong>左右指针</strong></em></h5><ul><li>左右指针在数组中实际是指两个索引值，一般初始化为 <code>left = 0, right = nums.length - 1</code></li></ul><p><em><strong>例</strong></em>: 二分查找、两数之和、反转数组</p><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><em><strong>滑动窗口</strong></em></h5><ul><li>解决子字符串的一大类问题。</li></ul><p>模板：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h4><p><em><strong>例：</strong></em>剑指 Offer 58 - II. 左旋转字符串</p><ul><li>设 <code>x&#39;</code>表示<code>x</code>的反转则<code>（x&#39;+ y&#39;）&#39; = y + x</code></li></ul><h6 id="判断字符串包含字符，不考虑数量"><a href="#判断字符串包含字符，不考虑数量" class="headerlink" title="判断字符串包含字符，不考虑数量"></a>判断字符串包含字符，不考虑数量</h6><p>用整型 的0~26 二进制位 表示 a ~ z 的状态</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    string word = words[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; word.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        temp[i] |= <span class="number">1</span> &lt;&lt; (word[j] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>$$<br>a^n &#x3D; \begin{cases}<br> a^{n-1} * a,  n 是奇数<br> \ a^{n&#x2F;2} *a^{n&#x2F;2}, n是偶数<br> \ 1 , n &#x3D; 0</p><p>\end{cases}<br>$$</p><h4 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h4><p><em><strong><code>Trie</code>树，即字典树，又称单词查找树</strong></em>: 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><p>实现<code>Trie</code>类 <a href="#trie">Trie类</a></p><p><strong>性质</strong></p><ul><li><p>特殊的多叉树、子节点有26个（输入仅为小写字母时） -<strong>[26叉树]</strong></p></li><li><p>&#96;&#96;&#96;c++<br>&#x2F;&#x2F;前缀树的节点定义<br>class TrieNode {<br>public:<br>vector&lt;TrieNode*&gt; children;<br>bool isWord;<br>TrieNode() : isWord(false), children(26, nullptr) {<br>}<br>~TrieNode() {<br>    for (auto&amp; c : children)<br>        delete c;<br>}<br>};</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `TrieNode` 里面存储了两个信息：</span><br><span class="line"></span><br><span class="line">  - `children` 是该节点的所有子节点。</span><br><span class="line">  - `isWord` 表示从根节点到当前节点为止，该路径是否形成了一个有效的字符串。</span><br><span class="line"></span><br><span class="line">##### 构建字典树</span><br><span class="line"></span><br><span class="line">- 根节点不保存任何信息；</span><br><span class="line">- 关键词放到「前缀树」时，需要把它拆成各个字符，每个字符按照其在 &#x27;a&#x27; ~ &#x27;z&#x27; 的序号，放在 `chidren` 对应的位置里面。下一个字符是当前字符的子节点。</span><br><span class="line">- 一个输入字符串构建「前缀树」结束的时候，需要把该节点的 `isWord` 标记为 true，说明从根节点到当前节点的路径，构成了一个关键词。</span><br><span class="line"></span><br><span class="line">##### 查询</span><br><span class="line"></span><br><span class="line">- 在寻找径的过程中，发现到某个位置路径断了。不存在这样的关键词</span><br><span class="line">- 找到了这条路径，但是最后一个节点的 `isWord` 为 false。不存在这样的关键词</span><br><span class="line">- 找到了这条路径，并且最后一个节点的 `isWord` 为 true。这说明前缀树存储了这个关键词</span><br><span class="line"></span><br><span class="line">**例：**[211. 添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">struct TrieTree &#123;</span><br><span class="line">    vector&lt;TrieTree*&gt; childen;</span><br><span class="line">    bool isword;</span><br><span class="line">    TrieTree() :isword(false), childen(26,nullptr) &#123;&#125;</span><br><span class="line">    ~TrieTree() &#123;</span><br><span class="line">        for(auto &amp;c : childen)</span><br><span class="line">            delete c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class WordDictionary &#123;</span><br><span class="line">public:</span><br><span class="line">    TrieTree * root;</span><br><span class="line">    WordDictionary() &#123;</span><br><span class="line">        root = new TrieTree();</span><br><span class="line">    &#125;</span><br><span class="line">    ~WordDictionary() &#123;</span><br><span class="line">        delete root;</span><br><span class="line">    &#125;</span><br><span class="line">    void addWord(string word) &#123;</span><br><span class="line">        TrieTree* move = root;</span><br><span class="line">        for(char &amp; str : word) &#123;</span><br><span class="line">            if(move-&gt;childen[str - &#x27;a&#x27;] == nullptr)</span><br><span class="line">                move-&gt;childen[str - &#x27;a&#x27;] = new TrieTree();</span><br><span class="line">            move = move-&gt;childen[str - &#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        move-&gt;isword = true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool back(string &amp;word, TrieTree * root, int depth) &#123; //树的深度表示字符串的长度0开始</span><br><span class="line">        if(root == nullptr) return false;</span><br><span class="line">        if(depth == word.size()) return root-&gt;isword;</span><br><span class="line">        bool ans = false;</span><br><span class="line">        if(word[depth] != &#x27;.&#x27;)</span><br><span class="line">            return back(word,root-&gt;childen[word[depth] - &#x27;a&#x27;],depth + 1);</span><br><span class="line">        else &#123;</span><br><span class="line">            for(TrieTree *&amp; chi : root-&gt;childen)&#123;</span><br><span class="line">                ans |= back(word,chi,depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        return back(word,root,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your WordDictionary object will be instantiated and called as such:</span><br><span class="line"> * WordDictionary* obj = new WordDictionary();</span><br><span class="line"> * obj-&gt;addWord(word);</span><br><span class="line"> * bool param_2 = obj-&gt;search(word);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul><h4 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h4><p><em><strong>求众数</strong></em></p><p>Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：</p><ul><li>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</li><li>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：<ul><li>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</li><li>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</li></ul></li><li>在遍历完成后，candidate 即为整个数组的众数。</li></ul><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p><a name = "单调栈"></a></p><ul><li>单调递增栈即栈内元素保持单调递增的栈，同理单调递减栈即栈内元素保持单调递减的栈<ul><li>可以以 O(1) 的时间复杂度得知某个位置左右两侧比他大（或小）的数的位置</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">  <span class="keyword">while</span>(! stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &gt; T[i])&#123;</span><br><span class="line">    stk.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  stk.<span class="built_in">push</span>(A[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p><a name ="单调队列"></a></p><ul><li>用单调队列来解决问题，一般都是需要得到当前的某个范围内的最小值或最大值。</li></ul><p><em><strong>例题：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></strong></em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; sque; <span class="comment">// 存的是下标</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!sque.<span class="built_in">empty</span>() &amp;&amp; i - sque.<span class="built_in">front</span>() &gt;= k) &#123;  <span class="comment">//  超出窗口大小，将队头元素pop</span></span><br><span class="line">                sque.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!sque.<span class="built_in">empty</span>() &amp;&amp; nums[sque.<span class="built_in">back</span>()] &lt; nums[i]) &#123; <span class="comment">// 维护单调递减队列</span></span><br><span class="line">                sque.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            sque.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k <span class="number">-1</span>)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[sque.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h4><blockquote><p>N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉</p></blockquote><ul><li><p>模拟：链表实现，删除节点o(1)</p><ul><li>index 表示当前删除的位置，下次删除的位置为： index + m - 1， 从头取数： (index + m - 1) % n；</li></ul></li><li><p>动态规划：</p><ul><li>输入 n, mn,m ，记此约瑟夫环问题为 「n, mn,m 问题」 ，设解（即最后留下的数字）为 f(n)f(n) ，则有：<ul><li><code>「n, m 问题」</code>：数字环为 0, 1, 2, …, n - 10,1,2,…,n−1 ，解为 f(n)f(n) ；</li><li><code>「n-1, m 问题」</code>：数字环为 0, 1, 2, …, n - 20,1,2,…,n−2 ，解为 f(n-1)f(n−1) ； 以此类推…</li></ul></li><li><img src="image-20220402165432792.png" alt="image-20220402165432792" style="zoom: 80%;" /></li><li><strong>状态定义</strong>： 设<code>「i, m  问题」</code>的解为 <code>dp[i]</code> ；</li><li><strong>转移方程</strong>： 通过以下公式可从 <code>dp[i - 1]</code> 递推得到 <code>dp[i]</code> ；<ul><li><code>dp[i] = (dp[i - 1] + m) \% i</code></li><li><code>dp[i]=(dp[i−1]+m)%i</code></li></ul></li><li><strong>初始状态</strong>：「1, m 问题」的解恒为 00 ，即 <code>dp[1] = 0</code> ；</li><li><strong>返回值</strong>： 返回「n, m 问题」的解 <code>dp[n]</code> ；</li></ul></li></ul><h4 id="两数的最大公约数"><a href="#两数的最大公约数" class="headerlink" title="两数的最大公约数"></a>两数的最大公约数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123; <span class="comment">// z</span></span><br><span class="line"><span class="type">int</span> rem;<span class="comment">//余数，当余数为0的时候，最后的m即为最大公约数</span></span><br><span class="line"><span class="comment">//先用较小的数对较大的数取余，再用余数对较小的数求余，直到余数为零 </span></span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">rem = m % n;</span><br><span class="line">m = n;</span><br><span class="line">n = rem;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> m;<span class="comment">//将结果返回</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="哈希表链接法"><a href="#哈希表链接法" class="headerlink" title="哈希表链接法"></a>哈希表链接法</h3><p><a name = "链接法"></a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HashSize 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">T val;</span><br><span class="line">Node * next;</span><br><span class="line"><span class="built_in">Node</span>() : <span class="built_in">val</span>(), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line"><span class="built_in">Node</span>(T v) : <span class="built_in">val</span>(v), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line"><span class="built_in">Node</span>(T v, Node* n) : <span class="built_in">val</span>(v), <span class="built_in">next</span>(n) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;T&gt; *node[HashSize];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val % HashSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">HashTable</span>();</span><br><span class="line">~<span class="built_in">HashTable</span>();</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(T val)</span></span>; </span><br><span class="line"><span class="function">Node&lt;T&gt;* <span class="title">Search</span><span class="params">(T val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Detlete</span><span class="params">(T val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;HashTable.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">HashTable&lt;T&gt;::<span class="built_in">HashTable</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; HashSize; ++i) &#123;</span><br><span class="line">node[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">HashTable&lt;T&gt;::~<span class="built_in">HashTable</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> HashTable&lt;T&gt;::<span class="built_in">Insert</span>(T val) </span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt; * head = node[<span class="built_in">Hash</span>(val)];</span><br><span class="line">Node&lt;T&gt; * newNode = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">head = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val &lt; head-&gt;val) &#123;</span><br><span class="line">newNode-&gt;next = head;</span><br><span class="line">head = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;T&gt; * p = head;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;next != <span class="literal">nullptr</span> &amp;&amp; p-&gt;val &lt; val) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line">node[<span class="built_in">Hash</span>(val)] = head;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//搜索</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node&lt;T&gt;* HashTable&lt;T&gt;::<span class="built_in">Search</span>(T val)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt; *head = node[<span class="built_in">Hash</span>(val)];</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val != val) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head ? head : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> HashTable&lt;T&gt;::<span class="built_in">Detlete</span>(T val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">Search</span>(val)) &#123;</span><br><span class="line">Node&lt;T&gt; *head = node[<span class="built_in">Hash</span>(val)];</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;next != <span class="literal">nullptr</span> &amp;&amp; head-&gt;next-&gt;val != val) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> HashTable&lt;T&gt;::<span class="built_in">printTable</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; HashSize; ++i) &#123;</span><br><span class="line">Node&lt;T&gt; *p = node[i];</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;N&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p><a name = "二叉树迭代"></a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        stack&lt;TreeNode*&gt; mstack;</span><br><span class="line">        <span class="keyword">while</span>(!mstack.<span class="built_in">empty</span>() || root) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                mstack.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = mstack.<span class="built_in">top</span>();</span><br><span class="line">            mstack.<span class="built_in">pop</span>();</span><br><span class="line">            root = root-&gt;right; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        stack&lt;TreeNode*&gt; stacks;</span><br><span class="line">        <span class="keyword">while</span>(!stacks.<span class="built_in">empty</span>() || root)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                stacks.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stacks.<span class="built_in">top</span>();</span><br><span class="line">            stacks.<span class="built_in">pop</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root -&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">stack&lt;TreeNode*&gt; s;</span><br><span class="line">TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (cur || !s.<span class="built_in">empty</span>()) &#123;<span class="comment">//同样是不断遍历左子树</span></span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line">s.<span class="built_in">push</span>(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">cur = s.<span class="built_in">top</span>();</span><br><span class="line"><span class="keyword">if</span> (!cur-&gt;right || pre == cur-&gt;right) &#123;<span class="comment">//当该节点的右子树为空或者该节点的右节点是上次遍历过的节点，则直接弹出</span></span><br><span class="line">v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">pre = cur;</span><br><span class="line">cur = <span class="literal">NULL</span>;<span class="comment">//当弹出一个节点时，说明该树已经遍历完了，那么就要把cur设置为NULL</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//否则就遍历右子树</span></span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line">pre = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name ="层序遍历"></a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; size; ++i)&#123;</span><br><span class="line">                TreeNode * newroot = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(newroot-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(newroot-&gt;left) que.<span class="built_in">push</span>(newroot-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(newroot-&gt;right) que.<span class="built_in">push</span>(newroot-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h3><ul><li>第⼀步：如果数组⼤⼩为零的话，说明是空节点了。</li><li>第⼆步：如果不为空，那么取后序数组最后⼀个元素作为节点元素。</li><li>第三步：找到后序数组最后⼀个元素在中序数组的位置，作为切割点</li><li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，⼀定是先切中序数组）</li><li>第五步：切割后序数组，切成后序左数组和后序右数组？</li><li>第六步：递归处理左区间和右区间</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码 中序数组和后序数组的长度一样</span></span><br><span class="line"><span class="comment">//第一步</span></span><br><span class="line"><span class="keyword">if</span>(postorde.<span class="built_in">size</span>()== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line"><span class="comment">//第二步</span></span><br><span class="line">Treenode* root = <span class="keyword">new</span> <span class="built_in">Treenode</span>(postorder.<span class="built_in">back</span>());</span><br><span class="line"><span class="keyword">if</span>(postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root; <span class="comment">//叶子节点</span></span><br><span class="line"><span class="comment">//第三步</span></span><br><span class="line"><span class="type">int</span> Index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;Index &lt; inorder.<span class="built_in">size</span>(); ++Index)&#123;</span><br><span class="line"><span class="keyword">if</span>(inorder[Index] == root-&gt;val) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第四步 左闭右开</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftinorder</span><span class="params">(inorder.begin(),inorder.begin() + Index)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightinorder</span><span class="params">(inorder.begin() + Index + <span class="number">1</span>,inorder.end())</span></span>;</span><br><span class="line"><span class="comment">//第五步</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftpostorder</span><span class="params">(postorder.begin(),postorder.begin() + leftinorder.size())</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightpostorder</span><span class="params">(postorder.begin() + leftinorder.size() + <span class="number">1</span>, postorder.end() - <span class="number">1</span>)</span></span>;  <span class="comment">// 舍弃尾部元素</span></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">root-&gt;left = <span class="built_in">dfs</span>(leftinorder,leftpostorder);</span><br><span class="line">root-&gt;right = <span class="built_in">dfs</span>(rightinorder,rightpostorder);</span><br></pre></td></tr></table></figure><h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><ul><li>如果找到⼀个节点，发现左⼦树出现结点p，右⼦树出现节点q，或者 左⼦树出现结点q，右⼦树出现节点p<ul><li>那么该节点就是节点p和q的最近公共祖先。</li></ul></li><li>自底向上- 后序遍历</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q || root == <span class="literal">nullptr</span>)  <span class="keyword">return</span> root;    <span class="comment">//找到p，q结点或者空就回溯到上一层</span></span><br><span class="line">        TreeNode * left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode * right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="comment">//p,q 结点存在于root 的左右子树</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> right;                           <span class="comment">//最近的公共祖先存在右子树种</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> left;                            <span class="comment">//最近的公共祖先存在左子树种</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树-1"><a href="#二叉搜索树-1" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><a name = "binaryseachtree"></a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* move = root;</span><br><span class="line">        <span class="keyword">while</span>(move) &#123;</span><br><span class="line">            <span class="keyword">if</span>(move-&gt;val &gt; val) &#123;</span><br><span class="line">                <span class="keyword">if</span>(move-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    move-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                move = move-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(move-&gt;val &lt; val) &#123;</span><br><span class="line">                <span class="keyword">if</span>(move-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    move-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                move = move-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root ? root : <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="前缀树-1"><a href="#前缀树-1" class="headerlink" title="前缀树"></a>前缀树</h3><p><a name = "trie"></a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    vector&lt;TrieNode *&gt; childen;</span><br><span class="line">    <span class="built_in">TrieNode</span>(): <span class="built_in">isWord</span>(<span class="literal">false</span>), <span class="built_in">childen</span>(<span class="number">26</span>,<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(TrieNode *&amp; cha : childen)</span><br><span class="line">            <span class="keyword">delete</span> cha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode * move = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> &amp;alpha : word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(move-&gt;childen[alpha - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">                move-&gt;childen[alpha - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            move = move-&gt;childen[alpha - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        move-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word,root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string&amp; word, TrieNode *&amp; r,<span class="type">int</span> depth = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth == word.<span class="built_in">size</span>()) <span class="keyword">return</span> r-&gt;isWord;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word,r-&gt;childen[word[depth] - <span class="string">&#x27;a&#x27;</span>],depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">startsWith</span>(prefix,root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix,TrieNode *&amp; r,<span class="type">int</span> depth = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="literal">nullptr</span> &amp;&amp; depth &lt;= prefix.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt;= prefix.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">startsWith</span>(prefix,r-&gt;childen[prefix[depth] - <span class="string">&#x27;a&#x27;</span>],depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode * root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><ul><li><p>状态数组：<code>f[i][j] 表示“前 i 件物品总重量为 j 时能获得的最大价值”；</code></p></li><li><p>状态转移方程：<code>f[i][j] = max(f[i - 1][j], f[i - 1][j - c[i]] + v[i])。</code></p><ul><li><code>f[i][j] = f[i - 1][j]</code> : 第<code>i</code>件物品不装入</li><li><code>f[i][j] = f[i - 1][j - c[i]] + v[i]</code>： 装入第<code>i</code>件物品</li></ul></li><li><p>滚动数组空间优化：<code>f[i] 表示“总重量为 i 时能获得的最大价值”</code> </p><ul><li>滚动数组： <em><strong>把上一层的数据拷贝的到当前层</strong></em> （）</li></ul></li><li><pre><code class="c++">// 01背包问题伪代码(空间优化版)for j = 1,...,N  //表示第j个物品： for依次表示第j件物品存入的情况    for i = C,...,c[j] // 必须逆向枚举!!!        f[i] = max(f[i], f[i−c[j]]+v[j]</code></pre></li><li><p>先物品后容量： 保证上一层的数据是计算完的，</p></li><li><p>重量逆序遍历： 保证 f[i−c[j]]的值是上一层的（前一时刻的值）</p><ul><li>而正序的话，  f[i−c[j]] 的值已经被当前层覆盖</li><li></li></ul></li></ul>]]></content>
    
    
    <summary type="html">数据结构与算法</summary>
    
    
    
    <category term="笔记" scheme="http://blog.wangeyi.ink/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
