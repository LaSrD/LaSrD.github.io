<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++ 基础 | We</title><meta name="author" content="We_"><meta name="copyright" content="We_"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="C++ 语法">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 基础">
<meta property="og:url" content="http://blog.wangeyi.ink/2022/06/13/C-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="We">
<meta property="og:description" content="C++ 语法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://picgo.wangeyi.ink/pexels-messala-ciulla-1162643.jpg">
<meta property="article:published_time" content="2022-06-13T12:17:42.000Z">
<meta property="article:modified_time" content="2022-07-07T08:53:26.683Z">
<meta property="article:author" content="We_">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://picgo.wangeyi.ink/pexels-messala-ciulla-1162643.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.wangeyi.ink/2022/06/13/C-%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-07-07 16:53:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="We" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.jpg" onerror="onerror=null;src='/img/me.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/run/"><i class="fa-fw fas fa-heart"></i><span> Run</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://picgo.wangeyi.ink/pexels-messala-ciulla-1162643.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">We</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/run/"><i class="fa-fw fas fa-heart"></i><span> Run</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ 基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-13T12:17:42.000Z" title="发表于 2022-06-13 20:17:42">2022-06-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-07T08:53:26.683Z" title="更新于 2022-07-07 16:53:26">2022-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ 基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<h2 id="内存区"><a href="#内存区" class="headerlink" title="内存区"></a>内存区</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><ul>
<li>分为代码区、全局区（静态区）、栈区、堆区。<ul>
<li>代码区：存放程序编译之后可以执行代码的地方</li>
<li>全局区：存放全局变量、静态变量，在程序结束之后操作系统释放</li>
<li>栈区：由编译其自动分配释放，存放函数的参数值以及局部变量等</li>
<li>堆区：一般由程序员通过 <code>new</code> 开辟空间，进行分配和释放，若程序员不释放，则程序结束时由操作系统回收</li>
</ul>
</li>
</ul>
<p>测试例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//局部非静态变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> d = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//动态分配内存</span></span><br><span class="line">	<span class="type">int</span>* d_a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="type">int</span>* d_b = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;g_a: &quot;</span> &lt;&lt; <span class="built_in">int</span>(&amp;g_a)&lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;g_b: &quot;</span> &lt;&lt; <span class="built_in">int</span>(&amp;g_b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; <span class="built_in">int</span>(&amp;a) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; <span class="built_in">int</span>(&amp;b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c: &quot;</span> &lt;&lt; <span class="built_in">int</span>(&amp;c) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;d: &quot;</span> &lt;&lt; <span class="built_in">int</span>(&amp;d) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;d_a: &quot;</span> &lt;&lt; <span class="built_in">int</span>(d_a) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;d_b: &quot;</span> &lt;&lt; <span class="built_in">int</span>(d_b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">g_a: <span class="number">742432</span></span><br><span class="line">g_b: <span class="number">742428</span></span><br><span class="line">a  : <span class="number">0x00CFFA48</span></span><br><span class="line">b  : <span class="number">0x00CFFA4C</span></span><br><span class="line">c  : <span class="number">741416</span></span><br><span class="line">d  : <span class="number">741412</span></span><br><span class="line">d_a: <span class="number">17029128</span></span><br><span class="line">d_b: <span class="number">17029144</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h3><ul>
<li><p>局部变量：编译器相关： <strong>按照内存地址递减的方式来给变量分配内存</strong>，只有当定义的作用域被调用时才会分配内存</p>
<ul>
<li>&#96;&#96;&#96;c++<br>&#x2F;&#x2F;测试<br>a  : 0x00CFFA48<br>b  : 0x00CFFA4C<br>&#x2F;&#x2F;vs : debug调试时会按照内存有大到小分配内存<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## 预处理器</span><br><span class="line"></span><br><span class="line">- 预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</span><br><span class="line"></span><br><span class="line">- 以（“#”）开头，只有空格字符能够出现在预处理指令前，不以`；`结尾</span><br><span class="line"></span><br><span class="line">- | 指令     | 作用                                            |      |</span><br><span class="line">  | -------- | ----------------------------------------------- | ---- |</span><br><span class="line">  | #include | 把头文件包含在源文件中                          |      |</span><br><span class="line">  | #define  | 用于创建符号常量                                |      |</span><br><span class="line">  | #ifdef   | 条件编译                                        |      |</span><br><span class="line">  | #endif   | 条件编译                                        |      |</span><br><span class="line">  | #        | replacement-text 令牌转换为用引号引起来的字符串 |      |</span><br><span class="line">  | ##       | 运算符用于连接两个令牌                          |      |</span><br><span class="line"></span><br><span class="line">### #define 预处理</span><br><span class="line"></span><br><span class="line">&gt; 属于文本插入替换，在编译之前完成替换</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#define macro-name replacement-text</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>在该文件中后续出现的所有宏都将会在<strong>程序编译之前</strong>被替换为 replacement-text</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> macro-name replacement-text /</span></span><br><span class="line">ss</span><br></pre></td></tr></table></figure>

<p>定义多行代码时，#define macro-name replacement-text</p>
<h3 id="参数宏"><a href="#参数宏" class="headerlink" title="参数宏"></a>参数宏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) a&lt;b ? a : b</span></span><br><span class="line">cout &lt;&lt;<span class="built_in">MIN</span>(<span class="number">1</span>,<span class="number">3</span>);  替换为 cout&lt;&lt; <span class="number">1</span>&lt;<span class="number">3</span>?<span class="number">1</span>:<span class="number">3</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) (a&lt;b ? a : b)</span></span><br><span class="line">cout &lt;&lt;<span class="built_in">MIN</span>(<span class="number">1</span>,<span class="number">3</span>);  替换为 cout&lt;&lt;( <span class="number">1</span>&lt;<span class="number">3</span>?<span class="number">1</span>:<span class="number">3</span> );</span><br></pre></td></tr></table></figure>

<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NULL</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">只在调试时编译</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Variable x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">   不进行编译的代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="#运算符"></a>#运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKSTR( x ) #x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MKSTR</span>(HELLO C++) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 替换为cout &lt;&lt; &quot;HELLO C++&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">结果：HELLO C++</span><br></pre></td></tr></table></figure>

<h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="##运算符"></a>##运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) a ## b</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> xy = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="built_in">concat</span>(x, y);</span><br><span class="line">    <span class="comment">//转换为cout&lt;&lt;xy;</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">结果 <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><table>
<thead>
<tr>
<th><strong>LINE</strong></th>
<th>这会在程序编译时包含当前行号。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FILE</strong></td>
<td>这会在程序编译时包含当前文件名。</td>
</tr>
<tr>
<td><strong>DATE</strong></td>
<td>这会包含一个形式为 month&#x2F;day&#x2F;year 的字符串，它表示把源文件转换为目标代码的日期。</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td>这会包含一个形式为 <code>hour:minute:second</code> 的字符串，它表示程序被编译的时间。</td>
</tr>
</tbody></table>
<h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a><strong><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language">Language</a></strong></h2><h3 id="Keywords-关键字"><a href="#Keywords-关键字" class="headerlink" title="Keywords 关键字"></a>Keywords 关键字</h3><h5 id="const-volatile-mutable"><a href="#const-volatile-mutable" class="headerlink" title="const volatile mutable"></a><code>const volatile mutable</code></h5><ul>
<li><p><code>const</code> : 修饰的变量或对象的值是不能被更新的</p>
<ul>
<li><p><code>顶层const</code>：表示指针本身是一个常量表示任意对象是常量，对任何数据类型都适用。对象本身是常量，指向不能改变，因此定义的时候必须进行初始化。</p>
</li>
<li><p><code>低层const</code>：表示指针所指向的对象是一个常量，对常量对象取址是一种底层CONST</p>
</li>
<li><p>指针类似既可以是<code>顶层const</code> 也可以是<code>低层const</code>:  </p>
</li>
<li><p>&#96;&#96;&#96;c++<br>int i &#x3D; 0;<br>int * const p1 &#x3D; &amp;i;   	&#x2F;&#x2F;顶层const常量指针，不能修改p1的值，能够通过p1修改i的值<br>const int ci &#x3D; 42;		&#x2F;&#x2F;顶层const常量,	<br>const int* p2 &#x3D; &amp;ci;   	&#x2F;&#x2F;底层const常量，指针整型常量的非常量指针、允许修改p2的值<br>int const * a &#x3D; &amp;b;		&#x2F;&#x2F;底层const常量,等价于const int*<br>const int* const p3;    &#x2F;&#x2F;第一个是底层const，第二个是顶层const<br>const int &amp;r &#x3D; ci;    	&#x2F;&#x2F;声明引用的都是底层consts<br>&#x2F;&#x2F;const 对象必须初始化<br>const int ival &#x3D; 1;<br>int *temp &#x3D; &amp;ival;     &#x2F;&#x2F;错误：普通指针不能指向常量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 指针和`const`</span><br><span class="line"></span><br><span class="line">    - **指针的类型必须与所指对象的类型一致**，例外：普通指针不能指向常量，指向常量的指针能指向非常量（但不能通过指针修改值）</span><br><span class="line">    - 常量指针（`const指针` `int * const p = &amp;temp`）：指向整型的常量指针： （不变的是*指针的值**指向*，而非*所指对象的值*）</span><br><span class="line"></span><br><span class="line">  - 常量指针： 指向常量的指针，常量便是指针指向的内容不可改变，</span><br><span class="line"></span><br><span class="line">  - 指针常量: 指针是个常量。///</span><br><span class="line"></span><br><span class="line">- 不考虑类的情况</span><br><span class="line"></span><br><span class="line">  - const常量在定义时必须初始化，之后无法更改</span><br><span class="line"></span><br><span class="line">  - const形参可以接收const和非const类型的实参，例如</span><br><span class="line"></span><br><span class="line">    ```C++</span><br><span class="line">    // i 可以是 int 型或者 const int 型</span><br><span class="line">    void fun(const int&amp; i)&#123;</span><br><span class="line">    	//...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>考虑类的情况</p>
<ul>
<li>const成员变量：不能在类定义外部初始化，只能通<strong>过构造函数初始化列表进行初始化</strong>，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</li>
<li>const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值</li>
</ul>
</li>
<li><ul>
<li><p>const 和 define 的区别</p>
<blockquote>
<ol>
<li>define 在编译之前的预处理阶段起作用，const 是在编译、运行时起作用</li>
<li>define 只做替换、不进行类型检查和计算； const 常量和数据类型，编译器可以对其进行类型检查。</li>
<li>宏定义的数据没有分配空间，只是进行插入替换、const定义的变量只是值不能改变，但是要为起分配内存空间。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="using"><a href="#using" class="headerlink" title="using"></a><code>using</code></h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ：：name;</span><br><span class="line"><span class="comment">//每个名字都要独立的using声明	</span></span><br><span class="line"><span class="keyword">using</span> std::cin; <span class="keyword">using</span> std:endl;</span><br><span class="line"><span class="comment">//头文件中不应该包含using 声明</span></span><br></pre></td></tr></table></figure>

<h5 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h5><ul>
<li>不考虑类<ul>
<li>所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用。<code>隐藏</code>。</li>
<li><code>默认初始化为0</code>，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区</li>
<li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</li>
<li>静态局部变量存放在内存的<strong>全局数据区</strong>。函数结束时，静态局部变量不会消失，每次该函数调用 时，也不会为其重新分配空间，只在其定义的作用域可见</li>
</ul>
</li>
<li>考虑类的情况<ul>
<li>static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。</li>
<li>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；<strong>不能被声明为const、虚函数和volatile</strong>；可以被非static成员函数任意访问</li>
</ul>
</li>
</ul>
<h3 id="Fundamental-types-基本类型"><a href="#Fundamental-types-基本类型" class="headerlink" title="Fundamental types 基本类型"></a>Fundamental types 基本类型</h3><table>
<thead>
<tr>
<th>void 空类型</th>
<th>不对应具体的值</th>
</tr>
</thead>
<tbody><tr>
<td>算数类型</td>
<td>整型和浮点型</td>
</tr>
</tbody></table>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/types">基本类型</a></h4><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>size</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>布尔类型</td>
<td>未定义</td>
</tr>
<tr>
<td>char</td>
<td>字符</td>
<td>8位</td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符</td>
<td>16位</td>
</tr>
<tr>
<td>char16_t</td>
<td><a href="#unicode">Unicode字符</a></td>
<td>16位</td>
</tr>
<tr>
<td>char32_t</td>
<td>Unicode字符</td>
<td>32位</td>
</tr>
<tr>
<td>short</td>
<td>短整型</td>
<td>16位</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>至少16位(32位系统)、32位（64位系统）</td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>至少32位(32位系统)、64位（64位系统）</td>
</tr>
<tr>
<td>long long</td>
<td>长整型</td>
<td>64位</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点型</td>
<td>6位有效数字32位</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>10位有效数字64位</td>
</tr>
<tr>
<td>long double</td>
<td>扩展精度浮点型</td>
<td>10位有效数字</td>
</tr>
<tr>
<td>size_t</td>
<td>机器相关的无符号类型</td>
<td>足够大</td>
</tr>
</tbody></table>
<ul>
<li><p>带符号<code>signed</code>和无符号<code>unsigned</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp;           <span class="comment">//-2,147,483,648 to 2,147,483,647</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> temp;  <span class="comment">//0 to 4,294,967,295</span></span><br><span class="line"><span class="comment">//char</span></span><br><span class="line"><span class="type">char</span> str;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> str;    <span class="comment">//char 与 signed char 并不一样</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str;  <span class="comment">//0 to 255</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>浮点型</p>
<ul>
<li><p>以符号位+ 有效数字+指数位的形式存</p>
<ul>
<li>有效数字：<code>1&lt;M&lt;2</code>: 保存时舍弃第一位默认为1，读取时在第一位的位置补上1</li>
<li>指数：<code>0~127</code>表示指数为负： <code>E = e + 127</code> e为真实指数值</li>
<li>表示的最小正数：0 0000 0000 000 0000 0000 0000 0000 0001</li>
</ul>
</li>
<li><table>
<thead>
<tr>
<th>float</th>
<th>88.8125 &#x3D; 101 1000.1101 &#x3D;&#x3D; 1.0110001101×2^6</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>符号位（1位）</td>
<td>指数域（8位）</td>
<td>小数域（23位）</td>
</tr>
<tr>
<td>0</td>
<td>E&#x3D;6+127&#x3D;133&#x3D;1000 0101</td>
<td>0110001101</td>
</tr>
<tr>
<td>double</td>
<td></td>
<td></td>
</tr>
<tr>
<td>符号位（1位）</td>
<td>指数域(11位）</td>
<td>小数域（52位）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码。<a name ="unicode"></a></p>
</blockquote>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><blockquote>
<p>有关联的两种类型之间可以相互转换</p>
</blockquote>
<h6 id="隐式转换：根据类型转换规则将运算对象类型统一后在计算，–尽可能减少精度损失"><a href="#隐式转换：根据类型转换规则将运算对象类型统一后在计算，–尽可能减少精度损失" class="headerlink" title="隐式转换：根据类型转换规则将运算对象类型统一后在计算，–尽可能减少精度损失"></a><em><strong>隐式转换</strong></em>：根据类型转换规则将运算对象类型统一后在计算，–尽可能减少精度损失</h6><ul>
<li><p>大多表达式中，比<code>int</code>小的整型值提升到较大的整型 – <a href="#%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87">整型提升</a></p>
</li>
<li><p>无符号类型的运算</p>
<ul>
<li>无符号类型不小于带符号：带符号类型转换为无符号 – <a href="">带符号的负数</a></li>
<li>无符号类型小于带符号： 取决于机器</li>
</ul>
</li>
<li><p>条件语句中，非布尔值转换为布尔值</p>
</li>
<li><p>初始化：初始值转为变量的值，赋值语句中，右侧对象转换为左侧对象的类型</p>
</li>
<li><p>算数运算</p>
</li>
<li><p>函数调用：<em><strong>实参和转换成形参的类型</strong></em></p>
</li>
<li><p>其他类型</p>
<ul>
<li><p>数组转换为指针：数组自动转换为指向数组首元素的指针 –<a href="#%E6%95%B0%E7%BB%84%E4%BE%8B%E5%A4%96">例外</a></p>
</li>
<li><p>函数名作为值使用时，自动转换为指针</p>
</li>
<li><p>指针的转换</p>
<ul>
<li>常量整数值 0 或者 <code>nullptr</code> 能够转换为任意指针类型</li>
<li>指向任意非常量的指针能够转换为<code>void*</code>  –<a href="#void*">void指针</a></li>
<li>指向任意对象的指针能够转换为<code>const void*</code></li>
</ul>
</li>
<li><p>转换成布尔类型：非零为真（算数类型、指针类型）</p>
</li>
<li><p>转换成<code>const</code>：能够将指向<code>T</code>的指针或者引用转换成指向<code>const T</code>的指针和引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T表示一种类型</span></span><br><span class="line">T i;</span><br><span class="line"><span class="type">const</span> T &amp;j = i;  <span class="comment">//非常量转换为const T的引用</span></span><br><span class="line"><span class="type">const</span> T *p = &amp;i; <span class="comment">// 非常量地址转换为const地址</span></span><br><span class="line"><span class="type">int</span> &amp;r = j; <span class="comment">//错误，不允许const转换成非常量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类定义的转换： <code>while(cin&gt;&gt; s)</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a name ="整型提升"></a></p>
<p>整型提升在表达式计算时，各种整型首先要提升为<code>int</code>类型，如果<code>int</code>类型不足以表示的话，就需要提升为<code>unsigned int</code>类型，然后再执行表达式的运算，较大的宽字符等类型，提升成能够容纳原类型值的最小的类型</p>
<p><a name ="数组例外"></a></p>
<p>数组作为取址符（&amp;）、<a href="">sizeof</a> 以及<a href="">tydeid</a>的运算对象、关键字<a href="">decltype</a>的参数、或引用初始化数组</p>
</blockquote>
<h6 id="显示转换：强制类型转换cast"><a href="#显示转换：强制类型转换cast" class="headerlink" title="显示转换：强制类型转换cast"></a><em><strong>显示转换</strong></em>：强制类型转换cast</h6><ul>
<li><p>C风格： <code>(type_name) expression type(expression)</code></p>
</li>
<li><p>C++：<code>cast-name&lt;type&gt;(expression)</code> |<code>cast-name</code>:<code>static_cast dynamic_cast const_cast reinterpret_cast</code></p>
<ul>
<li><p><code>static_cast</code>: 任何具有明确定于的类型转换都能使用，不包括<code>底层const</code>，不警告潜在的精度丢失</p>
</li>
<li><p><code>dynamic_cast</code></p>
</li>
<li><p><code>const_cast</code> :  用于改变运算对象的<code>底层const</code></p>
<ul>
<li>&#96;&#96;&#96;c++<br>const char *pc;					&#x2F;&#x2F;底层const<br>char *p &#x3D; const_cast&lt;char*&gt;(pc);&#x2F;&#x2F;正确<br>const_cast<string>(pc)			&#x2F;&#x2F;错误 只能改变常量属性 “去掉const性质”<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - `reinterpret_cast` : 本质上依赖机器、运算符并不会改变括号中运算对象的值，而是对该对象从位模式上进行重新解释</span><br><span class="line"></span><br><span class="line">###### ***字面值常量***</span><br><span class="line"></span><br><span class="line">六种常量：***字符串常量，整型常量，浮点型常量，字符常量，布尔常量，空常量***</span><br><span class="line"></span><br><span class="line">字面值常量的形式和值决定了 它的数据类型</span><br><span class="line"></span><br><span class="line">- 整型字面值</span><br><span class="line"></span><br><span class="line">  - `short`类型没有相应的字面值</span><br><span class="line"></span><br><span class="line">  | 进制                     | 值   | 符号     | 类型                                     |</span><br><span class="line">  | ------------------------ | ---- | -------- | ---------------------------------------- |</span><br><span class="line">  | 十进制                   | 20   | 带符号数 | `int long longlong`中最小的              |</span><br><span class="line">  | ***八进制，以0开头***    | 024  | 不确定   | `int long longlong uint ulong ulonglong` |</span><br><span class="line">  | ***十六进制，以0x开头*** | 0x16 | 不确定   | `int long longlong uint ulong ulonglong` |</span><br><span class="line"></span><br><span class="line">- 浮点型字面值：`3.14 3.14E0 0. 0e0 .001 `默认为`double`类型，`7.8f`为`float`类型</span><br><span class="line"></span><br><span class="line">- 布尔：true 、false； 指针： nullptr；</span><br><span class="line"></span><br><span class="line">- 字符和字符串字面值：两个字符串位置紧邻且仅由空格缩进换行符分隔，实际上他们是一个整体。</span><br><span class="line"></span><br><span class="line">- 转义序列</span><br><span class="line"></span><br><span class="line">| 转义序列 | 含义                                          | 指定字面值    | 类型                    |</span><br><span class="line">| -------- | --------------------------------------------- | ------------- | ----------------------- |</span><br><span class="line">| `\\`     | \字符                                         | 前缀 u’C‘     | `char16_t`              |</span><br><span class="line">| `\&#x27;`     | &#x27;字符                                         | 前缀 U’c‘     | `char32_t`              |</span><br><span class="line">| `\&quot;`     | &quot;字符                                         | 前缀 L&#x27;C&#x27;     | `wchar_t`               |</span><br><span class="line">| \?       | ？字符                                        | 前缀 u8       | **字符串**字面常量 char |</span><br><span class="line">| \a       | 警报铃声                                      | 后缀          |                         |</span><br><span class="line">| \b       | 退格键                                        | u or U        | unsigned                |</span><br><span class="line">| \f       | 换页符                                        | l or L        | long                    |</span><br><span class="line">| \n       | 换行符                                        | ll or LL      | long long               |</span><br><span class="line">| \r       | 回车                                          | f or F        | float                   |</span><br><span class="line">| \t       | 水平制表符                                    | l or L 浮点型 | long double             |</span><br><span class="line">| \v       | 垂直制表符                                    |               |                         |</span><br><span class="line">| \xxx     | 一到三位的八进制数 数字部分表示字符对应的数字 |               |                         |</span><br><span class="line">| \xhh     | 一到多位的十六进制数                          |               |                         |</span><br><span class="line">| \\       |                                               |               |                         |</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">char` `s[]=``&quot;\\123456\123456\t&quot;``;</span><br><span class="line">printf(``&quot;%d\n&quot;``,strlen(s));  //结果为12</span><br><span class="line">\\ 1 2 3 4 5 6 \123 4 5 6 \t</span><br><span class="line">    </span><br><span class="line"> char a = &#x27;\72&#x27;;  // 八进制</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>提供一个有名字的，能够供程序操作的存储空间 – 对象</p>
<ul>
<li><p>变量的初始化：对象在创建时获得了一个特定的值。初始化不是赋值。</p>
<ul>
<li><p>列表初始化:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="type">int</span> temp =&#123;<span class="number">0</span>&#125;; <span class="comment">//列表初始化</span></span><br><span class="line"><span class="type">int</span> temp &#123;<span class="number">0</span>&#125;;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">temp</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> temp = &#123;ld&#125;;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认初始化：<a name = "默认初始化"></a></p>
<ul>
<li>内置类型：定义在任何<strong>函数体外</strong>被初始化为<strong>0</strong>， 定义在函数体（块）内将<strong>不被初始化</strong>-产生未定义 的值<ul>
<li>全局变量的初始化 与 main的动作无关</li>
</ul>
</li>
<li>初始化部分的<em><strong>全局数组与局部数组</strong></em>，初始化部分为初始化值，<em>未初始化部分都为0</em></li>
<li>类的对象如果没有初始化，值由类确定</li>
</ul>
</li>
</ul>
</li>
<li><p>变量是声明和定义：变量能且只能被定义一次，可以被多次声明。 – 多文件中使用同一个变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> temp; <span class="comment">//声明temp而没有定义temp</span></span><br><span class="line"><span class="type">int</span> temp; <span class="comment">//声明且定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> temp = <span class="number">0</span>;  <span class="comment">//定义temp： 任何包含显示初始化的声明即为定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> temp = <span class="number">0</span>;   <span class="comment">//在函数体内尝试初始化由extern标记的变量：错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><h6 id="引用："><a href="#引用：" class="headerlink" title="引用："></a><em><strong>引用</strong></em>：</h6><p>为了另一个已经存在的对象起的另外一个名字，引用必须初始化。</p>
<ul>
<li><p>引用即别名：对引用的操作都是在与子绑定的对象上进行，不能定义引用的引用</p>
</li>
<li><p>引用的定义初始化: - 不允许随意改变引用所绑定的对象- 必须初始化</p>
<ul>
<li>引用的类型必须与所引用对象的类型一样 -<a href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BE%8B%E5%A4%96">例外</a></li>
<li>初始化值是<a href="#leftvalue">左值</a>-</li>
<li>初始化值不是左值：只能对<code>const T&amp;</code>（常量引用）赋值  \ 临时对象只能对<code>const T&amp;</code>（常量引用）赋值</li>
<li>引用不是对象，没有实际地址 -不能用来初始化指针， 不存在引用的数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; cdr = <span class="number">1</span>; <span class="comment">// okint i=100, i2 = 22;</span></span><br><span class="line"><span class="type">int</span> &amp;r =i, j = i2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;temp =<span class="number">10</span>; <span class="comment">//错误，引用的初始值必须为对象</span></span><br><span class="line"><span class="type">double</span> d2 = <span class="number">1.</span>;</span><br><span class="line"><span class="type">int</span> &amp;temp = d2; <span class="comment">//错误,引用的类型必须于引用的对象严格匹配</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span>&amp; dr = <span class="number">1</span>; <span class="comment">// 错误：需要左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; cdr = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="function">T1 <span class="title">func</span><span class="params">(T2&amp; temp)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function">T2 <span class="title">fun2</span><span class="params">()</span></span>;  		<span class="comment">//函数声明</span></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">func2</span>());  	<span class="comment">//错误， 函数返回值为临时对象，不能用来初始化非常量引用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>例外<a name ="引用类型例外"></a></p>
<p>1.允许使用任意表达式初始化常量引用、只要表达式的结果能够转换为引用的类型  –非常量的对象、字面值、一般表达式</p>
</blockquote>
<h6 id="指针："><a href="#指针：" class="headerlink" title="指针："></a><em><strong>指针</strong></em>：</h6><p>本身就是一个对象，允许对指针赋值和拷贝，无须在定义时初始化，</p>
<pre><code>        在*块作用域*&#123;&#125;中定义未初始化将拥有不确定的值
</code></pre>
<ul>
<li>定义 <code>int *p, *d；</code> <code>int *d = &amp; val</code>  - &amp;取值符</li>
<li>指针的值： 指向一个对象、指向紧邻对象所占空间的下一个位置、空指针、无效指针</li>
<li>解引用符： <code>*d</code>，适用于确实指向对象的指针·</li>
<li>建议初始化所有的指针：<ul>
<li>cout一个char型指针会打印其中内容，而cout一个int型指针会打印其地址</li>
<li>cout一个char型指针会打印其中内容，而cout一个int型指针会打印其地址</li>
</ul>
</li>
</ul>
<blockquote>
<p>取值符与解引用符：<a name ="曲解"></a></p>
<p>类型修饰符从右向左依次绑定：  int *p；int *&amp;r &#x3D; p；  指针的引用</p>
<p>取地址符（&amp;）返回的是int *类型，如int *p &#x3D; &amp;a</p>
<p>解引用符（*）返回的是int &amp;类型,  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> * p1 = <span class="number">0</span>;  <span class="comment">//空指针</span></span><br><span class="line"><span class="type">int</span> * p2 = &amp; ival;</span><br><span class="line"><span class="keyword">if</span>(p1)  <span class="comment">//条件的值为false, 非空为真</span></span><br><span class="line"><span class="keyword">if</span>(p2)	<span class="comment">//条件的值为true </span></span><br><span class="line"> p1 == p2;  <span class="comment">//false 两指针存放的地址值相等：1.都为空、2.指向同一个对象、3.指向同一对象的下一地址</span></span><br><span class="line">p1 != p2;   <span class="comment">//true;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><em>void</em> 指针</strong>*<a name = "void*"></a></p>
<p>特殊的指针类型，能够存放任意对象的地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> obj = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">void</span> * p = obj;</span><br><span class="line"></span><br><span class="line">*p =<span class="number">9.87</span>;  <span class="comment">//错误：不能直接操作void*指针所指的对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> * dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);  <span class="comment">//显示类型转换找回指针类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1，p2; <span class="comment">//p1是指向int的指针、p2是int类型</span></span><br><span class="line"><span class="type">int</span> **p3 = &amp;p1;  <span class="comment">//p3是指向指针（p1）的指针</span></span><br><span class="line"><span class="type">int</span> *&amp;r = p1;   <span class="comment">//r是指向指针（p1）的应用</span></span><br></pre></td></tr></table></figure>

<h6 id="常量表达式-C-11"><a href="#常量表达式-C-11" class="headerlink" title="常量表达式 -C++11"></a>常量表达式 -C++11</h6><ul>
<li><p>指值不会改变且在编译过程就能得到计算结果的表达式  -普通函数初始化的变量不属于常量表达式</p>
</li>
<li><p><code>constexpr</code>变量：变量是一个常量表达式，就声明成 <code>constexpr int size = 100;</code>   -能够用特殊的<code>constexpr函数</code>初始化<code>constexpr</code>变量</p>
</li>
<li><p>指针和<code>constexpr</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;     <span class="comment">//底层const： 指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">//置为顶层const： 指向整型的常量指针</span></span><br><span class="line"><span class="comment">//同const指针一样，constexper指针即可以指向常量也可以指向非常量 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *np = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// i和j必须定义在函数体外面</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *p = &amp;i;  <span class="comment">//p是常量指针，指向整型常量i</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> * pi = &amp;j;     <span class="comment">//pi是常量指针，指向整型j</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h6 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h6><ul>
<li><p>不允许拷贝数组</p>
</li>
<li><p>数组名字时指向数组首元素的指针</p>
</li>
<li><p>数组名作为函数形参时，沦为<strong>普通指针</strong>，能够自增自减</p>
<ul>
<li>在数组名做为函数参数和用于<strong>表达式</strong>中的时候,数组名就退化成了指针</li>
</ul>
</li>
<li><p>&#96;&#96;&#96;c++<br>int func(int * str) {<br>return *str++;<br>}<br>&#x2F;&#x2F;main<br>int num[10] &#x3D; {};<br>func(num);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">###### 复杂的数组声明</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  int *p[10];   //p 是数组，包含10个(int *)指向整型的指针</span><br><span class="line">  int (*ptr)[10];   //ptr 是指针， 指向数组</span><br><span class="line">  int &amp;r[10];   // 数组， 不存在引用的数组</span><br><span class="line">  int (&amp;rtr)[10]; // 引用， 数组的引用</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h4><h6 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h6><ul>
<li><p>某种类型的别名，定义方法 - 关键字typedef，新方法 别名声明</p>
<ul>
<li><code>typedef double wages;  // wages 是double 的别名</code></li>
<li><code>using int32_t = int;  //int32_t是int的别名</code></li>
</ul>
</li>
<li><p>指针、常量和类型别名</p>
<ul>
<li>&#96;&#96;&#96;c++<br>typeded char* pstring;<br>const pstring cstr &#x3D; 0;  &#x2F;&#x2F;指向char 的常量指针，而非指向常量char的普通指针<br>const pstring *ps;		 &#x2F;&#x2F;指针，指向指向char的常量指针<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###### auto 类型说明符(C++11)</span><br><span class="line"></span><br><span class="line">- 让编译器通过初始值来推断变量的类型</span><br><span class="line"></span><br><span class="line">- 一般会忽略掉顶层const（auto 引用时，初始值中顶层const属性会保留），保留底层const ，</span><br><span class="line"></span><br><span class="line">- 如果希望推断出来的类型为顶层const ，需明确指出</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  auto i = 0, *p = &amp;i;   //正确：i是整数、p是整型指针</span><br><span class="line">  auto sz = 0, pi = 3.14; //错误，sz 和pi类型不一样</span><br><span class="line">  </span><br><span class="line">  const int ci = i， &amp;cr = ci;</span><br><span class="line">  auto b = ci;  	// ci的const 被忽略了</span><br><span class="line">  auto c = cr;  	// c是整数</span><br><span class="line">  auto d = &amp;i; 	//整型指针</span><br><span class="line">  auto e = &amp;ci;   //指向常量整数的指针（对常量对象取址是一种底层const）</span><br><span class="line">  const auto f = ci; // f类型为 const int</span><br><span class="line">  auto &amp;g = ci;    //整型常量引用</span><br><span class="line">  auto &amp;h = 42;    //错误</span><br><span class="line">  const auto &amp;j = 42; </span><br><span class="line">  </span><br><span class="line">  auto &amp;n = i, *p = &amp;ci;   //错误，i类型为int，ci类型为const int，初始值必须是统一类型</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h6 id="decltype-类型指示符（C-11）"><a href="#decltype-类型指示符（C-11）" class="headerlink" title="decltype 类型指示符（C++11）"></a>decltype 类型指示符（C++11）</h6><ul>
<li><p>选择并返回操作数的类型-<a href="#%E6%9B%B2%E8%A7%A3">取值符与解引用符</a></p>
</li>
<li><blockquote>
<p>decltype((variable)) 的结果永远是引用（双括号）</p>
</blockquote>
<ul>
<li>&#96;&#96;&#96;C++<br>const int ci &#x3D; 0, &amp;cj &#x3D; ci; &#x2F;&#x2F;cj： const in&amp;<br>decltype(ci) x &#x3D; 0;        	&#x2F;&#x2F;const int<br>decltype((ci)) x2 &#x3D; x;    	&#x2F;&#x2F;const int&amp;, 必须初始化<br>decltype(cj) y &#x3D; x;    		&#x2F;&#x2F;const int&amp;, 必须初始化<br>&#x2F;&#x2F;表达式<br>int i &#x3D; 43, *p &#x3D; &amp;i, &amp;r &#x3D; i;<br>decltype(r+0) b;   &#x2F;&#x2F;正确，加法的结果是int，获得引用的类型<br>decltype(<em>p) c;   &#x2F;&#x2F;错误，c是int&amp;   – 解引用符</em> 返回的是 int &amp;; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### typedef</span><br><span class="line"></span><br><span class="line">&gt; 主要用于定义类型别名.，是编译的一部分，会进行数据类型检查</span><br><span class="line">&gt;</span><br><span class="line">&gt; // typedef char* p_char**;**</span><br><span class="line"></span><br><span class="line">### Expression 表达式</span><br><span class="line"></span><br><span class="line">#### 基础</span><br><span class="line"></span><br><span class="line">###### 运算对象的类型转换-[这里](#整型提升)</span><br><span class="line"></span><br><span class="line">###### 左值和右值&lt;a name =&quot;leftvalue&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">归纳：当一个对象被用作右值时，用的是对象的值（内容），而用作左值时，用的时对象的内存地址</span><br><span class="line"></span><br><span class="line">- 在***需要右值的地方可以用左值代替***，不能把右值当作左值使用  --例外：右值引用</span><br><span class="line">  - 赋值运算符、内置解引用、下标运算符，迭代器解引用、string、vector的下标运算符的</span><br><span class="line">  - 取址运算符作用于左值对象，返回指向该对象的指针，这个指针是一个右值</span><br><span class="line">  - 关键字decltype：表达式是左值时，得到引用类型；`decltype(&amp;p)`类型为指向p的类型的指针</span><br><span class="line"></span><br><span class="line">###### 求值顺序</span><br><span class="line"></span><br><span class="line">四种运算符（`&amp;&amp;; ||; ?:; ,;` ）明确规定了求值对象的运算顺序</span><br><span class="line"></span><br><span class="line">- 逻辑与`&amp;&amp;`：当且仅当左侧运算对象为真才继续求右侧对象的值 短路求值</span><br><span class="line">- 逻辑或`||`：当且仅当左侧运算对象为假才继续求右侧对象的值 短路求值</span><br><span class="line">- 条件运算符`?:`: 先对条件进行求值，然后根据条件真假求值</span><br><span class="line">- 逗号`,`: 按左到右的顺序进行求值，运算结果时右侧表达式的运算结果</span><br><span class="line"></span><br><span class="line">没有指定运算顺序的运算符：</span><br><span class="line"></span><br><span class="line">- 如果表达式的不同的子表达式指向并修改了同一个对象，将引发错误并产生未定义的行为</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">int i=0;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;++i&lt;&lt;endl; //未定义</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="赋值运算符满足右结合律"><a href="#赋值运算符满足右结合律" class="headerlink" title="赋值运算符满足右结合律"></a>赋值运算符满足右结合律</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = jval = <span class="number">2</span>; <span class="comment">// jval = 2 返回其左侧的运算对象（左值），作为ival = jval的右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">5</span>,b=<span class="number">0</span>,c=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (a=b+c) <span class="built_in">printf</span> (<span class="string">&quot;***\n&quot;</span>);  <span class="comment">// a=b+c 表达式返回 0， 为假。</span></span><br><span class="line"><span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;$$$\n&quot;</span>); 			<span class="comment">// 输出$$$</span></span><br></pre></td></tr></table></figure>

<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><ul>
<li>运算对象和求值结果都是<em><strong>右值</strong></em></li>
<li>运算结果 的类型</li>
<li><strong>% 取余运算符的运算对象必须是整数类型</strong></li>
</ul>
<h4 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h4><ul>
<li>作用与<em><strong>左值运算对象</strong></em><ul>
<li>前置版本<code>++i</code>：返回递增之后的值，将对象本身作为左值返回 - 运算结果是左值</li>
</ul>
</li>
<li>后置版本<code>i++</code>:返回递增之前的值，将对象原始值的副本作为右值返回 - 运算结果是右值<ul>
<li>后置版本的优先级高于解引用运算符： <code>*p++</code> 等价于 <code>*(p++)</code></li>
</ul>
</li>
</ul>
<h4 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h4><p><code>ptr-&gt;mem</code> 等价于 <code>(*p).mem</code> , 解引用的优先级低于点运算符， <code>*p.size() // 错误</code></p>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><p>当条件运算符的两个表达式 都是左值或者能够转换成同一类型左值时，运算结果时左值，或者都是右值</p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><ul>
<li>一般来说，运算对象是”小数型“时，它的值会被提升至较大的整数型</li>
<li>左移(&lt;&lt;)作用于带符号类型时，可能会改变符号位的值，是一种未定义的行为</li>
</ul>
<h4 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h4><blockquote>
<p>区别于strlen():</p>
<pre><code>1. strlen()是字符处理的库函数，sizeof是运算符
1. sizeof 的参数可以是任何数据、数据类型； strlen的参数只能是字符指针且结尾为 ‘\0’
1. sizeof的值在编译的时候确定，不能得到动态分配的空间大小。
</code></pre>
</blockquote>
<p>返回一条表达式或者一个类名字所占的字节数，所得的值是一个<code>size_t</code>类型的常量表达式</p>
<ul>
<li><code>sizeof(type)</code></li>
<li><code>sizeof expr</code> ：返回表达式结果类型的大小，不实际计算其运算对象的值<ul>
<li>即在<code>sizeof</code>的运算对象中解引用一个无效指仍然是安全的行为</li>
<li>引用，<code>sizeof</code>得到被引用对象所占空间的大小</li>
<li>指针，<code>sizeof</code>得到指针本身所占空间的大小</li>
<li>解引用指针，<code>sizeof</code>得到指针所指对象所占空间的大小，<em><strong>指针不需有效</strong></em></li>
<li>数组，<code>sizeof</code>得到整个数组所占空间的大小</li>
<li>string、vector：<code>sizeof</code>得到该类型固定部分的大小，不会计算对象中的运算占用的空间</li>
</ul>
</li>
</ul>
<h5 id="枚举类型、联合体、结构体"><a href="#枚举类型、联合体、结构体" class="headerlink" title="枚举类型、联合体、结构体"></a>枚举类型、联合体、结构体</h5><ul>
<li><p><code>enum</code>：enum只是定义了一个常量集合，里面没有“元素”，而枚举类型是当做int来存储的，所以枚举类型的sizeof值都为<code>sizeof(int)</code></p>
</li>
<li><p><code>union</code>:公用体中的成员公用同一段内存，整个联合体的sizeof是所有成员中占用内存最大的成员的sizeof,考虑内存对齐，整体空间长度要是公用体中<em><strong>长度最大的数据类型</strong></em>的整数倍</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">union</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="number">2</span> <span class="type">char</span> a[<span class="number">9</span>];</span><br><span class="line"><span class="number">3</span> <span class="type">int</span> b[<span class="number">2</span>];</span><br><span class="line"><span class="number">4</span> &#125;s; </span><br><span class="line"><span class="comment">//sizeof(a) = 9*1=9; size(b) = 2*4 =8; 长度最大的数据类型sizeof(int) = 4;</span></span><br><span class="line"><span class="comment">//大于9 且是4的整数倍数的是12</span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="type">void</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">6 </span>&#123;</span><br><span class="line"><span class="number">7</span>  cout&lt;&lt;<span class="built_in">sizeof</span>(s); <span class="comment">//值为12</span></span><br><span class="line"><span class="number">8</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>struct</code>:</p>
<ul>
<li><p>空结构体的长度为1，之所以不是0，因为如果空结构体不占内存，则该结构的的变量将无法存取，且两个不同的空结构体无法区分。</p>
</li>
<li><p>非空结构体：</p>
<p>**1.**整体空间是结构体中 <strong>占用空间*<u>最大的类型</u>*所占字节数的整数倍</strong> 。</p>
<ul>
<li>特殊：在*<u>32位Linux+gcc环境下，若最大的类型所占字节数超过4，如double是8，则整体空间大小是4的整数倍即可</u>*</li>
</ul>
<p>**2.*<em>数据对齐原则-内存按结构体成员的先后顺序排列，当排到该成员变量时，其前面</em><u><strong>所有成员已经占用的空间大小</strong></u>*必须是该成员类型大小的整数倍，如果不够，则前面的成员占用的空间要补齐，使之成为当前成员类型的整数倍。</p>
<p>​	<em><u>特殊：在Linux+gcc环境下，若当前成员类型字节数超过4，则前面所有成员已经占用的空间大小是4的整数倍即可，不够则补齐</u></em></p>
</li>
<li><p>结构体成员中存在其他结构体类型成员：</p>
<ul>
<li><p>1.整体空间是<em><strong>子结构体与父结构体中占用空间最大的类型所占字节数的整数倍</strong></em>。特殊：在32位Linux+gcc环境下，若最大的类型所占字节数超过4，如double是8，则整体空间大小是4的整数倍即可</p>
<p>2.数据对齐原则-内存按结构体成员的先后顺序排列，当排到子结构体成员时，其前面所有成员已经占用的空间大小必须是该<em><strong>子结构体成员中占用空间最大的类型大小的整数倍</strong></em>，如果不够，则前面的成员占用的空间要补齐，使之成为该类型大小的整数倍。特殊：在Linux+gcc环境下，若当前成员类型字节数超过4，则前面所有成员已经占用的孔家大小是4的整数倍即可，不够则补齐</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>类class</code></p>
<ul>
<li><p>在类中，如果什么都没有，则类占用1个字节，一旦类中有其他的占用空间成员，则这1个字节就不在计算之内，</p>
<ul>
<li>如一个类只有一个int则占用4字节而不是5字节。</li>
</ul>
</li>
<li><p>如果只有成员函数，则还是只占用1个字节，因为类函数不占用空间  - </p>
<ul>
<li>调用成员函数只需知道函数的地址，而函数的地址只与类型相关、与类型的实例无关。</li>
</ul>
</li>
<li><p>虚函数因为存在一个虚函数表，需要4个字节(32位机器)，数据成员对象如果为指针则为4字节，注意有字节对齐，如果为13字节，则进位到16字节空间。</p>
</li>
<li><p>static的成员变量属于类域，不算入对象 +0</p>
</li>
</ul>
</li>
</ul>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><ul>
<li><p>含有两个运算对象，从左向右的顺序依次求值</p>
</li>
<li><p>首先对左侧表达式求值， 然后将求值结果丢弃，真正的结果是右侧表达式的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = (<span class="number">9</span> + <span class="number">1</span>, <span class="number">4</span> + <span class="number">8</span>);</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;   <span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">b = (a = <span class="number">3</span> * <span class="number">5</span>, a * <span class="number">4</span>, a * <span class="number">5</span>);</span><br><span class="line"><span class="comment">//求值顺序： a = 15；-&gt; 60; -&gt; 75;  b = 右侧表达式</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c = (a = <span class="number">2</span>,b = <span class="number">3</span>,b++, a+b); <span class="comment">//=6</span></span><br><span class="line"><span class="comment">//求值顺序： a = 2, b = 3, b++(b = 4), a + b = 6</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p><img src="http://picgo.wangeyi.ink/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="C++运算符优先级"></p>
<h3 id="Statement语句"><a href="#Statement语句" class="headerlink" title="Statement语句"></a>Statement语句</h3><h4 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h4><ul>
<li><p>空语句： <code>;</code>  语法上需要一条语句，但是逻辑上不需要，就应该使用空语句</p>
</li>
<li><p>复合语句（块）：<em>用花括号括起来的语句和声明序列</em>，不以分号作为结束， 一个块就是一个作用域, 空块<code>&#123;&#125;</code>和等价于空语句</p>
</li>
<li><p>语句作用域：可以在<code>if、switch、while、for </code>的控制结构内定义变量，这些变量只能在相应语句的内部可见。</p>
<p>- </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="type">int</span> i  = <span class="built_in">get_num</span>())</span><br><span class="line">	cout&lt;&lt;i&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><ul>
<li><p><code>if 、 if else 、 switch</code></p>
</li>
<li><p>悬垂else： 规定<code>else</code> 与离它最近的尚未匹配的<code>if</code> 匹配， <em>可以利用花括号控制执行路径</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(grade % <span class="number">10</span> &gt;= <span class="number">3</span>)  <span class="comment">//if1</span></span><br><span class="line">	<span class="keyword">if</span>(grade % <span class="number">10</span> &gt; <span class="number">7</span>) <span class="comment">//if2</span></span><br><span class="line">		letter += <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//与if2匹配</span></span><br><span class="line">	letter += <span class="string">&#x27;-&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch 语句</p>
<ul>
<li>case标签：必须是整型常量表达式： <code>int char enum bool类型</code></li>
<li>switch的内部控制流：<ul>
<li>如果某个标签匹配成功，<em><strong>将从该标签开始往后顺序执行所有case分支</strong></em></li>
<li>在 每个case标签加上 <code>break;</code> 语句， 以显示第告诉编译器终止执行过程</li>
</ul>
</li>
<li>default 标签：如果没有任何一个case标签能够匹配上，<em><strong>程序将执行default后面的语句</strong></em></li>
</ul>
</li>
</ul>
<h4 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h4><ul>
<li><p><code>while、for 、 do while</code></p>
<ul>
<li><p>for语句中的多重定义： 初始化语句可以定义多个对象，但是只能有一条声明语句  </p>
</li>
<li><p>for 语句头能够省略掉初始化语句，条件语句，表达式中的任何一个或者全部</p>
</li>
<li><p>范围for： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Range for</span></span><br><span class="line"><span class="comment">expression: 对象用于表示一个序列</span></span><br><span class="line"><span class="comment">declaration： 定义变量用于访问序列中的基础元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(declaration : expression)</span><br><span class="line">    	statement</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Function-函数"><a href="#Function-函数" class="headerlink" title="Function 函数"></a>Function 函数</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li>函数包含：返回类型，函数名字、0个或多个形参组成的列表以及函数体</li>
<li>通过调用运算符 <code>()</code>来调用函数，它作用于一个表达式（函数或者指向函数的指针）；圆括号内是用逗号隔开的实参列表，用实参来初始化形参。</li>
<li>局部对象：形参和在函数体内定义的变量 <ul>
<li>自动对象：普通局部对象，在定义语句创建该对象，在到达定义所在快的末尾销毁。<ul>
<li>如果变量定义本身不含有初始值，<em><strong>执行默认初始化</strong></em>： 对于内置类型的局部对象产生未定义的值</li>
</ul>
</li>
<li>局部静态对象：在程序的执行路径第一次经过定义语句时初始化，直到程序终止才被销毁。<ul>
<li>如果局部静态对象没有显示的初始化值，<em><strong>执行值初始化</strong></em>： 内置类型的局部静态对象初始化为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p><em>每次调用函数时会重新创建形参，并用传入的实参对形参进行初始化</em></p>
<h6 id="占位参数："><a href="#占位参数：" class="headerlink" title="占位参数："></a>占位参数：</h6><p>只有函数参数类型的声明，没参数的声明 -<strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="引用传递："><a href="#引用传递：" class="headerlink" title="引用传递："></a>引用传递：</h6><ul>
<li><p><em><strong>形参类型是引用类型</strong></em>，引用形参是它对应实参的别名</p>
</li>
<li><p>通过使用引用形参，函数可以修改实参的值</p>
</li>
</ul>
<h6 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h6><ul>
<li><p><em><strong>实参的值拷贝给形参</strong></em>，形参和实参是两个相互独立的对象</p>
</li>
<li><p>函数对形参的所有操作不会影响传入的实参</p>
</li>
<li><p>指针形参：拷贝的是指针的值，形参和实参同时指向同一个对象，通过形参可以修改指向对象的值</p>
</li>
</ul>
<h6 id="const-形参和实参"><a href="#const-形参和实参" class="headerlink" title="const 形参和实参"></a>const 形参和实参</h6><ul>
<li><p>用实参初始化形参时会忽略掉顶层const</p>
<ul>
<li>&#96;&#96;&#96;c++<br>&#x2F;&#x2F; 可以传入const int 也可以传入 int<br>void func(const int i) {&#x2F;<em>只读 i</em>&#x2F;}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###### 数组形参</span><br><span class="line"></span><br><span class="line">*数组的两个性质： 不允许拷贝数组、使用数组时通常会将其转换为指针*</span><br><span class="line"></span><br><span class="line">- 传递一个数组时，实际上是传递指向数组首元素的指针</span><br><span class="line"></span><br><span class="line">   ```c++</span><br><span class="line">    void print(const int *);</span><br><span class="line">    void print(const int[]);</span><br><span class="line">    void print(const int[10]); // 三种都是等价的， const int *； 10期望数组的大小，实际并不一定</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组形参和const ：对数组进行只读操作时，形参应该是指向const的指针</p>
</li>
<li><p>数组引用形参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="type">int</span> &amp;arr[<span class="number">10</span>]) <span class="comment">//错误： 将arr 声明成包含10个引用对象的数组</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">int</span> (&amp;arr)[<span class="number">10</span>]) <span class="comment">//正确：10个整型的数组的引用   -- 只能传递大小为10的数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="返回类型和return"><a href="#返回类型和return" class="headerlink" title="返回类型和return"></a>返回类型和return</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>;  <span class="comment">//只能用在返回类型为void的函数</span></span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>

<h5 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h5><ul>
<li>return语句</li>
<li>return expression；expression 必须是另一个返回void 的函数，强行令void 函数返回其他类型会编译错误</li>
</ul>
<h5 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h5><ul>
<li><p>返回类型必须与函数返回类型相同，或者能隐式地转换成。</p>
<ul>
<li>返回值：返回的是临时对象，</li>
<li>返回引用：不要返回局部对象的引用或指针： 局部对象在函数完成后被销毁，空间被释放</li>
</ul>
</li>
<li><p>引用返回左值：<em><strong>调用一个返回引用的函数得到左值</strong></em>，其他返回类型返回右值</p>
</li>
<li><p>列表初始化返回值：<code>return &#123;&#125;; 返回空列表， return &#123;1，2&#125;；</code></p>
</li>
<li><p>返回数组指针：</p>
<ul>
<li><p>数组不能拷贝，函数不能返回数组</p>
</li>
<li><p>声明：</p>
</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">typdef <span class="type">int</span> arrT[<span class="number">10</span>];  <span class="comment">// arrT是类型别名，表示的类型为数组</span></span><br><span class="line"><span class="function">arrT * <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;   <span class="comment">//返回指向数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Type</span> (*<span class="built_in">func</span>(parameter_list))[dimension];</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span>-&gt;<span class="title">int</span> <span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure>

<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>重载函数：函数名字相同但是形参列表不同， - main()函数不能重载</p>
<p>不允许两个函数处了返回值外其他所有的要素都相同</p>
<ul>
<li><em>函数的返回值不可以作为函数重载的条件</em></li>
</ul>
<h6 id="重载和const"><a href="#重载和const" class="headerlink" title="重载和const"></a>重载和const</h6><p>一个拥有顶层const形参的函数无法和另一个没有const的形参区分开来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> <span class="type">int</span>)</span></span>; <span class="comment">//重复定义了lookup</span></span><br><span class="line"><span class="comment">//底层const能够重载函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;)</span></span>; <span class="comment">//新函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span>*)</span></span>;		<span class="comment">//新函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;	<span class="comment">//新函数</span></span><br></pre></td></tr></table></figure>

<h6 id="const-cast-和函数重载"><a href="#const-cast-和函数重载" class="headerlink" title="const_cast 和函数重载"></a>const_cast 和函数重载</h6><h6 id="调用重载函数的三种结果"><a href="#调用重载函数的三种结果" class="headerlink" title="调用重载函数的三种结果"></a>调用重载函数的三种结果</h6><ul>
<li>最佳匹配，</li>
<li>找不到与实参匹配的函数 ，发出无匹配错误</li>
<li>二义性调用</li>
</ul>
<h6 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h6><p>内层作用域中声明的名字会隐藏外层作用域中声明的同名实体，重载的函数名也是一样</p>
<h6 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h6><p>某个形参被赋予了默认值，它的后面的所有形参都必须有默认值，只能省略函数尾部的实参</p>
<ul>
<li><p>默认实参声明</p>
<p>多次声明同一个函数是合法的，-不能修改已经存在的默认值，函数的后续声明只能位没有默认值的形参添加默认值。</p>
</li>
<li><p>默认实参的初始值</p>
<p>只要表达式的类型能够转换成形参所需的类型，该表达式就能作为默认值，（<em><strong>局部变量不能作为默认实参</strong></em>）</p>
</li>
</ul>
<h6 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h6><p><code>（inline）</code>：避免函数调用的开销，用于优化规模较小、流程直接、频繁调用的函数 ， 通常定义在头文件中</p>
<p><code>constexpr</code>: <em><strong>返回值只能是字面值类型，有且只能有一条return语句</strong></em></p>
<h4 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h4><ul>
<li>选定候选函数：与被调用函数<em><strong>同名</strong></em>，声明在<em>调用点可见</em></li>
<li>选定可行函数：需要的形参数量(默认实参)与本次调用提供的实参<em><strong>数量相同</strong></em>，实参类型与对应形参<em><strong>类型相同</strong></em>或者<em><strong>能够转换</strong></em></li>
<li>寻找最佳匹配：优于其他可行函数</li>
<li>如果没有最佳匹配将出现二义性调用的错误</li>
</ul>
<h6 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h6><p>为了确定最佳匹配：转换等级如下</p>
<ul>
<li><p>精确匹配：</p>
<ul>
<li>实参形参类型相同</li>
<li>实参从数组类型或函数类型转换为指针类型</li>
<li>实参添加顶层const或删除<em>顶层const</em>？</li>
</ul>
</li>
<li><p>通过const转换实现匹配：</p>
</li>
<li><p>类型提升</p>
</li>
<li><p>算数类型转换或指针转换:</p>
<ul>
<li><p>所有算术类型的转换级别都是一样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">float</span>)</span></span>;</span><br><span class="line"><span class="built_in">manip</span>(<span class="number">3.14</span>);  <span class="comment">//二义性调用</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类类型转换</p>
</li>
</ul>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>函数指针指向函数而非对象，指向特定的类型，函数的类型<em><strong>有返回类型和形参类型决定</strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;)  <span class="comment">// 未初始化</span></span><br></pre></td></tr></table></figure>

<h6 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h6><ul>
<li><p>函数名作为值使用时，函数自动转换为指针，</p>
</li>
<li><p>能够直接使用指向函数的指针调用函数，而无需解引用指针</p>
<ul>
<li><p>&#96;&#96;&#96;c++<br>pf &#x3D; lengthcompare;  &#x2F;&#x2F;pf指向名为lengthcompare的函数<br>pf &#x3D; &amp; lengthcompare; &#x2F;&#x2F;pf指向名为lengthcompare的函数</p>
<p>bool b1 &#x3D; pf(“hell0”,”hello”); &#x2F;&#x2F;调用lengthcompare函数<br>bool b1 &#x3D; (*pf)(“hell0”,”hello”);&#x2F;&#x2F;等价的调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###### 重载函数的指针</span><br><span class="line"></span><br><span class="line">函数指针的类型必须与重载函数中的某一个函数精确匹配</span><br><span class="line"></span><br><span class="line">###### 函数指针形参</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">void useBigger(const string&amp;,const string&amp;,bool pf(const string&amp;,const string&amp;,));  //第三个形参是指向函数的指针</span><br><span class="line">void useBigger(const string&amp;,const string&amp;,bool (*pf)(const string&amp;,const string&amp;,));  //显示地将形参定义为指向函数的指针</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>函数指针的值是 该函数机器代码表示中第一条指令的地址</p>
</blockquote>
<h3 id="Classes-类"><a href="#Classes-类" class="headerlink" title="Classes 类"></a>Classes 类</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>可以使用<code>class</code>与<code>struct</code> 关键字定义类</p>
<blockquote>
<p><code>class</code>默认访问权限是<code>private</code>，<code>struct</code>默认是<code>public</code></p>
<p><code>class</code> 继承默认是 <code>private</code> 继承，而 <code>struct</code> 继承默认是 <code>public</code> 继承 。<br><code>class</code> 可以使用模板，而 <code>struct</code> 不能。</p>
</blockquote>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li><strong>数据抽象</strong>（接口：用户能够执行的操作、实现：包括类的数据成员和成员函数）和<strong>封装</strong></li>
</ul>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul>
<li><code>this</code><strong>常量指针</strong>：成员函数都有一个<code>this</code>的隐式参数，指向对象本身（<strong>不能修改指向</strong>），（<em><strong>成员函数对</strong></em>）任何对类成员的直接访问都是 <code>this</code>的隐式引用。</li>
<li><code>const</code>常量成员函数：被<code>const</code>关键字放在成员函数的参数列表后面，表示成员函数的 <em><strong>隐式<code>this</code>参数是常量的</strong></em>： 即this是指向常量对象的常量指针。</li>
</ul>
<blockquote>
<p>Note: 非常量的成员函数具有 <code>this</code>的隐式参数，且this 是一个指向非常量对象的常量指针(指向不能改变)</p>
<pre><code>        对与常量对象来说，this是指向常量对象的常量指针，不能初始化普通成员函数的非常量形参 
</code></pre>
</blockquote>
<ul>
<li><p>常量对象、以及常量对象的引用、指针都只能调用常量成员函数</p>
</li>
<li><p>非成员函数：如果非成员函数是类接口的一部分，则需要声明在与类的用一个文件中、</p>
<ul>
<li>类本身就是一个作用域，编译器分两步处理类：1.编译类成员的声明 2. 成员函数的函数体</li>
</ul>
</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h4><h5 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h5><ul>
<li>初始化类的数据成员，创建类对象时就会被执行， 不能被声明成<code>const</code><ul>
<li>构造函数的名字和类相同，没有返回类型 - 构造函数重载必须在参数数量或类型之间有区别</li>
<li>构造函数在<em><strong>常量对象</strong></em>的构造过程中能够向其写值，直到构造函数完成初始化，常量对象才获得“常量”属性</li>
</ul>
</li>
</ul>
<h5 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h5><p>类没有显示地定义默认构造函数（没有任何参数）时，<em><strong>编译器会隐性地定义一个默认构造函数</strong></em></p>
<ul>
<li><p><u><em>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数</em></u></p>
</li>
<li><p>合成的默认构造函数的初始化规则</p>
<ul>
<li>如果存在类内的初始值，用它来初始化成员</li>
<li>否则，默认初始化成员</li>
</ul>
</li>
<li><p>不适用情况</p>
<ul>
<li>含有内置类型或者复合类型成员的类 - <a href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96">默认初始化</a>  </li>
<li>类包含其他类类型的成员，且这个类没有默认构造函数</li>
</ul>
</li>
<li><p><code>default</code> ： C++11允许添加“&#x3D;default”说明符到函数声明的末尾，以将该函数声明为显示默认构造函数。</p>
<ul>
<li>&#96;&#96;&#96;c++<br>class Sales_data{<br>Sales_data() &#x3D; default;    &#x2F;&#x2F;默认构造函数<br>&#x2F;&#x2F;Sales_data(){};			&#x2F;&#x2F;也是显示声明默认构造函数，有区别<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 初始化列表</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">//1 列表初始化： 初始化顺序与类中定义出现的顺序一致</span><br><span class="line">sacle_data(const string &amp;S,unsigned int data) : BOOK(S)&#123;&#125; </span><br><span class="line">//2 对成员执行赋值操作 ：先初始化在赋值</span><br><span class="line">sacle_data(const string &amp;S,unsigned int data) &#123; </span><br><span class="line">    BOOK = s;   </span><br><span class="line">    ……; </span><br><span class="line">&#125;</span><br><span class="line">//成员时const 或者 引用时，，或这成员的类型没有定义默认构造函数，必须初始化(不能使用类似2的赋值操作)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>初始化const 或者引用类型的数据成员的唯一机会就是构造函数初始值。</p>
</li>
<li><p>类数据成员的初始化顺序与类中定义出现的顺序一致</p>
</li>
<li><p>为一个构造函数的所有参数都提供<em><strong>默认实参</strong></em>，实际上也定义了<em><strong>默认构造函数</strong></em></p>
</li>
</ul>
<h5 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h5><ul>
<li>一个委托构造函数也有一个成员初始化列表和一个函数体，</li>
<li>成员初始化列表只能包含<strong>一个其它构造函数，</strong><ul>
<li>不能再包含其它成员变量的初始化，</li>
<li>且参数列表必须与构造函数匹配。</li>
</ul>
</li>
<li>被委托的构造函数应该包含<em><strong>较大数量的参数</strong></em>，初始化较多的成员变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123;<span class="built_in">initRest</span>(); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> i) : <span class="built_in">Foo</span>() &#123;type = i;&#125; <span class="comment">// 对type 重新赋值</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">char</span> e) : <span class="built_in">Foo</span>() &#123;name = e;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initRest</span><span class="params">()</span> </span>&#123; <span class="comment">/* init othre members */</span>&#125;</span><br><span class="line">    <span class="type">int</span> type&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">char</span> name&#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h5><p>转换构造函数：构造函数只接受一个实参（包含默认实参）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> HashTable &amp; a)</span> </span>&#123; cout &lt;&lt; a.val; &#125;	</span><br><span class="line"><span class="built_in">HashTable</span>(<span class="type">int</span> val)					<span class="comment">//定义了int 向HashTable 的隐式类型转化</span></span><br><span class="line"><span class="built_in">HashTable</span>(<span class="type">int</span> val, <span class="type">double</span> d = <span class="number">8.0</span>); <span class="comment">//同样定义了int 向HashTable 的隐式类型转化</span></span><br><span class="line">HashTable&lt;<span class="type">int</span>&gt; mhash;</span><br><span class="line">mhash.<span class="built_in">test</span>(<span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类成员函数</span></span><br><span class="line"><span class="comment">// Sales_data &amp; combine(const Sales_data &amp;);</span></span><br><span class="line"><span class="comment">//Sales_data item; 对象</span></span><br><span class="line"><span class="comment">//Sales_data(string &amp; str): BOOK(str) &#123;&#125; 一个实参的构造函数</span></span><br><span class="line">string null_book = <span class="string">&quot;ssss&quot;</span>;</span><br><span class="line"><span class="comment">//构造临时的Sales_data对象，其他成员执行默认初始化BOOK = null_book;</span></span><br><span class="line">item.<span class="built_in">combine</span>(null_book);  <span class="comment">//包含string 向Sales_data的隐式类型转换</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编译器只有自动执行一步的<em><strong>隐式类型转换</strong></em>：</li>
</ul>
<h5 id="explicit构造函数"><a href="#explicit构造函数" class="headerlink" title="explicit构造函数"></a><em><strong>explicit</strong></em>构造函数</h5><p>修饰单参数的构造函数，抑制类的隐式类型转换，</p>
<ul>
<li>只能在<strong>类内部声明构造函数</strong>时使用，<strong>类外部定义时不能重复</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(string &amp; str)</span>: BOOK(str) &#123;</span>&#125; </span><br><span class="line">item.<span class="built_in">combine</span>(null_book); <span class="comment">//错误，</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em><strong>explicit</strong></em>构造函数只能用于直接初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>; <span class="comment">//正确 ：直接初始化</span></span><br><span class="line">Sales_data item2 = null_book; <span class="comment">// 错误，不能用于拷贝初始化， 会发生隐式的类型转换</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// conversion from A (constructor):</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">const</span> A&amp; x)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B&#x27;s constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// conversion from A (assignment):</span></span><br><span class="line">	B&amp; <span class="keyword">operator</span>= (<span class="type">const</span> A&amp; x) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B&#x27;s assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// conversion to A (type-cast operator)</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B&#x27;s conversion&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(B arg)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	A foo;</span><br><span class="line">	<span class="function">B <span class="title">bar</span><span class="params">(foo)</span></span>;</span><br><span class="line">	<span class="comment">//B bar = foo;    // calls constructor, 添加explicit出错, 不能默认构造</span></span><br><span class="line">	<span class="comment">//bar = foo;      // calls assignment</span></span><br><span class="line">	<span class="comment">//foo = bar;      // calls type-cast operator</span></span><br><span class="line">	<span class="comment">//fn(foo); //添加explicit出错, 就不能默认的隐式转换</span></span><br><span class="line">	<span class="built_in">fn</span>(bar);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="拷贝、赋值、析构"><a href="#拷贝、赋值、析构" class="headerlink" title="拷贝、赋值、析构"></a>拷贝、赋值、析构</h4><ul>
<li>不显示地定义这些操作，编译器会合成默认的操作函数 -<a href="">13章</a></li>
</ul>
<h4 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h4><p><em><strong>访问说明符</strong></em>：</p>
<ul>
<li><code>public</code> 说明符之后的成员在整个程序中都可见，定义类的接口</li>
<li><code>private</code>说明符之后的成员可以被类的成员函数访问，封装了类的实现细节</li>
</ul>
<h5 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h5><p>可以把1、<em><strong>非成员函数</strong></em> 2、<em><strong>其他的类</strong></em> 3、<em><strong>其他类的成员函数</strong></em>定义为友元、 把友元函数定义在类内部：隐式内联的函数</p>
<ul>
<li><p>允许其他类或函数访问类的私有成员：<code>friend</code></p>
</li>
<li><p>全局函数作友元函数：在类中声明<code>friend void friendfun(void)</code> -</p>
<ul>
<li><p>友元的声明仅仅是指定了访问权限，不是函数声明，需要  “<strong>在友元声明之外对函数进行声明</strong>”</p>
</li>
<li><p>类和非成员函数的声明不是必须在友元声明之前：当一个函数名字第一次出现在友元声明中，<strong>隐式地假定该名字在当前作用域是可见的</strong></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>friend complex add(complex &amp;a,complex &amp; b) ; &#x2F;&#x2F;不是声明不能省略形参名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 友元函数没有this指针，不能被继承</span><br><span class="line"></span><br><span class="line">- 友元类： 友元类的成员函数***可以访问此类包括私有成员在内的所有成员***</span><br><span class="line"></span><br><span class="line">- 成员函数作为友元：：使用***类作用域运算符***指明该成员函数属于哪个类</span><br><span class="line"></span><br><span class="line">  - 先定义类a，**声明成员函数`func`**（将作为另一个类的友元）（不能定义）</span><br><span class="line">  - 定义类b（使用类a的成员函数作为友元），包括对`func`的**友元声明**</span><br><span class="line">  - 最后**定义`func`**。</span><br><span class="line"></span><br><span class="line">#### 类的其他特性</span><br><span class="line"></span><br><span class="line">##### 类型成员</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class Screen &#123;</span><br><span class="line">public: </span><br><span class="line">	typedef std::sting::size_type pos;  //类型别名</span><br><span class="line">    //using pos = std::sting::size_type d</span><br><span class="line">private:</span><br><span class="line">    pos cursor = 0;</span><br><span class="line">    pos hegiht = 0, width = 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="重载成员函数"><a href="#重载成员函数" class="headerlink" title="重载成员函数"></a>重载成员函数</h5><p>与非成员函数的重载相同</p>
<h5 id="可变数据成员-mutable"><a href="#可变数据成员-mutable" class="headerlink" title="可变数据成员 mutable"></a>可变数据成员 <code>mutable</code></h5><p>关键字：<code>mutable</code>： 可变数据成员永远不会是const -任何成员函数，包括const成员函数都能改变它的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类结构内</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr;</span><br><span class="line"><span class="comment">//类外</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classname::some_member</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++access_ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类数据成员的初始值"><a href="#类数据成员的初始值" class="headerlink" title="类数据成员的初始值"></a>类数据成员的初始值</h5><p>当提供一个类内初始值时，必须使用符号<code>=</code>或者花括号表示。</p>
<h5 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data item1;		<span class="comment">//默认初始化Sales_data类型的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> item1; <span class="comment">//等价的声明 默认初始化Sales_data类型的对象 </span></span><br><span class="line"><span class="comment">//类的声明</span></span><br><span class="line">Class screen; <span class="comment">// 前向声明，在声明之后定义之前</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类的声明<br><code>Class screen;</code> 前向声明，在声明之后定义之前，是一个<strong>不完全类型</strong>（已知是类类型，不清楚包含哪些成员及所占空间）<a name = "不完全类型"></a><ul>
<li>不完全类型：定义指向这种类型的指针或者引用，<em><strong>声明</strong></em>（不能定义）以不完全类型为参数或者返回值的函数。</li>
<li>不能使用不完全类型或定义该类型的对象。</li>
</ul>
</li>
</ul>
<h4 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h4><p>……</p>
<p>类的定义分为两步处理：编译器会先处理完类中的所有声明，之后才会处理函数成员的定义</p>
<h5 id="只适用于成员函数种的使用的名字"><a href="#只适用于成员函数种的使用的名字" class="headerlink" title="只适用于成员函数种的使用的名字"></a>只适用于成员函数种的使用的名字</h5><ul>
<li>首先，编译成员的声明</li>
<li>直到所有类全部可见之后才编译函数体  -</li>
</ul>
<h5 id="声明中使用的名字"><a href="#声明中使用的名字" class="headerlink" title="声明中使用的名字"></a>声明中使用的名字</h5><p>包括返回类型、参数列表中的名字， 只考虑名字出现之前的声明</p>
<h5 id="类型名要特殊处理"><a href="#类型名要特殊处理" class="headerlink" title="类型名要特殊处理"></a>类型名要特殊处理</h5><p>一般：内层作用域可以重新定义外层作用域中的名字</p>
<p>特殊：类中，如果成员使用外层作用域中的名字，且这个名字<em><strong>代表一种类型</strong></em>， 则不能重新定义该名字</p>
<h4 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h4><ul>
<li><p>满足条件：</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类、没有**<code>virtual</code>**函数</li>
</ul>
</li>
<li><p>初始化：</p>
<ul>
<li>&#96;&#96;&#96;c++<br>struct Data {<br>int val;<br>string s;<br>}<br>Data val1 &#x3D; { 0, “Anna”};	<br>&#x2F;&#x2F;初始值列表中的元素少于类的成员数量，则靠后的成员被默认值初始化<br>&#x2F;&#x2F;初始值列表的元素个数不能超过类的成员数量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 类的静态成员 static</span><br><span class="line"></span><br><span class="line">静态成员可以是public、private的</span><br><span class="line"></span><br><span class="line">- 类的静态成员存在于任何对象之外，对象不包含任何于静态成员有关的数据。</span><br><span class="line">- 静态成员函数不与任何对象绑定， 不包含`this` 指针 ：静态成员函数不能声明为`const`</span><br><span class="line"></span><br><span class="line">##### 定义静态成员</span><br><span class="line"></span><br><span class="line">- static关键字***只出现在类内部***的声明语句中, 在类外部定义静态成员函数不能重复</span><br><span class="line">- 静态数据成员不是由类的构造函数初始化的，***必须在类外部定义和初始化***每个静态数据成员</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">//对象类型， 类名，作用域运算符， 成员名</span><br><span class="line">double Account :: interestRate = initRate(); </span><br><span class="line">//    |从这里出现类名开始，都位于类的作用域中</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="使用静态成员"><a href="#使用静态成员" class="headerlink" title="使用静态成员"></a>使用静态成员</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span> ：</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">caculate</span><span class="params">()</span> </span>&#123;amount += amount * interestRate&#125; <span class="comment">// 成员函数不用通过做作用域运算符就能访问静态成员</span></span><br><span class="line">	<span class="type">static</span> <span class="type">double</span> <span class="built_in">rate</span>() &#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125; <span class="comment">//声明静态成员函数</span></span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">	<span class="type">double</span> amount;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">double</span> interestRate; <span class="comment">//静态数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> r;</span><br><span class="line">Account ac1;</span><br><span class="line">Account &amp;ac2 = ac1;</span><br><span class="line">Account *ac3 = &amp;acl; </span><br><span class="line">r = Account :: <span class="built_in">rate</span>();  <span class="comment">//通过作用域运算符访问静态成员</span></span><br><span class="line">r = ac1.<span class="built_in">rate</span>();			<span class="comment">//通过类的对象</span></span><br><span class="line">r = ac2.<span class="built_in">rate</span>();			<span class="comment">//通过类的引用</span></span><br><span class="line">r = ac3-&gt;<span class="built_in">rate</span>();		<span class="comment">//通过类的指针</span></span><br></pre></td></tr></table></figure>

<h5 id="静态成员的类内初始化"><a href="#静态成员的类内初始化" class="headerlink" title="静态成员的类内初始化"></a>静态成员的类内初始化</h5><p><em>一般不能在类内初始化静态数据成员</em></p>
<ul>
<li>可以： 字面值常量类型的静态数据成员： <code>constexpr</code>，初始值必须是<em><strong>常量表达式</strong></em><ul>
<li>即使常量静态数据成员在类内初始化了，也应该在<em><strong>类外定义</strong></em></li>
</ul>
</li>
</ul>
<h5 id="静态成员与普通成员的区别"><a href="#静态成员与普通成员的区别" class="headerlink" title="静态成员与普通成员的区别"></a>静态成员与普通成员的区别</h5><ul>
<li>不属于任何对象</li>
<li>静态数据成员、指针成员可以是**<a href="#%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%B1%BB%E5%9E%8B">不完全类型</a>**, 普通数据成员必须是完全类型</li>
<li>静态成员可以作为<em><strong>默认实参</strong></em>，非静态数据成员不能作为成员函数的默认实参</li>
</ul>
<h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><pre><code>由编译器自动创建、销毁：
</code></pre>
<ul>
<li>静态内存：保存局部<code>statc</code>对象、类<code>static</code>数据成员、定义在函数体外部得变量；</li>
<li>栈内存：保存定义在函数内部的非<code>static</code>对象、</li>
</ul>
</li>
<li>内存池：（自由空间或堆（heap）：程序用来贮存动态分配的对象</li>
</ul>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><h5 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h5><p><code>#include&lt;memory&gt;</code></p>
<ul>
<li>运行多个指针指向同一个对象<ul>
<li>模板类，实例化时提供指针指向的类型 <code>shared_ptr&lt;string&gt; p1</code> ,使用方式与普通指针类型</li>
</ul>
</li>
</ul>
<h6 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shared_ptr\ unique_str 都支持的操作</span></span><br><span class="line">shared_ptr&lt;T&gt; sp; <span class="comment">//创建空的智能指针</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">sp</span><span class="params">(q,d)</span></span>; <span class="comment">//sp智能指针接管内置指针的对象所有权，使用d类型可调用对象代替delete</span></span><br><span class="line">unique_ptr&lt;T&gt; up;</span><br><span class="line"><span class="keyword">if</span>(p) <span class="comment">// 作为条件判断，return p != nullptr;</span></span><br><span class="line">*p;  <span class="comment">//解引用指针，获得指针指向的对象</span></span><br><span class="line">p-&gt;mem <span class="comment">//等价于（*p）.mem</span></span><br><span class="line">p.<span class="built_in">get</span>() <span class="comment">//返回p中保存的指针</span></span><br><span class="line"><span class="built_in">swap</span>(p,q);<span class="comment">//交换p和q指针</span></span><br><span class="line">p.<span class="built_in">swap</span>(q);</span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr 独有的操作</span></span><br><span class="line"><span class="built_in">make_shared</span>&lt;T&gt;(args) <span class="comment">//返回shared_ptr&lt;T&gt; 对象，用args初始化此对象</span></span><br><span class="line">shared_ptr&lt;T&gt;<span class="built_in">P</span>(q) <span class="comment">// p是q的拷贝，（递增q的计数器？）</span></span><br><span class="line">p = q; 			<span class="comment">//此操作会递减p的计数器，递增q的计数器，若p的引用计数变为0，则将其管理的原内存释放</span></span><br><span class="line">p.<span class="built_in">unique</span>()	<span class="comment">//return p.use_count() == 1</span></span><br><span class="line">p.<span class="built_in">use_count</span>()	<span class="comment">// 返回于p共享对象的智能指针数值</span></span><br></pre></td></tr></table></figure>

<h6 id="make-shared"><a href="#make-shared" class="headerlink" title="make_shared"></a>make_shared</h6><ul>
<li>必须指定要创建的对象的类型：<code>make_shared&lt;sting&gt;(10,&#39;a&#39;)</code>;<ul>
<li>传递的参数于类型的某个构造函数相匹配</li>
</ul>
</li>
</ul>
<h6 id="拷贝和赋值"><a href="#拷贝和赋值" class="headerlink" title="拷贝和赋值"></a>拷贝和赋值</h6><ul>
<li>引用计数器（reference count）：shared_ptr 关联的计数器 记录有多少个其他shared_ptr 指向相同的对象<ul>
<li>无论何时<strong>拷贝</strong>一个<code>shared_ptr</code>都会递增其计数器<ul>
<li>用一个<code>shared_ptr</code> 初始化另一个<code>shared_ptr</code></li>
<li>作为参数传递给函数</li>
<li>作为函数的返回值</li>
</ul>
</li>
<li>给<code>shared_ptr</code>赋予新值或者<code>shared_ptr</code>被销毁(局部<code>shared_ptr</code>离开其作用域)，都会递减计数器x</li>
<li>最后一个<code>shared_ptr</code> 销毁时，对象会被自动释放</li>
</ul>
</li>
</ul>
<h5 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h5><p>new运算符：动态分配内存，delete 释放new分配的内存</p>
<ul>
<li><p>new： 返回一个指向对象的指针</p>
<ul>
<li>&#96;&#96;&#96;c++<br>int *pi &#x3D; new int; &#x2F;&#x2F; 执行默认初始化 ， pi指向未初始化的int<br>int *pi &#x3D; new int(); &#x2F;&#x2F;值初始化为 0，<br>sting *str &#x3D; new sting; &#x2F;&#x2F;执行默认初始化 （默认构造函数）,空的string<br>sting *str &#x3D; new sting();&#x2F;&#x2F;值初始化为 空string<br>&#x2F;&#x2F;直接初始化： 圆括号、花括号<br>int *pi &#x3D; new int(1024);<br>string *str &#x3D; new string(19,’a’);  &#x2F;&#x2F; 与某个构造函数相匹<br>vector<int> *pv &#x3D; new vector<int>{1,2,3,4,5,6,7,8,9};<br>&#x2F;&#x2F;由初始化器推断分配的对象的类型<br>auto *p &#x3D; new auto(obj);  &#x2F;&#x2F;只有当括号中由唯一的初始化器，编译器才能由此推断类型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 动态分配const 对象</span><br><span class="line"></span><br><span class="line">  - `const int * pci = new int(1024); ` // 与任何const 对象，必须进行初始化，</span><br><span class="line">  - new 返回的是指向const 的指针</span><br><span class="line"></span><br><span class="line">- 定位`new`： `int *p2  = new (nothrow) int`</span><br><span class="line"></span><br><span class="line">  - 如果这种形式的new 不能分配所需内存，会返回一个空指针</span><br><span class="line"></span><br><span class="line">- `delete`：接受一个指针，释放对象</span><br><span class="line"></span><br><span class="line">  - `delete p; // p 必须指向动态分配的对象或空指针`</span><br><span class="line">  - delete 释放静态对象或者释放已经被释放的对象**会**潜在危害，（尽管大多数编译器都能通过）</span><br><span class="line">  - 由内置指针（区别于智能指针）管理的动态内存，在被显示释放之前都会一直存在</span><br><span class="line">  - **空悬指针**：delete一个指针后，指针仍然保存着（已经释放了的）动态内存的地址</span><br><span class="line">    - delete之后将指针指向改为`nullptr`</span><br><span class="line"></span><br><span class="line">##### shared_ptr 和new</span><br><span class="line"></span><br><span class="line">- 可以用new返回的指针来初始化智能指针：`shared_ptr&lt;int&gt; p2(new int(0));`</span><br><span class="line">  - 接受指针参数的 智能指针构造函数是 explicit的，- 因此不能使用拷贝初始化</span><br><span class="line">    - `即 shared_ptr&lt;int&gt; p2 = new int(1);` 是错误的。</span><br><span class="line"></span><br><span class="line">- 其他操作：</span><br><span class="line">  - `p.reset(new int(1024));`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 智能指针与异常</span><br><span class="line"></span><br><span class="line">#### unique_ptr</span><br><span class="line"></span><br><span class="line">- 拥有所指向对象的所有权，某个时刻智能有一个unique_ptr 指向一个对象，被销毁时，所指的对象也被</span><br><span class="line">  - 只能绑定到new 返回的指针</span><br><span class="line">    - 使用内置指针初始化时，编译通过，但是运行 销毁时使用默认的delete会出错；</span><br><span class="line"></span><br><span class="line">  - 绑定到new </span><br><span class="line">  - 不支持普通的拷贝和赋值操作</span><br><span class="line">  - 能够拷贝或赋值将要被销毁的unique_ptr指针：--编译器执行一种特殊的拷贝</span><br><span class="line">    - 从函数返回一个unique_ptr</span><br><span class="line">    - 返回局部对象的拷贝</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 操作</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">unique_ptr&lt;T&gt; U1; //空的unique_ptr对象,可以指向T的对象，默认使用delete释放指针</span><br><span class="line">unique_ptr&lt;T，D&gt; U2; //使用类型为D的可调用对象释放指针</span><br><span class="line">u = nullptr; // 1.释放u指向的对象，2，将u置空</span><br><span class="line">u.release(); //返回当前保存的指针，后将指针置为空， 指向对象没有释放</span><br><span class="line">	p2.release(); //错误的，p2指向的对象不会被释放，且丢失了指向这个对象的指针</span><br><span class="line">auto p = p2.release(); //正确，p2 被置空，需要delete p；</span><br><span class="line">u.reset(); //释放u指向的对象</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>传递删除器： 在尖括号中提供删除器的类型，并在创建或对象时提供一个指定类型（删除器类型）的对象</p>
<ul>
<li><code>unique_ptr&lt;objt,delT&gt; P(new objt,fcn);</code></li>
</ul>
</li>
</ul>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><ul>
<li>指向由shared_ptr管理的对象，不会影响所指对象的生存期（弱共享）</li>
<li>操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">weak_ptr&lt;T&gt; W; <span class="comment">//创建空的weak_ptr</span></span><br><span class="line"><span class="function">weak_ptr&lt;T&gt; <span class="title">W</span><span class="params">(sp)</span></span>; <span class="comment">// 与shared_ptr sp指向相同对象</span></span><br><span class="line">w = p; <span class="comment">// 可以将shared_ptr 或者weak_ptr 赋值给另一个weak_ptr;</span></span><br><span class="line">w.<span class="built_in">reset</span>(); <span class="comment">// 置空</span></span><br><span class="line">w.<span class="built_in">use_count</span>(); <span class="comment">// 返回与W共享的shared_ptr 的数量</span></span><br><span class="line">w.<span class="built_in">expired</span>(); <span class="comment">// 返回 w.use_count() == 0;</span></span><br><span class="line">w.<span class="built_in">lock</span>();   <span class="comment">// return w.expired() ? nullptr : shared_ptr;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建weak_ptr , 要用一个 shared_ptr 来初始化</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能直接用weak_ptr 访问对象： 可能对象已经被销毁了</span></span><br><span class="line"><span class="comment">//使用.lock() 来d</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">auto</span> np = wp.<span class="built_in">lock</span>()) &#123;&#125;;  <span class="comment">//np 不为空 访问对象</span></span><br></pre></td></tr></table></figure>



<h2 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h2><table>
<thead>
<tr>
<th>成员函数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>拷贝构造函数</td>
<td></td>
</tr>
<tr>
<td>拷贝赋值运算符</td>
<td></td>
</tr>
<tr>
<td>移动构造函数</td>
<td></td>
</tr>
<tr>
<td>移动赋值运算符</td>
<td></td>
</tr>
<tr>
<td>析构函数</td>
<td></td>
</tr>
</tbody></table>
<h4 id="拷贝、赋值于销毁"><a href="#拷贝、赋值于销毁" class="headerlink" title="拷贝、赋值于销毁"></a>拷贝、赋值于销毁</h4><h5 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h5><ul>
<li>构造函数的<strong>第一个参数</strong>是<strong>自身类型的引用</strong>，且其余额外的参数都有默认值<ul>
<li>第一个参数必须是<em>引用</em>：如果不是引用的话，调用拷贝构造函数时，要拷贝实参来初始化形参时又会调用拷贝构造函数 -————***<u>永无休止而导致栈溢出</u>***</li>
<li>合成拷贝构造函数：如果没有显示地定义拷贝构造函数，编译器将数据成员逐个拷贝到正在创建的对象中</li>
</ul>
</li>
<li>拷贝初始化<ul>
<li>使用 <code>“=”</code>进行<strong>初始化</strong>时：执行拷贝初始化</li>
<li>拷贝初始化在下列情况也会发生（依靠拷贝构造函数或者移动构造函数）<ul>
<li>使用等号定义一个变量时</li>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ul>
</li>
</ul>
</li>
<li>合成拷贝函数：按值拷贝</li>
</ul>
<h6 id="调用拷贝构造函数的三种情况"><a href="#调用拷贝构造函数的三种情况" class="headerlink" title="调用拷贝构造函数的三种情况:"></a>调用拷贝构造函数的三种情况:</h6><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1、用一个对象去初始化同一个类的另一个新对象时</span><br><span class="line">2、函数的形参对象，调用函数进行形参和实参结合时 </span><br><span class="line">3、函数的返回值是类的对象，函数执行返回调用时 将一个对象赋值给另一个对象，两个对象都存在，调用的是赋值构造函数，不涉及内存的分配。</span><br><span class="line">当被赋值的对象不存在调用的是拷贝构造函数。</span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>    函数调用过程中，具有非引用的形参或者具有非引用的返回类型时进行拷贝初始化
</code></pre>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str = “<span class="number">1234</span>”; <span class="comment">// &quot;1234&quot; 隐式转换为string类型，产生一个临时对象（调用转换构造函数）</span></span><br><span class="line">					<span class="comment">//调用拷贝构造函数创建str 对象</span></span><br></pre></td></tr></table></figure>

<h5 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h5><ul>
<li><p>赋值运算符：通常组合析构函数和构造函数的功能</p>
<ul>
<li>销毁左侧运算对象的资源</li>
<li>从右侧对象拷贝数据</li>
</ul>
</li>
<li><p>重载运算符：本质上是函数，<code>operator + 运算符组成</code>，有返回类型和参数列表</p>
<ul>
<li>重载运算符的参数表示运算对象</li>
<li>成员函数： 左侧运算对象绑定到隐式的this参数，右侧运算对象有显示的参数传递</li>
</ul>
</li>
</ul>
<blockquote>
<p>赋值运算符通常返回一个指向左侧运算对象的引用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>返回值为类类型的引用： 保证进行连续赋值操作</span><br><span class="line"><span class="number">2.</span>传入的参数应为<span class="type">const</span> 引用：提高代码效率</span><br><span class="line"><span class="number">3.</span>释放左侧运算对象（自身已有的内存）</span><br><span class="line"><span class="number">4.</span>判断传入的参数是否是自身</span><br><span class="line">cm &amp; cm：：<span class="keyword">operator</span>=(<span class="type">const</span> cm &amp; other) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">cm <span class="built_in">temp</span>(other);</span><br><span class="line"><span class="type">char</span> * ptemp = temp.pdata; </span><br><span class="line">temp.pdata = <span class="keyword">this</span>-&gt;pdata;</span><br><span class="line"><span class="keyword">this</span>-&gt;pdata = temp.pdata;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用构造函数创建临时变量temp；</span></span><br><span class="line"><span class="comment">//交换temp 和this的pdata的指向</span></span><br><span class="line"><span class="comment">//在退出temp变量的作用域，会自动调用temp的析构函数，把temp。pdata指向的内存释放d</span></span><br></pre></td></tr></table></figure>

<ul>
<li>合成拷贝赋值运算符：未定义自己的拷贝赋值运算符：由编译器生成</li>
</ul>
<h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><ul>
<li>释放对象使用的资源、销毁对象的非static 数据成员<ul>
<li>不接受参数，因此不能被重载，一个类只有唯一一个析构函数</li>
<li>析构函数中，成员按初始化顺序的逆序销毁</li>
</ul>
</li>
<li>什么时候调用析构函数：无论何时一个对象被销毁<ul>
<li>变量离开其作用域</li>
<li>容器被销毁时，其元素被销毁</li>
<li>动态分配的对象，对指向他的指针应用delete运算符时被销毁</li>
<li>临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
</li>
<li>析构函数中，首先执行函数体，然后销毁成员：析构函数体自身并不直接销毁成员：<strong>在函数体之后隐含的析构阶段中被销毁</strong></li>
</ul>
<h5 id="x3D-default"><a href="#x3D-default" class="headerlink" title="&#x3D; default"></a>&#x3D; default</h5><ul>
<li>显示地要求编译器生成合成的拷贝控制成员（<em><strong>只能修饰</strong></em>默认构造函数或拷贝构造，拷贝赋值、析构）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sales</span> &#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"><span class="built_in">sales</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">sales</span>(<span class="type">const</span> sales &amp;) = <span class="keyword">default</span>;</span><br><span class="line">sales&amp; <span class="keyword">operator</span>=(<span class="type">const</span> sales &amp;) = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">sales</span>() = <span class="keyword">default</span>;  <span class="comment">//在类内用= default 修饰，合成的函数会隐式地声明为内联	</span></span><br><span class="line">&#125;</span><br><span class="line">sales&amp; sales::<span class="keyword">operator</span>=(<span class="type">const</span> sales &amp;) = <span class="keyword">default</span>; <span class="comment">// 类外修改生成不为内联</span></span><br></pre></td></tr></table></figure>

<h5 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h5><ul>
<li><p>通过将拷贝构造函数、拷贝赋值函数定义为删除的函数来阻止拷贝 （**&#x3D;delete**）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Nocopy</span> &#123;</span><br><span class="line">	<span class="built_in">Nocopy</span>() = dafault;</span><br><span class="line">	<span class="built_in">Nocopy</span>(<span class="type">const</span> Nocpopy&amp;) = <span class="keyword">delete</span>; <span class="comment">//阻止拷贝</span></span><br><span class="line">	Nocopy &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Nocpopy&amp;) = <span class="keyword">delete</span>; <span class="comment">//阻止赋值</span></span><br><span class="line">	~<span class="built_in">Nocopy</span>() = dafault;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&#x3D;delete 必须出现在函数第一次声明的地方， 可以对任何函数指定为&#x3D;delete；</p>
</li>
<li><p><u>析构函数是删除的</u>： 不允许定义该类型的变量或创建临时对象</p>
<ul>
<li><strong>类的成员的类型删除了析构</strong>：也不能定义这个类的变量或创建临时对象</li>
<li>但能够动态分配这种类型的对象，不能释放这些对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NoDtor</span> &#123;</span><br><span class="line"><span class="built_in">NoDtor</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">NoDtor</span>() = <span class="keyword">delete</span>;</span><br><span class="line">&#125;</span><br><span class="line">NoDtor np; <span class="comment">// 错误，不能定义删除了析构的类型的对象</span></span><br><span class="line">NoDtor np = <span class="keyword">new</span> <span class="built_in">NoDtor</span>(); <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">delete</span> np; <span class="comment">//错误，不能释放</span></span><br></pre></td></tr></table></figure>

<pre><code>&gt; 如果类有数据成员（不能默认构造、拷贝、复制、析构），则这个类的对应成员函数是定义为删除的
&gt;
&gt; 类有引用成员且没有[类内初始化器](#类内初始化器)，且没显式定义默认构造函数，则该类的默认构造函数是删除的
</code></pre>
<ul>
<li><p>private 拷贝控制</p>
<ul>
<li>通过将拷贝构造函数和拷贝赋值函数声明为private来阻止拷贝</li>
</ul>
</li>
</ul>
<p>标准库中定义的函数对象</p>
<p><code>#include&lt;functional&gt;</code></p>
<h4 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h4><ul>
<li><p>右值引用：必须绑定到右值上的引用</p>
<ul>
<li><p>变量是左值，不能直接将右值引用绑定到一个变量上，即使这个变量是右值引用</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>int &amp;&amp;rr1 &#x3D; 42;<br>int &amp;&amp;rr2 &#x3D; rr1; &#x2F;&#x2F;错误c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - std::move  返回给定对象的右值引用。</span><br><span class="line"></span><br><span class="line">- ***移动构造函数***和移动赋值函数</span><br><span class="line"></span><br><span class="line">  - 移动构造函数的第一个参数是该类型的右值引用，其余参数都有默认实参</span><br><span class="line"></span><br><span class="line">    - 完成移动后，源对象必须不再指向移动的资源</span><br><span class="line"></span><br><span class="line">    - ```c++</span><br><span class="line">      A::A(A &amp;&amp; a) noexcep ： elements(a.elements), first(a.first)&#123;</span><br><span class="line">      	a.elements = a.first = nullptr;</span><br><span class="line">      &#125;// 如果 没有将a.first置空，则销毁a之后，移动的资源也会被销毁</span><br></pre></td></tr></table></figure>

<blockquote>
<p>noexcept 不抛出异常的移动构造函数、移动赋值函数必须标记为noexcept</p>
<p>必须在成员函数的声明和定义都指定noexcept</p>
</blockquote>
</li>
</ul>
</li>
<li><p>移动后的源对象：必须保持有效(能够赋予新值，安全地使用)、可析构的状态，且值是不确定。</p>
</li>
<li><p>合成的移动操作：</p>
<ul>
<li><strong>只有当</strong>： 一个类没有定义自己的拷贝控制成员，且每个非static数据成员都能够移动时。</li>
</ul>
</li>
<li><p>移动右值、拷贝左值</p>
<ul>
<li><p>类既有移动构造函数、也有拷贝构造函数：按照<strong>普通函数的匹配规则</strong>确定使用函数</p>
</li>
<li><p>类没有移动构造函数，右值也使用拷贝构造函数</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>&#x2F;&#x2F; strVec 类中，拷贝构造函数接受const strVec的引用<br>strVec getvec(istream &amp;); &#x2F;&#x2F;返回一个右值<br>strVec v1,v2;<br>v1 &#x3D;v2;			&#x2F;&#x2F; v2是左值，使用的拷贝赋值函数<br>v2 &#x3D; getvec(cin);&#x2F;&#x2F; getvec(cin)是右值，精确匹配到移动赋值函数，使用移动赋值函数</p>
<p>class FOO{<br>FOO() &#x3D; default;<br>FOO(const FOO &amp;); &#x2F;&#x2F;拷贝构造函数<br>};<br>FOO X;<br>FOO Y(X); &#x2F;&#x2F;拷贝构造函数<br>FOO Z(std::move(X)); &#x2F;&#x2F;拷贝构造函数，因为没有定义移动构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 重载运算与类型转换</span><br><span class="line"></span><br><span class="line">##### 基本概念</span><br><span class="line"></span><br><span class="line">- 具有特殊名字的函数：`operator 和后面的运算符号组成`，**包含返回类型和参数列表、函数体**</span><br><span class="line">- 参数的数量与运算符的*&lt;u&gt;运算对象&lt;/u&gt;*一样多：（一元运算符有一个参数，二元运算符有两个参数）</span><br><span class="line">  - 二元运算符作为***普通函数***：左侧对象传递给第一个参数、右侧对象传递给第二个参数</span><br><span class="line">  - 二元运算符作为***成员函数***：左侧对象绑定到隐式的this指针，右侧对象为参数。（参数数量比运算对象少一个）</span><br><span class="line">- 运算符函数： 是类的成员函数(隐式地包含一个类类型参数)，或至少含有一个类类型的参数</span><br><span class="line">  - 不能为内置类型重载运算符</span><br><span class="line">- 对于`(+,-,*,&amp;)`既是一元运算符又是二元运算符，有参数的数量来推断</span><br><span class="line">- 重载运算符的优先级和结合律与内置运算符保持一致</span><br><span class="line">- `：： 、 .* . ?:`不能被重载</span><br><span class="line">- 重载 `&amp;&amp; || ，`运算符的求值顺序不能保留，**&lt;u&gt;短路求值失效&lt;/u&gt;**</span><br><span class="line"></span><br><span class="line">##### 重点</span><br><span class="line"></span><br><span class="line">- 赋值（=）、下标（[]）、调用（（））、和成员访问箭头（-&gt;）运算符必须是成员函数</span><br><span class="line">- *输入输出运算符必须是非成员函数，一般定义为友元函数*</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">//重载前置++运算符声明：</span><br><span class="line">    myclass &amp;operator++();// ++i 前置++ 加完返回左值</span><br><span class="line"></span><br><span class="line">//重载后置++运算符声明：</span><br><span class="line">	myclass operator++(int);// i++  后置++ 加完后 返回变量原始的值（右值）</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><pre><code>花括号列表赋值， 必须是成员函数
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec &amp; StrVec::<span class="keyword">operator</span>=(std::initializer_list&lt;std:string&gt; il)&#123;</span><br><span class="line">	<span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span>(),il.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">free</span>();</span><br><span class="line">	elements = data.first;</span><br><span class="line">	<span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="number">1.</span></span><br></pre></td></tr></table></figure>

<h5 id="重载输入输出运算符"><a href="#重载输入输出运算符" class="headerlink" title="重载输入输出运算符"></a>重载输入输出运算符</h5><ul>
<li>输入输出运算符必须是 <strong>非成员对象</strong> ： 否则 左侧运算对象是 类的一 个 <strong>对象</strong></li>
<li>读写类的 “非公有数据成员” ： 声明为<strong>友元</strong></li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>核心</strong>： <u>数据抽象、继承、动态绑定</u></p>
<ul>
<li>继承：该机制自动地为一个类提供来自另一个类的操作和数据结构</li>
<li>动态绑定: 使用<strong>基类的引用（指针）调用虚函数</strong>时发生动态绑定，就是在运行时，虚函数会根据绑定对象的实际类型，选择调用函数的版本。</li>
</ul>
<h3 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h3><h4 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Qutoe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="built_in">Qutoe</span>() = <span class="keyword">default</span>;</span><br><span class="line">	 <span class="built_in">Qutoe</span>(<span class="type">const</span> std::string book, <span class="type">double</span> pri) : <span class="built_in">bookNo</span>(book), <span class="built_in">price</span>(pri) &#123;</span><br><span class="line">		 std::cout &lt;&lt; <span class="string">&quot;调用Qutoe构造函数_&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">return</span> bookNo;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> t)</span> <span class="type">const</span></span>;</span><br><span class="line">	 <span class="keyword">virtual</span> ~<span class="built_in">Qutoe</span>() &#123;</span><br><span class="line">		 std::cout &lt;&lt; <span class="string">&quot;调用Qutoe析构函数_&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	 &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string bookNo;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	<span class="type">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Qutoe::net_price</span><span class="params">(std::<span class="type">size_t</span> t)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Qutoe_版本的函数:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> t * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>virtual</code>: 虚函数，派生类重写属于派生类的函数版本，与基类版本区分<ul>
<li>虚函数在派生类中隐式地也是虚函数</li>
<li>普通成员函数： 派生类直接继承，不能修改，</li>
</ul>
</li>
<li>访问 控制<ul>
<li>public ： 公有成员，派生类和其他用户都能访问</li>
<li>protected ： 受保护成员，派生类和友元能访问，其他用户无法访问<ul>
<li>派生类对象和友元只能通过 <em><strong><u>派生类的对象</u></strong></em> 访问基类受保护的成员</li>
</ul>
</li>
<li>private： <strong>派生类 和其他用户都不能访问</strong></li>
</ul>
</li>
</ul>
<h4 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Bulk</span> : <span class="keyword">public</span> Qutoe <span class="comment">//1.类派生列表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="built_in">Bulk</span>() = <span class="keyword">default</span>;</span><br><span class="line">	 <span class="built_in">Bulk</span>(<span class="type">const</span> std::string, <span class="type">double</span>, std::<span class="type">size_t</span>, <span class="type">double</span>);</span><br><span class="line">	 <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;  <span class="comment">//2.虚函数</span></span><br><span class="line">	 ~<span class="built_in">Bulk</span>() &#123;</span><br><span class="line">		 std::cout &lt;&lt; <span class="string">&quot;调用Bulk析构函数_&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	 &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="type">size_t</span> min_qty;</span><br><span class="line">	<span class="type">double</span> discount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Bulk::net_price</span><span class="params">(std::<span class="type">size_t</span> t)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Bulk_版本的函数:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">if</span> (t &gt; min_qty) &#123;</span><br><span class="line">		<span class="keyword">return</span> t * (<span class="number">1</span> - discount)* price; <span class="comment">// 基类的公有成员也是派生类的组成部分</span></span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">return</span> t * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类派生列表："><a href="#类派生列表：" class="headerlink" title="类派生列表："></a>类派生列表：</h5><ul>
<li><p>指出该类有哪些基类继承而来，<code>： 访问说明符 类名</code></p>
</li>
<li><p>派生类访问说明符与能否访问直接基类的成员<strong>没有影响</strong>，控制派生类用户对于基类成员的访问权限 （<strong>不影响派生类对基类成员的访问权限</strong>）</p>
<ul>
<li><p><code>： public</code> 公有继承，基类的<code>公有成员（受保护成员）</code>也是派生类的组成部分，基类的公有成员成为派生类的公有成员， –成员遵循原有访问说明符–&gt;</p>
</li>
<li><p><code>：private</code> 私有继承，基类的  <code>公有成员和保护成员</code> 在派生类中的访问属性相当于派生类中的<strong>私有成员</strong>   –继承至基类的成员的访问都变为私有的–&gt;</p>
</li>
<li><table>
<thead>
<tr>
<th>私有基类中的成员</th>
<th>在私有派生类中的访问属性</th>
</tr>
</thead>
<tbody><tr>
<td>私有成员</td>
<td>不可访问</td>
</tr>
<tr>
<td>公用成员</td>
<td>私有</td>
</tr>
<tr>
<td>保护成员</td>
<td>私有</td>
</tr>
</tbody></table>
</li>
<li><p><code>： protected</code> 受保护继承  –基类的公有成员降级为受保护的-</p>
</li>
</ul>
</li>
</ul>
<h5 id="派生类中虚函数："><a href="#派生类中虚函数：" class="headerlink" title="派生类中虚函数："></a>派生类中虚函数：</h5><ul>
<li>派生类的函数如果覆盖基类虚函数：<ul>
<li>形参类型必须完全一致</li>
<li>返回类型必须匹配（例外:<strong>虚函数返回类本身的指针或引用</strong>）</li>
</ul>
</li>
<li>如果没有覆盖继承的虚函数，则使用的是基类中的版本</li>
<li><ol>
<li>可以<code>virtual</code> 关键字，非必须，不加就是隐式地</li>
<li>在形参列表后（<code>const</code> 后）添加关键字 <code>override</code> 显示地注明覆盖了继承的虚函数</li>
</ol>
</li>
</ul>
<h5 id="向基类的类型转换"><a href="#向基类的类型转换" class="headerlink" title="向基类的类型转换"></a>向基类的类型转换</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Qutoe item;</span><br><span class="line">	Bulk bulk;</span><br><span class="line">	Qutoe * p = &amp;item;</span><br><span class="line">	p = &amp;bulk;</span><br><span class="line">	Qutoe &amp;r = bulk;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol>
<li>基类类型的指针、引用能够指向派生类类型的对象</li>
<li>继承的关键：派生类对象中含有其基类对应的部分</li>
</ol>
</li>
</ul>
<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bulk::<span class="built_in">Bulk</span>(<span class="type">const</span> std::string str, <span class="type">double</span> d, std::<span class="type">size_t</span> t, <span class="type">double</span> d2) :</span><br><span class="line">	<span class="built_in">Qutoe</span>(str, d), <span class="built_in">min_qty</span>(t), <span class="built_in">discount</span>(d2)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;调用Bulk构造函数_&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先传参给基类的构造函数初始化<strong>基类的部分</strong>，然后按照声明顺序初始化派生类的成员</li>
<li>派生类对象的<code>基类部分</code> 先被创建（调用基类构造函数），然后是派生类部分，</li>
<li>销毁对象时则相反： 派生类部分先被销毁（调用派生类的析构函数），然后是基类部分，以此类推</li>
</ul>
<h5 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h5><ul>
<li>如果基类定义了一个静态成员，则整个继承体系（基类，所有的派生类）对于每个静态成员来说都只有唯一的一个实例。</li>
</ul>
<h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><ul>
<li>派生类的声明不能包含派生列表</li>
<li>用作基类的类<strong>必须</strong>是<a href="">完全类型</a>的， - 类不能派生他本身</li>
<li>基类使用<code>final</code>修饰以防止继承 - <code>class base final &#123;* *&#125;; 不能被继承</code></li>
</ul>
<h4 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h4><h5 id="静态类型动态类型"><a href="#静态类型动态类型" class="headerlink" title="静态类型动态类型"></a>静态类型动态类型</h5><ul>
<li><p>静态类型：变量声明时表达式生成的类型，在编译时总是已知的</p>
</li>
<li><p>动态类型：变量或表达式在内存中的对象的类型，直到运行时才可知</p>
</li>
<li><p>不一致的情况：</p>
<ul>
<li><p>基类的指针或引用的静态类型可能与其动态类型不一致</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>Qutoe item;<br>Bulk bulk;<br>Qutoe * p &#x3D; &amp;bulk;<br>display(*p,10);<br>&#x2F;&#x2F;<br>Bulk_版本的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 不存在**基类** 向派生类的隐式类型转换</span><br><span class="line"></span><br><span class="line">- 在对象之间不存在类型转换：派生类向基类的自动类型转换只对指针或引用有效</span><br><span class="line"></span><br><span class="line">### 虚函数</span><br><span class="line"></span><br><span class="line">- 必须为每个虚函数提供定义（纯虚函数除外）</span><br><span class="line">- **内联成员函数不能是虚函数**</span><br><span class="line"></span><br><span class="line">#### 对虚函数的调用</span><br><span class="line"></span><br><span class="line">- 通过指针或者引用调用虚函数时，直到运行时才能确定函数版本（发生动态绑定动态联编）</span><br><span class="line">- 通过具有普通类型（非引用指针）的表达式调用时，在编译时就会确定虚函数使用的版本</span><br><span class="line"></span><br><span class="line">#### final 、override说明符</span><br><span class="line"></span><br><span class="line">- override:</span><br><span class="line"></span><br><span class="line">  - 在形参列表后（`const` 后）添加关键字 `override` **显示地注明覆盖了继承的虚函数**</span><br><span class="line"></span><br><span class="line">  - (如果override 标记的函数，但函数没有覆盖存在的虚函数： **编译器将报错**)</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    struct B&#123;</span><br><span class="line">    	virtual void f1(int) const;</span><br><span class="line">    	virtual void f2();</span><br><span class="line">    	void f3();</span><br><span class="line">    &#125;</span><br><span class="line">    struct A： public B&#123;</span><br><span class="line">    	void f1(int) const override;  //正确</span><br><span class="line">        void f2(int) override;		// 错误，没有f2（int）的虚函数</span><br><span class="line">    	void f3() override;			// 错误，f3不是虚函数</span><br><span class="line">        void f4() override;			//错误，没有f4的函数</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>final</code></p>
<ul>
<li><p>修饰类 ： <code>class B final &#123;* *&#125;</code>， 防止继承</p>
</li>
<li><p>修饰函数： 防止虚函数被覆盖</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span>： <span class="keyword">public</span> B &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D3</span>： <span class="keyword">public</span> D2 &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>; <span class="comment">//错误。f1已经时final了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="默认实参-1"><a href="#默认实参-1" class="headerlink" title="默认实参"></a>默认实参</h4><ul>
<li>调用虚函数如果使用了默认实参： 实参值由本次调用的静态类型决定<ul>
<li>通过基类的指针或者引用调用虚函数时，使用的是 <strong>基类</strong>中定义的<strong>默认实参</strong></li>
</ul>
</li>
</ul>
<h4 id="回避虚函数"><a href="#回避虚函数" class="headerlink" title="回避虚函数"></a>回避虚函数</h4><ul>
<li><p>对虚函数的调用不要进行动态绑定，使用指定的版本：使用<strong>作用域运算符</strong>实现</p>
<ul>
<li>&#96;&#96;&#96;c++<br>double undiscount &#x3D; basep-&gt;Qutoe::net_price(42);<br>&#x2F;&#x2F;不管basep的动态类型是什么，调用的都是基类Qutoe中定义的函数版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 抽象基类</span><br><span class="line"></span><br><span class="line">#### 纯虚函数</span><br><span class="line"></span><br><span class="line">- 虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">virtual double net_price(std::size_t) const = 0;</span><br><span class="line">// 在虚函数声明语句的分号之前， =0。 （只能出现在虚函数声明语句处）</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可以为虚函数提供定义：函数体必须定义在类的<em>外部</em>，（不能为类的内部&#x3D;0的函数提供函数体）</p>
</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>含有(或没覆盖直接继承)纯虚函数的类，（不能直接创建抽象类的对象）</li>
</ul>
<h3 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h3><ul>
<li>派生类的作用域嵌套在基类的作用域之内</li>
<li>编译时进行名字查找：先在对应静态类型的类中查找，然后依次在直接基类中查找直到继承链顶端</li>
<li>派生类也能重用定义基类（直接或间接）中的名字，<u>内层作用域的名字将隐藏外层作用域的名字</u></li>
<li>名字查找先于类型检查：内层作用域的函数不会重载外层作用域的函数（派生类的函数不会从重载基类的函数）</li>
</ul>
<h4 id="名字查找与继承"><a href="#名字查找与继承" class="headerlink" title="名字查找与继承"></a>名字查找与继承</h4><ul>
<li>假设调用（p-&gt;mem()，依次执行以下4个步骤<ul>
<li>首先确定p的静态类型，必定是类类型</li>
<li>在p的<strong>静态类型</strong>对应的类中查找mem，如何找不到<ul>
<li>依次在直接基类中不断查找直到继承链的顶端</li>
<li>找不到：编译器将报错</li>
</ul>
</li>
<li>找到mem后，进行常规的类型检查</li>
<li>调用合法：根据是否是虚函数产生不同的代码<ul>
<li>动态联编</li>
<li>静态联编</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h4><ul>
<li><p>基类的虚函数与派生类有同名形参不同的函数：<em>派生类的函数会隐藏基类中的虚函数</em></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>class BASE {<br>public：<br>virtual int func(); &#x2F;&#x2F; 虚函数<br>}<br>class D1 ：public BASE{<br>public：<br>int func(int); &#x2F;&#x2F;不是虚函数，隐藏base中的虚函数<br>virtual void func2();<br>}<br>class D2 ：public D1{<br>public：<br>int func(int); &#x2F;&#x2F;不是虚函数，隐藏D1中的虚函数<br>int func();   &#x2F;&#x2F; 虚函数覆盖了base中的func<br>void func2();	&#x2F;&#x2F;虚函数。覆盖D1中的func2<br>}<br>&#x2F;&#x2F;调用<br>BASE bobj;<br>D1 d1obj;<br>D2 d2obj;<br>BASE * bp1 &#x3D; &amp;bobj,*bp2 &#x3D; &amp; d1obj, *bp3 &#x3D; &amp; d2obj;</p>
<p>bp1-&gt;func(); &#x2F;&#x2F;虚调用，运行时调用BASE::func()<br>bp2-&gt;func(); &#x2F;&#x2F;虚调用，运行时调用BASE::func(), D1没有覆盖虚函数<br>bp2-&gt;func(0); &#x2F;&#x2F;int func(int),错误base 没有匹配的函数<br>bp3-&gt;func(); &#x2F;&#x2F;虚调用，运行时调用D2::func()<br>bp3-&gt;func(0); &#x2F;&#x2F;int func(int),错误base 没有匹配的函数</p>
<p>D1 * dp1 &#x3D; &amp; d1obj;<br>D2 * dp2 &#x3D; &amp; d2obj;<br>bp2-&gt;f2();  &#x2F;&#x2F;错误, bp2的静态类型BASE* 没有f2的函数<br>dp1-&gt;f2(); &#x2F;&#x2F;虚调用：运行时调用D1：：f2();<br>dp1-&gt;func(10); &#x2F;&#x2F;静态绑定<br>dp2-&gt;func(10); &#x2F;&#x2F;静态绑定<br>dp2-&gt;f2(); &#x2F;&#x2F;虚调用：运行时调用D2：：f2();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### `public 、private、protected`</span><br><span class="line"></span><br><span class="line">- public ： 说明符之后的成员在整个程序内可被访问、public 成员定义了类的接口</span><br><span class="line"></span><br><span class="line">- private： 说明符之后的成员只能被类的成员函数访问、private部分封装了类的实现细节。</span><br><span class="line"></span><br><span class="line">  - 派生类不能访问基类的私有成员</span><br><span class="line"></span><br><span class="line">- protected：</span><br><span class="line"></span><br><span class="line">  - 受保护成员对于类的用户来说是不可访问的</span><br><span class="line">  - 受保护的成员对于派生类的成员和友元来说是可以访问的</span><br><span class="line">  - 派生类的成员和友元只能访问派生类对象中基类部分的受保护成员</span><br><span class="line"></span><br><span class="line">- 派生访问说明符（控制派生类的用户）（`用户、派生类的派生类`））对于基类成员的访问权限</span><br><span class="line"></span><br><span class="line">  - public ： 派生类的基类部分成员 遵循原来的访问说明符</span><br><span class="line"></span><br><span class="line">  - protected ： [基类](https://so.csdn.net/so/search?q=基类&amp;spm=1001.2101.3001.7020)的公有成员和保护成员都将成为派生类的保护成员，</span><br><span class="line"></span><br><span class="line">  - private ： 基类的所有成员都将成员派生类的私有成员</span><br><span class="line"></span><br><span class="line">  - | 特征             | 公有继承               | 保护继承               | 私有继承               |</span><br><span class="line">    | ---------------- | ---------------------- | ---------------------- | ---------------------- |</span><br><span class="line">    | 公有成员变成     | 派生类的公有成员       | 派生类的保护成员       | 派生类的私有成员       |</span><br><span class="line">    | 保护成员变成     | 派生类的保护成员       | 派生类的保护成员       | 派生类的私有成员       |</span><br><span class="line">    | 私有成员变成     | 只能通过基类的接口访问 | 只能通过基类的接口访问 | 只能通过基类的接口访问 |</span><br><span class="line">    | 能否隐式向上转换 | 是                     | 是（但只能在派生类中） | 否                     |</span><br><span class="line"></span><br><span class="line">## IO库</span><br><span class="line"></span><br><span class="line">#### IO类</span><br><span class="line"></span><br><span class="line">##### IO库类型和头文件</span><br><span class="line"></span><br><span class="line">| 头文件   | 类型                          |                  |</span><br><span class="line">| -------- | ----------------------------- | ---------------- |</span><br><span class="line">| iostream | istream，wistream             | 从流读取数据     |</span><br><span class="line">|          | ostream，wostream             | 向流写入数据     |</span><br><span class="line">| fstream  | ifstream，wifstream           | 从文件读取数据   |</span><br><span class="line">|          | ofstream，wofstream           | 向文件写入数据   |</span><br><span class="line">|          | fstream，wfstream             | 读写文件         |</span><br><span class="line">| sstream  | istringstream，wistringstream | 从string读取数据 |</span><br><span class="line">|          | ostringstream，wostringstream | 向string写入数据 |</span><br><span class="line">|          | stringstream，wstrignstream   | 读写string       |</span><br><span class="line"></span><br><span class="line">- **IO对象无拷贝或者赋值** --IO对象没有拷贝构造函数</span><br><span class="line">  - 不能拷贝IO对象，因此也不能将形参或返回类型设置为***流类型***</span><br><span class="line">  - 通常以引用方式传递和返回流</span><br><span class="line">  - 读写IO对象会改变其状态，传递和返回不能是const</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 条件状态</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  //strm 指代IO类型</span><br><span class="line">  strm::iostate // 与机器无关的类型，表达流状态的完整功能，有四个常量值*(IO对象有四个状态：)</span><br><span class="line">      strm::badbit //系统级错误，不可恢复</span><br><span class="line">      strm::eofbit //指出流达到了文件结束</span><br><span class="line">      //表示特定的错误</span><br><span class="line">      strm::failbit//c</span><br><span class="line">      strm::goodbit //有效状态， = !(badbit &amp; failbit &amp; eofbit)</span><br><span class="line">  //方法：</span><br><span class="line">      .clear();  //将所有条件状态复位，设置为有效状态</span><br><span class="line">  	.clear(flag); //接受strm::iostate的参数，将给flag复位</span><br><span class="line">  	.setstate(flag); //接受strm::iostate的参数，将给flag置位</span><br><span class="line">  	.rdstate();   //返回流s的条件状态;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="管理输出缓冲区"><a href="#管理输出缓冲区" class="headerlink" title="管理输出缓冲区"></a>管理输出缓冲区</h5><ul>
<li><p>缓冲机制：操作系统将程序的<strong>多个输出</strong>组合成单一的系统级写操作</p>
</li>
<li><p>缓冲刷新：</p>
<ul>
<li><p>程序正常结束：main函数的return操作，导致缓冲刷新</p>
</li>
<li><p>缓冲区满时，</p>
</li>
<li><p>操纵符： <code>endl</code>：换行并刷新缓冲区</p>
<pre><code>            `flush`：刷新缓冲区，不输出任何额外字符
    
            `ends`：插入空字符，刷新缓冲区
</code></pre>
</li>
<li><p><code>unitbuf</code>操纵符：指示流接下来的写操作都进行一次<code>flush</code>操作</p>
<ul>
<li><code>nounitbuf</code>： 回到正常的缓冲方式</li>
</ul>
</li>
<li><p>关联的输入输出流：<code>cin</code>和<code>cerr</code>都关联到<code>cout</code>，读<code>cin</code>和<code>cerr</code>都会导致<code>cout</code>的缓冲区刷新</p>
</li>
<li><p>当系统空闲时（还有种说法是长时间无输入时）缓冲区会自动刷新。lidapu</p>
</li>
</ul>
</li>
<li><p>关联</p>
<ul>
<li>&#96;&#96;&#96;c++<br>&#x2F;&#x2F;istream::tie()和tie(ostream * os)两个版本， 返回指向关联流的指针<br>cin.tie(&amp;cout);<br>ostream * os &#x3D; cin.tie(nullptr);  &#x2F;&#x2F;cin不再与其他流关联<br>cin.tie(cerr);<br>cin.tie(os);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 操纵符</span><br><span class="line"></span><br><span class="line">| 操纵符               | 说明                                             | I/O        |</span><br><span class="line">| -------------------- | ------------------------------------------------ | ---------- |</span><br><span class="line">| unitbuf              | 指示流接下来的写操作都进行一次`flush`操作        | 输出       |</span><br><span class="line">| nounitbuf            | 回到正常的缓冲方式                               | 输出       |</span><br><span class="line">| flush                | 刷新缓冲区，不输出任何额外字符                   | 输出       |</span><br><span class="line">| endl                 | 输出一个换行符并 刷新缓冲区                      | 输出       |</span><br><span class="line">| ends                 | 输出一个空字符， 刷新缓冲区                      | 输出       |</span><br><span class="line">| ws                   | 跳过输入的空格符                                 | 输入       |</span><br><span class="line">| dec                  | 格式化为十进制数值数据                           | 输入和输出 |</span><br><span class="line">| hex                  | 格式化为十六进制数值数据                         | 输入和输出 |</span><br><span class="line">| oct                  | 格式化为八进制数值数据                           | 输入和输出 |</span><br><span class="line">| —————————            | ————&lt;iomanip&gt;                                    | ——         |</span><br><span class="line">| setprecision(int p)  | 设置浮点数的精度位数                             | 输出       |</span><br><span class="line">| setbase(n)           | 设置整数的进制（n为 0，10，8，16）默认0 为十进制 | 输入和输出 |</span><br><span class="line">| setfil(char )        | 设置填充符(默认为空格)                           | 输出       |</span><br><span class="line">| setw(n)              | 设置域宽n                                        | 输出       |</span><br><span class="line">| setiosflags(flags)   | 设置指定状态标志，多个用&quot;&quot;分隔”                  | 输出和输入 |</span><br><span class="line">| resetiosflags(flags) | 清除指定状态标志，多个用&quot;&quot;分隔”                  | 输出和输入 |</span><br><span class="line"></span><br><span class="line">##### 操作符setiosflags(flags)和resetiosflags(flags)的部分状态标志</span><br><span class="line"></span><br><span class="line">- 状态标志在ios类中定义为枚举值，所以在引用这些值前要加上`ios::`</span><br><span class="line"></span><br><span class="line">| left       | 按域宽左对齐输出 |</span><br><span class="line">| ---------- | ---------------- |</span><br><span class="line">| right      | 按域宽右对齐输出 |</span><br><span class="line">| fixed      | 定点格式小数输出 |</span><br><span class="line">| scientific | 科学计数法输出   |</span><br><span class="line"></span><br><span class="line">另：借助&lt;bitset&gt;库，调用方式bitset&lt;len&gt;(num)，其中 len: 二进制输出的位数，输出二进制</span><br><span class="line"></span><br><span class="line">##### `cin.getline()`与 `getline()`</span><br><span class="line"></span><br><span class="line">- cin.getline()属于istream流，而getline()属于string流</span><br><span class="line"></span><br><span class="line">  - getline()</span><br><span class="line"></span><br><span class="line">    - 函数原型：istream&amp; getline ( istream &amp;is , string &amp;str , char delim );</span><br><span class="line">      is:istream类的输入流对象，譬如cin；</span><br><span class="line">      str:待输入的string对象，表示把从输入流读入的字符串存放在这个字符串中（可以自己随便命名，str什么的都可以）；</span><br><span class="line">      delim：表示遇到这个字符停止读入，在不设置的情况下系统默认该字符为&#x27;\n&#x27;，也就是回车换行符（遇到回车停止读入）。</span><br><span class="line"></span><br><span class="line">  - cin.getline(char ch[],size)是cin 的一个成员函数，定义在&lt;iostream&gt;中，用于输入行指定size的字符串，以enter结束。若输入长度超出size，则不再接受后续的输入。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">#### 文件输入输出</span><br><span class="line"></span><br><span class="line">`#include&lt;fstream&gt;` : `ifstream` : 读取给定文件，`ofstream` 写给定文件，`fstream`读写</span><br><span class="line"></span><br><span class="line">`fstream` 特有的操作</span><br><span class="line"></span><br><span class="line">| fstream fstrm；        | 默认构造函数，创建未绑定的文件流          |      |</span><br><span class="line">| ---------------------- | ----------------------------------------- | ---- |</span><br><span class="line">| **fstream fstrm(s);**  | string s \| char * s; 打开名为s的文件     |      |</span><br><span class="line">| fstream fstrm(s,mode); | 按指定格式打开文件                        |      |</span><br><span class="line">| fstrm.open(s);         | 打开文件s，并且文件与fstrm 绑定           |      |</span><br><span class="line">| fstrm.close();         | 关闭于文件s绑定的文件，返回void           |      |</span><br><span class="line">| fstrm.is_open();       | 返回于fstrm关联的文件是否成功打开且未关闭 |      |</span><br><span class="line"></span><br><span class="line">##### 使用文件流对象</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">ifstream in(ifile); //构造函数自动调用open函数，与ifile绑定；可以是string 、 char *</span><br><span class="line">ofstream out;</span><br><span class="line">out.open(&quot;**&quot;); // 如果调用open 失败（打开文件失败） failbit会被置位</span><br><span class="line">out.open(&quot;d&quot;); // 对已经打开的文件流调用open会失败，failbit会被置位，————</span><br><span class="line">if(out) // 判断是否打开成功</span><br><span class="line">   //fstream 对象被销毁时，close函数会被自动调用</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="文件模式（file-mode）"><a href="#文件模式（file-mode）" class="headerlink" title="文件模式（file mode）"></a>文件模式（file mode）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">in 		<span class="comment">//以读的方式打开</span></span><br><span class="line">out 	<span class="comment">//以写的方式打开</span></span><br><span class="line">app		<span class="comment">//追加方式，写操作都定位到文件末尾 ifstream 也能被设定为app模式，虽然没有用？</span></span><br><span class="line">ate		<span class="comment">//打开文件定位到文件末尾</span></span><br><span class="line">trunc   <span class="comment">//截断文件：会清空文件内容</span></span><br><span class="line">binary	<span class="comment">//二进制方式打开文件    </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//位于命名空间 ： fstream</span></span><br></pre></td></tr></table></figure>

<p>- </p>
<ul>
<li>制：<ul>
<li><code>ofstream | fstream</code> 才能设定为 <code>out</code> 模式， <code>ofstream</code>默认以out模式打开 fstream 以 <code>in | out</code> 模式打开</li>
<li><code>ifstream | fstream</code> 才能设定为 <code>in</code> 模式，<code>ifstream</code>默认以in模式打开</li>
<li>只有<code>out</code>被设定，才能设定位 <code>trunc</code>模式</li>
<li>只要没设定trunc，就能设定为app模式，<strong>app模式下，</strong>文件总是以输出方式被打开</li>
<li>默认情况下（没有显示指定trunc），out模式也会截断文件</li>
<li>ate 和 binary 可用于任何类型的文件流对象， 与<strong>其他文件模式组合使用</strong></li>
</ul>
</li>
</ul>
<p><strong><u><em>！</em></u><strong>保留被osftreamd打开的文件的</strong>唯一</strong>方法： 显<strong>示指定app模式或in模式</strong></p>
<h4 id="string-流"><a href="#string-流" class="headerlink" title="string 流"></a>string 流</h4><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>！<strong>可调用对象</strong>： 函数、 函数指针、<em><strong>lambda 表达式</strong></em>、 重载了函数调用符的类</p>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><em><strong>lambda 表达式</strong></em>： 可调用的代码单元， （未命名的内联函数）， 可以***<u>定义在函数内部</u>***</p>
<p>不具名function object，每个lambda表达式的类型都是<strong>独一无二的</strong>。</p>
<ul>
<li>必须使用**<a href="#%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E">尾置返回</a>**类型</li>
<li>可以忽略<a href="">参数列表</a>和返回类型，但是必须要有捕获列表和函数体<ul>
<li>忽略括号和参数列表： 等价于指定空参数列表；</li>
<li>忽略返回类型： 根据代码推断返回类型、 包含除return；外的任何语句 –&gt;返回 void;</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; <span class="keyword">return</span> type &#123;function body&#125;</span><br><span class="line"><span class="comment">//-capture list(捕获列表)：该lambda 所在的函数中定义的局部变量的列表</span></span><br><span class="line"><span class="comment">//- parameter list\ return type\function body 和和普通函数一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = []&#123;<span class="keyword">return</span> <span class="number">43</span>;&#125;;  <span class="comment">//f为可调用对象，返回43；</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>();</span><br></pre></td></tr></table></figure>

<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><ul>
<li><strong>lambda 不能使用默认参数</strong>，调用的实参数目永远等于形参数目</li>
</ul>
<h4 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h4><ul>
<li>通过将局部变量包含在捕获列表中来<strong>指明</strong>将会使用这些变量；<ul>
<li>值捕获：被捕获的变量的值是在<strong>lambda创建时拷贝</strong>， 而不是调用时捕获</li>
<li>引用捕获：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>捕获列表</th>
<th>例子</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[ ]</td>
<td>[ ]</td>
<td>空捕获列表，不使用所在函数的变量</td>
</tr>
<tr>
<td>[names]</td>
<td>[va,vb,vc,&amp;vd]</td>
<td>names是由逗号分隔的名字列表，&amp;前缀的为引用捕获方式</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>[&amp;]</td>
<td>隐式捕获列表，函数中所有变量采用值捕获方式</td>
</tr>
<tr>
<td>[&#x3D;]</td>
<td>[&#x3D;]</td>
<td>隐式捕获列表，函数中所有变量采用引用捕获方式</td>
</tr>
<tr>
<td>[&amp;, identifier_list]</td>
<td>[&amp;,va,vb,vc ]</td>
<td>identifier_list中的名字都为值捕获、其余为引用捕获</td>
</tr>
<tr>
<td>[&#x3D;, identifier_list]</td>
<td>[&#x3D;,&amp;va,&amp;vb,&amp;vc ]</td>
<td>identifier_list中的名字都为引用捕获、其余为值捕获</td>
</tr>
</tbody></table>
<h4 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变lambda</h4><p><strong>mutable，则会使得该“值捕获变量”的值，可以在被捕获的值的基础上进行变化。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto f=[v1](A a) mutable -&gt; B&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [t]()&#123; t = t + <span class="number">1</span>;  <span class="keyword">return</span> t; &#125;;  <span class="comment">// 报错：值捕获的非可变lambda 不能修改值</span></span><br><span class="line">/</span><br><span class="line"><span class="keyword">auto</span> f = [t]()<span class="keyword">mutable</span> &#123; t = t + <span class="number">1</span>;  <span class="keyword">return</span> t; &#125;;</span><br><span class="line">t = <span class="number">0</span>;  <span class="comment">// 不影响按值捕获的lambda 中的t</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; <span class="built_in">f</span>(); <span class="comment">// 输出：10 11;</span></span><br></pre></td></tr></table></figure>

<h4 id="指定返回类型"><a href="#指定返回类型" class="headerlink" title="指定返回类型"></a>指定返回类型</h4><ul>
<li>函数体是单一的return 语句; 无须指定返回类型; </li>
<li>不是单一的return语句： 推断返回类型为void； 需指定返回类型</li>
</ul>
<blockquote>
<p>尾置返回类型：<a name  ="尾置返回"></a></p>
<p>任何函数的能定义为尾置返回类型</p>
<p><code>auto func(int i) -&gt; int (*)[10];</code>  返回一个指针， 指向含有10个整数的数组</p>
</blockquote>
<h2 id="Strings-library"><a href="#Strings-library" class="headerlink" title="Strings library"></a><strong><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/string">Strings library</a></strong></h2><p><code>#include&lt;string&gt;</code></p>
<h5 id="定义和初始化-std-basic-string-basic-string-cppreference-com"><a href="#定义和初始化-std-basic-string-basic-string-cppreference-com" class="headerlink" title="[定义和初始化](std::basic_string::basic_string - cppreference.com)"></a>[定义和初始化](<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/string/basic_string/basic_string">std::basic_string::basic_string - cppreference.com</a>)</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">std::string <span class="type">const</span> <span class="title">other</span><span class="params">(<span class="string">&quot;Exemplary&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">string temp;		<span class="comment">//默认构造函数，空字符串、未指定容量大小</span></span><br><span class="line"><span class="function">string <span class="title">temp</span><span class="params">(other, <span class="number">0</span>, other.length()<span class="number">-1</span>)</span> <span class="comment">//使用other的子字符串[0,other.length-1)构造字符串</span></span></span><br><span class="line"><span class="function">string <span class="title">temp</span><span class="params">(other,<span class="number">8</span>)</span></span>;   				<span class="comment">//使用other所指向字符串的第一个计数字符构造字符串。s可以包含空字符。字符串的长度是count。如果[s, s + count)不是有效范围，则行为未定义。	</span></span><br><span class="line"><span class="function">string <span class="title">temp</span><span class="params">(<span class="string">&quot;C-style string&quot;</span>, <span class="number">7</span>)</span></span>;		<span class="comment">//使用字符串的副本构造字符串，长度为7</span></span><br><span class="line"><span class="function">string <span class="title">temp</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;v&#x27;</span>)</span></span>; <span class="comment">//使用字符“v”的10个副本构造字符串</span></span><br></pre></td></tr></table></figure>

<h5 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h5><ul>
<li><em>读写string对象</em>：<code>os &lt;&lt; S</code>,<code>is &gt;&gt; S</code> ， 忽略空白（空格、制表符、换行）从第一个字符到下一处空白，返回iostream对象</li>
<li><em>读取整行</em>：<code>getline(istream is, string s)</code> 从is读取一行赋值给s，返回s<ul>
<li>从输入流中读取内容，直到遇到换行符（<em><strong>换行符也被读取</strong></em>），然后赋值给string对象（<em><strong>不存换行符</strong></em>）。</li>
</ul>
</li>
<li>empty(), size()(返回无符号整型的长度)</li>
<li><em>比较string对象</em><ul>
<li>相等性运算符 <code> ==\!=</code>: 相等意味着两字符串长度和字符全都相同</li>
<li>关系运算符 <code>&lt;  &gt; &lt;= &gt;=  </code>:<ul>
<li>两字符串长度不同，短字符串<code>S1</code>是长字符串<code>S2</code>的子串：<code>S1</code> 小于 <code>S2</code></li>
<li>依照字典顺序（<em><strong>大小写敏感</strong></em>）比较第一个相异字符的结果</li>
</ul>
</li>
</ul>
</li>
<li>赋值： &#x3D; </li>
<li>重载了 <code>+</code>操作： 两个string对象相加，与字面值相加，返回string对象</li>
</ul>
<h5 id="string-字符串的增删改查"><a href="#string-字符串的增删改查" class="headerlink" title="string 字符串的增删改查"></a>string 字符串的增删改查</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">// 在指定位置插入</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">	<span class="comment">//从index开始移除min(count,size() - index)的字符</span></span><br><span class="line"><span class="function">basic_string&amp; <span class="title">erase</span><span class="params">( size_type index = <span class="number">0</span>, size_type count = npos)</span></span>; </span><br><span class="line">	<span class="comment">//删除[first, last]范围内的字符。</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator first, iterator last )</span></span>;</span><br><span class="line"><span class="comment">//提取子串</span></span><br><span class="line"><span class="function">string <span class="title">substr</span> <span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = npos)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//find() 函数用于在 string 字符串中查找子字符串出现的位置,第二个参数为开始查找的位置（下标）</span></span><br><span class="line"><span class="built_in">rfind</span>(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>); <span class="comment">//不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处</span></span><br><span class="line"><span class="built_in">find_first_of</span>(<span class="type">const</span> string&amp; str); <span class="comment">//函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assign</span>();  <span class="comment">//替换字符串的内容</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="operator-x3D"><a href="#operator-x3D" class="headerlink" title="operator+&#x3D;"></a>operator+&#x3D;</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">str += <span class="string">&quot;This&quot;</span>;  <span class="comment">// std::cout &lt;&lt; std::quoted(str) &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//“const stirng”</span></span><br><span class="line">str += std::<span class="built_in">string</span>(<span class="string">&quot; is &quot;</span>);</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">quoted</span>(str) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// char</span></span><br><span class="line">str += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">quoted</span>(str) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// char[]</span></span><br><span class="line">str += &#123;<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">quoted</span>(str) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// float </span></span><br><span class="line">str += <span class="number">76.85</span>; <span class="comment">// equivalent to str += static_cast&lt;char&gt;(76.85), might not be the intent</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">quoted</span>(str) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;3[z]2[2[y]pq4[2[jk]e1[f]]]ef&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="Algorithm-library"><a href="#Algorithm-library" class="headerlink" title="Algorithm library"></a><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm">Algorithm library</a></h2><p><code>#include&lt;algorithm&gt;</code></p>
<h4 id="Sorting-Operations"><a href="#Sorting-Operations" class="headerlink" title="Sorting Operations"></a>Sorting Operations</h4><h5 id="std-is-sorted"><a href="#std-is-sorted" class="headerlink" title="std::is_sorted"></a>std::is_sorted</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查范围[first, last)内的元素是否按非降序排序。</span></span><br><span class="line"><span class="comment">/*参数：first,last - 要检查的范围[first.last)*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_sorted</span><span class="params">( ForwardIt first, ForwardIt last )</span></span>;</span><br><span class="line"><span class="comment">/*参数： comp 比较函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_sorted</span><span class="params">( ForwardIt first, ForwardIt last, Compare comp )</span></span>;</span><br><span class="line"><span class="comment">//比较函数形如：</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Type1 &amp;a, <span class="type">const</span> Type2 &amp;b)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="std-sort"><a href="#std-sort" class="headerlink" title="std::sort"></a>std::sort</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对[first, last)范围内的元素按非降序排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last)</span></span>;</span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br><span class="line"><span class="comment">//比较函数形如：</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Type1 &amp;a, <span class="type">const</span> Type2 &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="std-partial-sort"><a href="#std-partial-sort" class="headerlink" title="std::partial_sort"></a>std::partial_sort</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//partial_sort() 会将 [first, last) 范围内最小（或最大）的 middle-first 个元素移动到 [first, middle) 区域中，并对这部分元素做升序（或降序）排序。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partial_sort</span><span class="params">( RandomIt first, RandomIt middle, RandomIt last )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partial_sort</span><span class="params">( RandomIt first, RandomIt middle, RandomIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                   Compare comp )</span></span>;</span><br><span class="line"><span class="comment">//比较函数形如：</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Type1 &amp;a, <span class="type">const</span> Type2 &amp;b)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="std-stable-sort"><a href="#std-stable-sort" class="headerlink" title="std::stable_sort"></a>std::stable_sort</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//稳定排序，对[first, last)范围内的元素按非降序排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stable_sort</span><span class="params">( RandomIt first, RandomIt last )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stable_sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br><span class="line"><span class="comment">//比较函数对象</span></span><br><span class="line"><span class="comment">//比较函数形如：</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Type1 &amp;a, <span class="type">const</span> Type2 &amp;b)</span></span>;</span><br><span class="line"><span class="comment">// 比较函数为真时， a 排在 b 前面</span></span><br><span class="line">/比较函数对象(即一个满足Compare要求的对象)，如果第一个参数小于(即在第二个参数之前排序)则返回<span class="literal">true</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="std-reverse"><a href="#std-reverse" class="headerlink" title="std::reverse"></a>std::reverse</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：first,last - 反转元素的范围[first.last)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">reverse</span><span class="params">( BidirIt first, BidirIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="std：：accumulate"><a href="#std：：accumulate" class="headerlink" title="std：：accumulate"></a>std：：accumulate</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">( InputIt first, InputIt last, T init )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> T, <span class="keyword">class</span> BinaryOperation &gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">( InputIt first, InputIt last, T init,</span></span></span><br><span class="line"><span class="params"><span class="function">              BinaryOperation op )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init	-	initial value of the sum</span></span><br></pre></td></tr></table></figure>



<h4 id="Binary-search-operations"><a href="#Binary-search-operations" class="headerlink" title="Binary search operations"></a>Binary search operations</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个指向[first, last]范围内不小于(即大于或等于)值的第一个元素的迭代器，如果没有找到这样的元素则指向last。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;\</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个指向范围[first, last]中大于value的第一个元素的迭代器，如果没有找到这样的元素则指向last</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"><span class="comment">//查找[first, last)区域中第一个不符合 comp 规则的元素  val 作为comp的第二个参数</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="std-next-permutation"><a href="#std-next-permutation" class="headerlink" title="std::next_permutation"></a>std::next_permutation</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function">          <span class="type">bool</span> <span class="title">next_permutation</span><span class="params">( BidirIt first, BidirIt last )</span></span>;</span><br><span class="line"><span class="comment">//将范围[first, last]排列为下一个排列，其中所有排列的集合根据运算符&amp;lt按字典顺序排序;或comp.如果存在这样的&quot;next permutation&quot;则返回true;否则，将范围转换为按字典顺序优先排列(就像通过std::sort(first, last, comp))并返回false。</span></span><br></pre></td></tr></table></figure>

<h4 id="std-max"><a href="#std-max" class="headerlink" title="std::max"></a>std::max</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">max</span><span class="params">( <span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">max</span><span class="params">( <span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, Compare comp )</span></span>;</span><br><span class="line"><span class="comment">// comp:比较函数对象(即一个满足Compare要求的对象)，当a小于b时返回true。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>算法实现- <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/">下一个排列 </a></p>
<ul>
<li><p>&#96;&#96;&#96;c++<br>&#x2F;&#x2F;1.首先从后向前查找第一个顺序对 (i,i+1)(i,i+1)，满足 a[i] &lt; a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n)[i+1,n) 必然是下降序列。</p>
<p>&#x2F;&#x2F;2.如果找到了顺序对，那么在区间 [i+1,n)[i+1,n) 中从后向前查找第一个元素 j 满足 a[j] &gt; a[i]。这样「较大数」即为 a[j]。</p>
<p>&#x2F;&#x2F;3.交换 a[i]a[i] 与 a[j]a[j]，此时可以证明区间 [i+1,n)[i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n)[i+1,n) 使其变为升序，而无需对该区间进行排序。<br>class Solution {<br>public:<br>void nextPermutation(vector<int>&amp; nums) {<br>    int i &#x3D; nums.size() - 2;<br>    while(i &gt;&#x3D; 0 &amp;&amp; nums[i] &gt;&#x3D; nums[i + 1]) {<br>        i–;<br>    }<br>    if(i &gt;&#x3D; 0) {<br>        int j &#x3D; nums.size() - 1;<br>        while(j &gt; i &amp;&amp; nums[j] &lt;&#x3D; nums[i]) {<br>            j–;<br>        }<br>        swap(nums[i],nums[j]);<br>    }<br>    reverse(nums.begin() + i + 1,nums.end());<br>}<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## **[General utilities library](https://en.cppreference.com/w/cpp/utility#General-purpose_utilities)**</span><br><span class="line"></span><br><span class="line">`#include&lt;utility&gt;`</span><br><span class="line"></span><br><span class="line">#### Pair</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">/*</span><br><span class="line">参数：T1是第一个值的数据类型，T2是第二个值的数据类型。</span><br><span class="line">功能：pair将一对值(T1和T2)组合成一个值，</span><br><span class="line">这一对值可以具有不同的数据类型（T1和T2），</span><br><span class="line">两个值可以分别**用pair的两个公有函数first和second访问。</span><br><span class="line">Member name | Type</span><br><span class="line">first		| T1</span><br><span class="line">second		| T2</span><br><span class="line">*/</span><br><span class="line">template&lt;</span><br><span class="line">  class T1,</span><br><span class="line">  class T2</span><br><span class="line">\&gt; struct pair;</span><br><span class="line"></span><br><span class="line">//创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span><br><span class="line">pair&lt;T1, T2&gt; p1;            </span><br><span class="line">//创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。 </span><br><span class="line">pair&lt;T1, T2&gt; p1(v1, v2);    </span><br><span class="line">//以v1和v2的值创建一个新的pair对象，其元素类型分别是t和u的类型,返回一个pair对象</span><br><span class="line">emplate&lt; class T1, class T2 &gt;</span><br><span class="line">std::pair&lt;T1,T2&gt; make_pair(T1 t, T2 u);         </span><br><span class="line">//交换内容 first 与other.fist; second 与other.second交换</span><br><span class="line">void swap(pair&amp; other)  </span><br><span class="line"></span><br><span class="line">//比较</span><br><span class="line">p1 &lt; p2;                    </span><br><span class="line">// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span><br><span class="line">p1 == p2；                  </span><br><span class="line"> // 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="字符处理库"><a href="#字符处理库" class="headerlink" title="字符处理库"></a>字符处理库</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*功能一：字符测试</span></span><br><span class="line"><span class="comment">1&gt; 函数原型均为int isxxxx(int)</span></span><br><span class="line"><span class="comment">2&gt; 参数为int, 任何实参均被提升成整型</span></span><br><span class="line"><span class="comment">3&gt; 只能正确处理处于[0, 127]之间的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">isalnum</span>()  <span class="comment">//如果参数是字母数字，即字母或者数字，函数返回true</span></span><br><span class="line"><span class="built_in">isalpha</span>()  <span class="comment">//如果参数是字母，函数返回true</span></span><br><span class="line"><span class="built_in">iscntrl</span>()  <span class="comment">//如果参数是控制字符，函数返回true</span></span><br><span class="line"><span class="built_in">isdigit</span>()  <span class="comment">//如果参数是数字（0－9），函数返回true</span></span><br><span class="line"><span class="built_in">isgraph</span>()  <span class="comment">//如果参数是除空格之外的打印字符，函数返回true</span></span><br><span class="line"><span class="built_in">islower</span>()  <span class="comment">//如果参数是小写字母，函数返回true</span></span><br><span class="line"><span class="built_in">isprint</span>()  <span class="comment">//如果参数是打印字符（包括空格），函数返回true</span></span><br><span class="line"><span class="built_in">ispunct</span>()  <span class="comment">//如果参数是标点符号，函数返回true</span></span><br><span class="line"><span class="built_in">isspace</span>()  <span class="comment">//如果参数是标准空白字符，如空格、换行符、水平或垂直制表符，函数返回true</span></span><br><span class="line"><span class="built_in">isupper</span>()  <span class="comment">//如果参数是大写字母，函数返回true</span></span><br><span class="line"><span class="built_in">isxdigit</span>() <span class="comment">//如果参数是十六进制数字，即0－9、a－f、A－F，函数返回true</span></span><br><span class="line"><span class="comment">/*功能二：字符映射</span></span><br><span class="line"><span class="comment">1&gt; 函数原型为int toxxxx(int)</span></span><br><span class="line"><span class="comment">2&gt; 对参数进行检测, 若符合范围则转换, 否则不变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">tolower</span>()  <span class="comment">//如果参数是大写字符，返回其小写，否则返回该参数</span></span><br><span class="line"><span class="built_in">toupper</span>()  <span class="comment">//如果参数是小写字符，返回其大写，否则返回该参数</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://blog.wangeyi.ink">We_</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.wangeyi.ink/2022/06/13/C-%E7%AC%94%E8%AE%B0/">http://blog.wangeyi.ink/2022/06/13/C-%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.wangeyi.ink" target="_blank">We</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="http://picgo.wangeyi.ink/pexels-messala-ciulla-1162643.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="http://picgo.wangeyi.ink/pexels-kush-kaushik-2078126.jpg" onerror="onerror=null;src='/img/pexels-wolfram-k-804166.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构与算法</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/13/STL%E6%A0%87%E5%87%86%E5%BA%93-%E6%9B%B4%E6%96%B0%E4%B8%AD/"><img class="next-cover" src="/img/pexels-alex-andrews-1983032.jpg" onerror="onerror=null;src='/img/pexels-wolfram-k-804166.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">STL标准库</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/me.jpg'" alt="avatar"/></div><div class="author-info__name">We_</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lasrd"><i class="fab fa-github"></i><span>——</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/larsd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/18259572395@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哈哈哈</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA"><span class="toc-number">1.</span> <span class="toc-text">内存区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D"><span class="toc-number">1.2.</span> <span class="toc-text">地址分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%AE%8F"><span class="toc-number">1.3.</span> <span class="toc-text">参数宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">1.4.</span> <span class="toc-text">条件编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">#运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="toc-number">1.6.</span> <span class="toc-text">##运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">1.7.</span> <span class="toc-text">预定义宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Language"><span class="toc-number">2.</span> <span class="toc-text">Language</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Keywords-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.</span> <span class="toc-text">Keywords 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#const-volatile-mutable"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">const volatile mutable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#using"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">using</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">static</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fundamental-types-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">Fundamental types 基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.3.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%9A%E6%A0%B9%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%E5%B0%86%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%BB%9F%E4%B8%80%E5%90%8E%E5%9C%A8%E8%AE%A1%E7%AE%97%EF%BC%8C%E2%80%93%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%87%8F%E5%B0%91%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1"><span class="toc-number">2.2.3.0.1.</span> <span class="toc-text">隐式转换：根据类型转换规则将运算对象类型统一后在计算，–尽可能减少精度损失</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2%EF%BC%9A%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2cast"><span class="toc-number">2.2.3.0.2.</span> <span class="toc-text">显示转换：强制类型转换cast</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.4.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.5.</span> <span class="toc-text">复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">2.2.5.0.1.</span> <span class="toc-text">引用：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">2.2.5.0.2.</span> <span class="toc-text">指针：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.2.5.0.3.</span> <span class="toc-text">复合类型的声明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F-C-11"><span class="toc-number">2.2.5.0.4.</span> <span class="toc-text">常量表达式 -C++11</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.6.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">2.2.6.0.1.</span> <span class="toc-text">性质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.7.</span> <span class="toc-text">处理类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.2.7.0.1.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#decltype-%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6%EF%BC%88C-11%EF%BC%89"><span class="toc-number">2.2.7.0.2.</span> <span class="toc-text">decltype 类型指示符（C++11）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E6%BB%A1%E8%B6%B3%E5%8F%B3%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">2.2.8.</span> <span class="toc-text">赋值运算符满足右结合律</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.9.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.10.</span> <span class="toc-text">递增和递减运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.11.</span> <span class="toc-text">成员访问运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.12.</span> <span class="toc-text">条件运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.13.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.14.</span> <span class="toc-text">sizeof 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%81%94%E5%90%88%E4%BD%93%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.2.14.1.</span> <span class="toc-text">枚举类型、联合体、结构体</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.15.</span> <span class="toc-text">逗号运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.2.16.</span> <span class="toc-text">运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Statement%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.3.</span> <span class="toc-text">Statement语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.3.1.</span> <span class="toc-text">简单语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.3.2.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.3.3.</span> <span class="toc-text">迭代语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">Function 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">2.4.1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">2.4.2.</span> <span class="toc-text">参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-number">2.4.2.0.1.</span> <span class="toc-text">占位参数：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">2.4.2.0.2.</span> <span class="toc-text">引用传递：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">2.4.2.0.3.</span> <span class="toc-text">值传递：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#const-%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">2.4.2.0.4.</span> <span class="toc-text">const 形参和实参</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn"><span class="toc-number">2.4.3.</span> <span class="toc-text">返回类型和return</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">无返回值函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">有返回值函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">尾置返回类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.4.</span> <span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8Cconst"><span class="toc-number">2.4.4.0.1.</span> <span class="toc-text">重载和const</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#const-cast-%E5%92%8C%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.4.0.2.</span> <span class="toc-text">const_cast 和函数重载</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BB%93%E6%9E%9C"><span class="toc-number">2.4.4.0.3.</span> <span class="toc-text">调用重载函数的三种结果</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.4.4.0.4.</span> <span class="toc-text">重载与作用域</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-number">2.4.4.0.5.</span> <span class="toc-text">默认实参</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.4.0.6.</span> <span class="toc-text">内联函数和constexpr函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-number">2.4.5.</span> <span class="toc-text">函数匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.4.5.0.1.</span> <span class="toc-text">实参类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.4.6.</span> <span class="toc-text">函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.4.6.0.1.</span> <span class="toc-text">使用函数指针</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Classes-%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">Classes 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">2.5.2.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.3.</span> <span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.4.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">基本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">默认构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.4.3.</span> <span class="toc-text">委托构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.4.4.</span> <span class="toc-text">隐式的类类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#explicit%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.4.5.</span> <span class="toc-text">explicit构造函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E6%9E%90%E6%9E%84"><span class="toc-number">2.5.5.</span> <span class="toc-text">拷贝、赋值、析构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">2.5.6.</span> <span class="toc-text">访问控制与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">2.5.6.1.</span> <span class="toc-text">友元</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.6.2.</span> <span class="toc-text">重载成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98-mutable"><span class="toc-number">2.5.6.3.</span> <span class="toc-text">可变数据成员 mutable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">2.5.6.4.</span> <span class="toc-text">类数据成员的初始值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.6.5.</span> <span class="toc-text">类类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.5.7.</span> <span class="toc-text">类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%A7%8D%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E5%90%8D%E5%AD%97"><span class="toc-number">2.5.7.1.</span> <span class="toc-text">只适用于成员函数种的使用的名字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%90%8D%E5%AD%97"><span class="toc-number">2.5.7.2.</span> <span class="toc-text">声明中使用的名字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%90%8D%E8%A6%81%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="toc-number">2.5.7.3.</span> <span class="toc-text">类型名要特殊处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-number">2.5.8.</span> <span class="toc-text">聚合类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">2.5.8.1.</span> <span class="toc-text">使用静态成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.5.8.2.</span> <span class="toc-text">静态成员的类内初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.8.3.</span> <span class="toc-text">静态成员与普通成员的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.0.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.0.2.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shared-ptr%E7%B1%BB"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">shared_ptr类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.2.1.1.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#make-shared"><span class="toc-number">3.0.2.1.2.</span> <span class="toc-text">make_shared</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">3.0.2.1.3.</span> <span class="toc-text">拷贝和赋值</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-number">3.0.2.2.</span> <span class="toc-text">直接管理内存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr"><span class="toc-number">3.0.3.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%BA%8E%E9%94%80%E6%AF%81"><span class="toc-number">4.0.1.</span> <span class="toc-text">拷贝、赋值于销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">4.0.1.1.1.</span> <span class="toc-text">调用拷贝构造函数的三种情况:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">拷贝赋值运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.0.1.3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x3D-default"><span class="toc-number">4.0.1.4.</span> <span class="toc-text">&#x3D; default</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.0.1.5.</span> <span class="toc-text">阻止拷贝</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="toc-number">4.0.2.</span> <span class="toc-text">对象移动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.0.2.2.</span> <span class="toc-text">重载输入输出运算符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">定义基类和派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB"><span class="toc-number">5.2.1.</span> <span class="toc-text">基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">5.2.2.</span> <span class="toc-text">派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%B4%BE%E7%94%9F%E5%88%97%E8%A1%A8%EF%BC%9A"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">类派生列表：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">派生类中虚函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">向基类的类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">5.2.2.4.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">5.2.2.5.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">5.2.2.6.</span> <span class="toc-text">声明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">5.2.3.</span> <span class="toc-text">类型转换与继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">静态类型动态类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82-1"><span class="toc-number">5.2.4.</span> <span class="toc-text">默认实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%81%BF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.5.</span> <span class="toc-text">回避虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">5.2.6.</span> <span class="toc-text">抽象类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.3.</span> <span class="toc-text">继承中的类作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">5.3.1.</span> <span class="toc-text">名字查找与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.3.2.</span> <span class="toc-text">虚函数与作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">管理输出缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F%EF%BC%88file-mode%EF%BC%89"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">文件模式（file mode）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string-%E6%B5%81"><span class="toc-number">5.3.3.</span> <span class="toc-text">string 流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">6.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">6.0.2.</span> <span class="toc-text">传递参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="toc-number">6.0.3.</span> <span class="toc-text">捕获列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98lambda"><span class="toc-number">6.0.4.</span> <span class="toc-text">可变lambda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.0.5.</span> <span class="toc-text">指定返回类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Strings-library"><span class="toc-number">7.</span> <span class="toc-text">Strings library</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-std-basic-string-basic-string-cppreference-com"><span class="toc-number">7.0.0.1.</span> <span class="toc-text">[定义和初始化](std::basic_string::basic_string - cppreference.com)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">7.0.0.2.</span> <span class="toc-text">string对象上的操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">7.0.0.3.</span> <span class="toc-text">string 字符串的增删改查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#operator-x3D"><span class="toc-number">7.0.0.4.</span> <span class="toc-text">operator+&#x3D;</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Algorithm-library"><span class="toc-number">8.</span> <span class="toc-text">Algorithm library</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Sorting-Operations"><span class="toc-number">8.0.1.</span> <span class="toc-text">Sorting Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#std-is-sorted"><span class="toc-number">8.0.1.1.</span> <span class="toc-text">std::is_sorted</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#std-sort"><span class="toc-number">8.0.1.2.</span> <span class="toc-text">std::sort</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#std-partial-sort"><span class="toc-number">8.0.1.3.</span> <span class="toc-text">std::partial_sort</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#std-stable-sort"><span class="toc-number">8.0.1.4.</span> <span class="toc-text">std::stable_sort</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-reverse"><span class="toc-number">8.0.2.</span> <span class="toc-text">std::reverse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std%EF%BC%9A%EF%BC%9Aaccumulate"><span class="toc-number">8.0.3.</span> <span class="toc-text">std：：accumulate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-search-operations"><span class="toc-number">8.0.4.</span> <span class="toc-text">Binary search operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-next-permutation"><span class="toc-number">8.0.5.</span> <span class="toc-text">std::next_permutation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-max"><span class="toc-number">8.0.6.</span> <span class="toc-text">std::max</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E5%BA%93"><span class="toc-number">9.</span> <span class="toc-text">字符处理库</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><img src="/img/pexels-balamurugan-anbazhagan-763103.jpg" onerror="this.onerror=null;this.src='/img/pexels-wolfram-k-804166.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/2022/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2022-08-30T07:46:29.000Z" title="发表于 2022-08-30 15:46:29">2022-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/25/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" title="计网笔记"><img src="/img/pexels-mustafa-ezz-590697.jpg" onerror="this.onerror=null;this.src='/img/pexels-wolfram-k-804166.jpg'" alt="计网笔记"/></a><div class="content"><a class="title" href="/2022/08/25/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" title="计网笔记">计网笔记</a><time datetime="2022-08-25T12:47:37.000Z" title="发表于 2022-08-25 20:47:37">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" title="计算机网络之性能指标"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/pexels-wolfram-k-804166.jpg'" alt="计算机网络之性能指标"/></a><div class="content"><a class="title" href="/2022/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" title="计算机网络之性能指标">计算机网络之性能指标</a><time datetime="2022-08-25T12:11:03.000Z" title="发表于 2022-08-25 20:11:03">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/22/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="文件管理"><img src="http://picgo.wangeyi.ink/老人.png" onerror="this.onerror=null;this.src='/img/pexels-wolfram-k-804166.jpg'" alt="文件管理"/></a><div class="content"><a class="title" href="/2022/08/22/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="文件管理">文件管理</a><time datetime="2022-08-22T08:02:10.000Z" title="发表于 2022-08-22 16:02:10">2022-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/21/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="智能指针"><img src="http://picgo.wangeyi.ink/老人.png" onerror="this.onerror=null;this.src='/img/pexels-wolfram-k-804166.jpg'" alt="智能指针"/></a><div class="content"><a class="title" href="/2022/08/21/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="智能指针">智能指针</a><time datetime="2022-08-21T12:11:27.000Z" title="发表于 2022-08-21 20:11:27">2022-08-21</time></div></div></div></div></div></div></main><footer id="footer" style="background: balck"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By We_</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>