<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构与算法 | We</title><meta name="author" content="We_"><meta name="copyright" content="We_"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="数据结构与算法">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://blog.wangeyi.ink/2022/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="We">
<meta property="og:description" content="数据结构与算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.wangeyi.ink/img/pexels-balamurugan-anbazhagan-763103.jpg">
<meta property="article:published_time" content="2022-06-19T09:01:22.000Z">
<meta property="article:modified_time" content="2022-07-07T09:29:19.617Z">
<meta property="article:author" content="We_">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.wangeyi.ink/img/pexels-balamurugan-anbazhagan-763103.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.wangeyi.ink/2022/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-07-07 17:29:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="We" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.jpg" onerror="onerror=null;src='/img/me.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/run/"><i class="fa-fw fas fa-heart"></i><span> Run</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/pexels-balamurugan-anbazhagan-763103.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">We</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/run/"><i class="fa-fw fas fa-heart"></i><span> Run</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-19T09:01:22.000Z" title="发表于 2022-06-19 17:01:22">2022-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-07T09:29:19.617Z" title="更新于 2022-07-07 17:29:19">2022-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><h5 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h5><ul>
<li>栈 -后进先出（<strong>LIFO</strong>）<ul>
<li>栈下溢：对空栈进行弹出操作</li>
<li>栈上溢：栈顶超出集容量<ul>
<li><a href="#%E5%8D%95%E8%B0%83%E6%A0%88">单调栈</a></li>
</ul>
</li>
</ul>
</li>
<li>队列-先进先出（<strong>FIFO</strong>）<ul>
<li><a href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">单调队列</a></li>
</ul>
</li>
</ul>
<p><code>std::stack</code>、<code>std:: queue</code>  <!--详见STL.md--> </p>
<p><em><strong>例：</strong></em> 225. 用队列实现栈、 232. 用栈实现队列</p>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><ul>
<li>单向、双向、循环、非循环</li>
<li>哨兵：简化边界条件的处理： <ul>
<li>设置哨兵 <code>L</code>对于链表中指向<code>nullptr</code>的指针，都以指向 <code>L</code>取代，<code>L</code>的next 指向头节点</li>
</ul>
</li>
</ul>
<p><code>std::List</code><!--详见STL.md--> </p>
<p><em><strong>例：</strong></em>设计链表</p>
<p>例： 相交链表： 双指针</p>
<h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><ul>
<li>（Hash table 哈希表）：根据关键码值(Key value)而直接进行访问的数据结构</li>
</ul>
<h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p><strong>直接寻址法</strong>：<em>取关键字或关键字的某个线性函数值为散列地址。</em></p>
<p>数字分析法：<em>通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</em></p>
<p><strong>平方取中法</strong>：<em>当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</em></p>
<p><strong>取随机数法</strong>：<em>使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</em></p>
<p><strong>除留取余法</strong>：<em>取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。</em></p>
<h5 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h5><h6 id="链接法"><a href="#链接法" class="headerlink" title="链接法"></a>链接法</h6><p><strong>基本思想:</strong> </p>
<ul>
<li>将所有哈希地址为<code>i</code>的元素构成一个称为同义词链的链表，并将链表的头指针存在哈希表的第<code>i</code>个单元中，同义词链表可以是单链表，也可以是双链表</li>
<li>查找、插入和删除主要在同义词链中进行。适用于经常进行插入和删除的情况。</li>
</ul>
<p><img src="/223_a.gif"></p>
<p><strong>代码实现：<a href="#%E9%93%BE%E6%8E%A5%E6%B3%95">这里</a></strong></p>
<p><code>std::unordered_map</code>、<code>std::unordered_set</code> <!--详见STL--></p>
<p><em><strong>例</strong></em>： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-hashset/">设计哈希集合</a>、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-hashmap">设计哈希映射</a></p>
<h4 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h5><p>递归，<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3">迭代</a>, <a href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</a></p>
<h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><ul>
<li>一颗二叉树只有度为0的结点和度为2的结点，且度为0 的结点都在同一层上</li>
</ul>
<h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><ul>
<li>在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h 层，则该层包含 1~ 2^h -1个节点。</li>
<li>用数组存完全二叉树时，不会浪费空间</li>
</ul>
<h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>二叉搜索树是一种节点值之间具有一定数量级次序的二叉树，对于任意树节点：</p>
<ul>
<li>若其左子树存在，则其左子树中的每个节点值都不大于该节点值</li>
<li>若其右子树存在，则其右子树中的每个节点值都不小于该节点值</li>
</ul>
<h6 id="动态集合的操作"><a href="#动态集合的操作" class="headerlink" title="动态集合的操作"></a>动态集合的操作</h6><p><em>查询、插入和删除、构建</em></p>
<h6 id="查询-代码"><a href="#查询-代码" class="headerlink" title="查询-代码"></a>查询-<a href="#binaryseachtree">代码</a></h6><p>关键字K：从根结点开始，比较K和结点的值，k小于x：在左子树中查找，k大于x：在右子树中查找	</p>
<ul>
<li>二叉搜索树的查询复杂度为 <code>O(logn)~o(n)</code><em>完全二叉树和每层只有一个结点两种情况</em></li>
</ul>
<h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><p>比较元素值大小，迭代查找左右子树，直到找到子节点为空，插入相应位置</p>
<h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><ul>
<li>删除的叶子结点、节点度为零： 可以直接删除</li>
<li>删除的节点度为一：需要将删除节点的左子树或者右子树上移到删除节点的位置，以保证二叉搜索树的结构性</li>
<li>删除的节点都为二：将删除节点的左子树中的最大值节点（删除节点的后继节点）移动到删除节点的位置，同<ul>
<li>则将删除节点的左⼦树头结点（左孩⼦）放到删除节点的右⼦树<br>的最左⾯节点的左孩⼦上，返回删除节点右孩⼦为新的根节点。</li>
</ul>
</li>
</ul>
<h6 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h6><p><em><strong>例：</strong></em><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p>
<h5 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h5><ul>
<li>⼜被称为AVL（<code>Adelson-Velsky and Landis</code>）树，且具有以下性质：它是⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树.</li>
</ul>
<h5 id="二叉搜索树的前驱和后继"><a href="#二叉搜索树的前驱和后继" class="headerlink" title="二叉搜索树的前驱和后继"></a>二叉搜索树的前驱和后继</h5><h6 id="前驱：x结点的前驱，-val值小于-x-gt-val-的所有结点中最大的一个"><a href="#前驱：x结点的前驱，-val值小于-x-gt-val-的所有结点中最大的一个" class="headerlink" title="前驱：x结点的前驱， val值小于 x-&gt;val 的所有结点中最大的一个"></a>前驱：x结点的前驱， <code>val</code>值小于 <code>x-&gt;val</code> 的所有结点中最大的一个</h6><ul>
<li>x结点有左子树：x结点的前驱是左子树的<code>val</code>值最大的元素 : <code>x-&gt;pre = TREE_MAXMUM(x-&gt;left)</code></li>
<li>x结点没有左子树<ul>
<li>x结点是其父结点的<em><strong>右子树</strong></em>，则x结点的前驱是其父结点</li>
<li>x节点是其父结点的<em><strong>左子树</strong></em>，则</li>
</ul>
</li>
</ul>
<h6 id="后继：x结点的后继，-val值大于-x-gt-val-的所有结点中最小的一个"><a href="#后继：x结点的后继，-val值大于-x-gt-val-的所有结点中最小的一个" class="headerlink" title="后继：x结点的后继， val值大于 x-&gt;val 的所有结点中最小的一个"></a>后继：x结点的后继， <code>val</code>值大于 <code>x-&gt;val</code> 的所有结点中最小的一个</h6><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h4 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h4><h5 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h5><blockquote>
<p>对于图G &#x3D;  (V , E)  V: 节点，E：边</p>
</blockquote>
<ul>
<li>邻接链表：以所有节点 <code>u ∈ V</code>为头节点的链表组成数组 <code>adj</code>，每个链表包含所有与 <code>u</code>节点相邻的节点，即： <code>adj[u]</code> <ul>
<li>无向图：对于边<code>（u，v）</code>， <code>adj[u]</code>中包含节点 v， <code>adj[v]</code>中包含节点 u。<em><strong>（所有邻接链表的长度为 2 E）</strong></em></li>
<li>有向图：对于边<code>（u，v）</code>， <code>adj[u]</code>中包含节点 v 。<em><strong>（所有邻接链表的长度为  E）</strong></em></li>
<li>边的权值 存在节点中</li>
</ul>
</li>
<li>邻接矩阵：<code>|V| *|V|</code>的矩阵表示，<ul>
<li>无向图： 对称矩阵</li>
<li>有向图：……</li>
<li>边（u，v）的权值 记录在矩阵 <code>第u行v列</code>的位置上</li>
</ul>
</li>
</ul>
<p>	</p>
<h5 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h5><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p>
<ul>
<li>堆中某个结点的值总是不大于或不小于其父结点的值；<ul>
<li>最大堆：父结点的值最大 ：（算法导论用于堆排序）</li>
<li>最小堆：父结点的值最小：（构造优先队列）</li>
</ul>
</li>
<li>堆总是一棵完全二叉树。</li>
</ul>
<h5 id="维护堆的性质"><a href="#维护堆的性质" class="headerlink" title="维护堆的性质"></a>维护堆的性质</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 维护堆的性质</span></span><br><span class="line"><span class="comment">// 从data[i] (根结点)， data[left(i)]、data[right(i)] 中找出最大值，记录最大值的下标lagerst</span></span><br><span class="line"><span class="comment">// 如果当前已经满足 堆的性质（i==lagerst）返回， 否则交换i 和 lagerst ， 并维护 lagerst 结点的堆的性质</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeap::heapify</span><span class="params">(<span class="type">size_t</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;data.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="type">int</span> lastgest = i;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">left</span>(i) &lt; <span class="keyword">this</span>-&gt;datasize &amp;&amp; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(<span class="built_in">left</span>(i)) &gt; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(i))</span><br><span class="line">					lastgest = <span class="built_in">left</span>(i);</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">right</span>(i) &lt; <span class="keyword">this</span>-&gt;datasize &amp;&amp; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(<span class="built_in">right</span>(i)) &gt; <span class="keyword">this</span>-&gt;data.<span class="built_in">at</span>(lastgest))</span><br><span class="line">					lastgest = <span class="built_in">right</span>(i);</span><br><span class="line">				<span class="keyword">if</span> (lastgest != i) &#123;</span><br><span class="line">					std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;data[i], <span class="keyword">this</span>-&gt;data[lastgest]);</span><br><span class="line">					i = lastgest;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//建堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeap::buildheap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = data.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">heapify</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeap::heapsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">buildheap</span>(); <span class="comment">//建立最大堆</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = datasize - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;data[i], <span class="keyword">this</span>-&gt;data[<span class="number">0</span>]); <span class="comment">// 交换堆顶元素和末尾元素</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;datasize -= <span class="number">1</span>; <span class="comment">// 末尾元素已经是排好序了</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">heapify</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Esort::QuickSort</span><span class="params">(std::vector&lt;T&gt; &amp; data,<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> indestandvalue = <span class="built_in">adjustarray</span>(data, l, r);</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">QuickSort</span>(data, l, indestandvalue - <span class="number">1</span>); <span class="comment">// 递归处理两个子数组</span></span><br><span class="line">	<span class="built_in">QuickSort</span>(data, indestandvalue + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">Esort::adjustarray</span><span class="params">(std::vector&lt;T&gt; &amp; data, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ptr = left, qtr = right;</span><br><span class="line">	<span class="type">int</span> standvalue = data[left];  <span class="comment">// 选定标准， 按照标准分为两部分</span></span><br><span class="line">	<span class="keyword">while</span> (ptr &lt; qtr) &#123;</span><br><span class="line">		<span class="keyword">while</span> (ptr &lt; qtr &amp;&amp; data[qtr] &gt;= standvalue)qtr--; <span class="comment">//从右往左找到比标准值小的下标</span></span><br><span class="line">		<span class="keyword">if</span> (ptr &lt; qtr) &#123;</span><br><span class="line">			data[ptr++] = data[qtr];  <span class="comment">//换到标准值前面</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (ptr &lt; qtr &amp;&amp; data[ptr] &lt; standvalue)ptr++;</span><br><span class="line">		<span class="keyword">if</span> (ptr &lt; qtr) &#123;</span><br><span class="line">			data[qtr--] = data[ptr];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	data[ptr] = standvalue;</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul>
<li>基数排序(Radix Sort)属于分配式排序，又称”桶子法”(Bucket Sort或Bin Sort)，将要排序的元素分配到某些”桶”中，以达到排序的作用。基数排序属于稳定的排序，其时间复杂度为nlog(r)m (其中r为的采取的基数,m为堆数)，基数排序的效率有时候高于其它比较性排序。</li>
<li><strong>最低位优先LSD（Least sgnificant digital）法</strong>  : 键值最右边开始</li>
<li><strong>最高位优先MSD（Most sgnificant digital）法</strong></li>
</ul>
<img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp; num)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;原数组：\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; it : num) &#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; std::endl;</span><br><span class="line">	<span class="type">int</span> size = num.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> digit = <span class="built_in">GetMaxBits</span>(num);</span><br><span class="line">	<span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(size)</span></span>;</span><br><span class="line">	<span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 0 ~9 的桶</span></span><br><span class="line">	<span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= digit; ++i) &#123; <span class="comment">// 1 到最高位 进行排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;</span><br><span class="line">			count[j] = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="comment">// 清除计数器</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; ++j) &#123;</span><br><span class="line">			count[(num[j] / radix) % <span class="number">10</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">			count[j] += count[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = size - <span class="number">1</span>; j &gt;= <span class="number">0</span> ; --j) &#123;</span><br><span class="line">			temp[count[(num[j] / radix) % <span class="number">10</span>] - <span class="number">1</span>] = num[j];</span><br><span class="line">			count[(num[j] / radix) % <span class="number">10</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">		radix *= <span class="number">10</span>;</span><br><span class="line">		num = std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">		cout &lt;&lt; num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><blockquote>
<p>程序调用自身，函数作为自身的子例程调用</p>
<p>需要根据递推关系调用函数本身，直到其抵达基本情况</p>
</blockquote>
<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>把一个大型复杂的原问题转化为规模更小的子问题，直到子问题无需进一步递归就能得到解</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>基本案例（bottom case）：规模最小的子问题，能够不适用递归得到解</li>
<li>递推关系（recurrence relation）： 将其他问题拆分到基本案例</li>
</ul>
<h4 id="递归算法的三要素"><a href="#递归算法的三要素" class="headerlink" title="递归算法的三要素"></a>递归算法的三要素</h4><ul>
<li>确定递归函数的参数和返回值</li>
<li>确定终止条件</li>
<li>确定单层递归逻辑</li>
</ul>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>​	纯暴力搜索方式：<em>递归和回溯是相辅相成的，解决问题： 组合问题、切割问题（字符串切割方式）、子集问题、排列问题、棋盘问题（N皇后）</em></p>
<blockquote>
<p>决策树的遍历过程</p>
</blockquote>
<ul>
<li><strong>路径</strong>：记录我们做出了的选择(走过的决策树上的路径，我们一般都是在最后的叶子节点上去收集结果)；【比如我们选的123,124】;</li>
<li><strong>选择列表</strong>：当前情况下我们可以做出的选择；【比如在第三步我们可以选3.4.5】</li>
<li><strong>结束条件</strong>：也就是到达了决策树的底层叶子节点，选择列表为空了，无法再做出别的选择了。【比如我们的树选完了123达到题目中的要求3个元素了，就不能够再做选择了】</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ans; <span class="comment">//结果集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(^)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="comment">/*终止条件*/</span>) &#123;</span><br><span class="line">		ans.<span class="built_in">push_back</span>(结果);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(选择列表)&#123;</span><br><span class="line">		处理结点;   \递归前做出选择,递归结束后<span class="function">c</span></span><br><span class="line"><span class="function">        <span class="title">backtracking</span><span class="params">(^)</span></span>;</span><br><span class="line">        回溯，撤销处理结点;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><em><strong>查找空间：</strong></em>具有指定左、右索引的连续序列（有序）。</p>
<p><em><strong>算法流程：</strong></em>维护查找空间的左、右、中索引，将序列中间值应用于<em><strong>查找条件</strong></em>，清除 <em>查找目标</em> 不存在的一半序列，直到成功为止。 <!--即：每次比较后将查找空间一分为二。--></p>
<p><em><strong>组成：</strong></em> 1. <em>预处理</em> —查找空间有序化。</p>
<p>​			 2.<em>二分查找</em>—使用循环或者递归在每次比较之和将查找空间一分为二</p>
<p>​			 3.<em>后处理</em>—在剩余的查找空间中确定可行的候选者</p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a><em>模板</em></h4><h5 id="模板-1："><a href="#模板-1：" class="headerlink" title="模板 1："></a><em><strong>模板 1：</strong></em></h5><blockquote>
<p>&lt;–查找空间为闭合区间, 包含i &#x3D;&#x3D; j 的空间–&gt;</p>
<p>​				&lt;–无需后处理，每步中均检查是否找到目标–&gt;</p>
<p>​				&lt;– 循环结束（j &#x3D; i - 1），目标值存在于开区间(var[j], var[i])之间–&gt;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;	</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target) &#123; </span><br><span class="line">        <span class="keyword">return</span> mid; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; </span><br><span class="line">        left = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        right = mid - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// End Condition: left &gt; right</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>例 1：搜索旋转排序数组</strong></em> </p>
<!--解一logn-->

<ul>
<li>数组<code>vector&lt;T&gt; var</code>分为左右两个递增区间<code>[left,k],[k+1,right]</code>。	<ul>
<li>中间值为目标值，结束查找。</li>
<li>中间值位于左区间 —*<code>var[left] &lt;= var[mid]</code>*<ul>
<li>目标值存在于区间<code>[left,mid]</code>，查找空间变为<code>[left,mid]</code>。—<code>var[left] &lt;= target &lt;= var[mid]</code>* </li>
<li>目标值存在于区间<code>[mid + 1,right]</code> ，查找空间变为<code>[mid + 1,right]</code>。—*<code> target &gt; var[mid]</code>*</li>
</ul>
</li>
<li>中间值位于右区间 —*<code>var[left] &gt; var[mid]</code>*<ul>
<li>目标值存在于区间<code>[mid,right]</code>，查找空间变为<code>[mid,right]</code>。—<code>var[mid] &lt;= target &lt;= var[right]</code>* </li>
<li>目标值存在于区间<code>[left,mid - 1]</code> ，查找空间变为<code>[left,mid - 1]</code>。—*<code> target &lt; var[mid]</code>*</li>
</ul>
</li>
</ul>
</li>
<li>循环结束，目标值不存在</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;=nums[right])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    right = mid - <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<!--解二：找断点，判断目标位于哪个区间，再进行二分查找-->

<h5 id="模板-2："><a href="#模板-2：" class="headerlink" title="模板 2："></a><em><strong>模板 2：</strong></em></h5><blockquote>
<p>&lt;–查找空间为开区间，不包含right–&gt;</p>
<p>​			 &lt;–保证每一步中查找空间至少存在两个元素–&gt;</p>
<p>​			  &lt;–循环结束，i&#x3D;j，需要判断是否为目标值–&gt;&lt;–注意溢出–&gt;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)&#123; <span class="keyword">return</span> mid; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; right = mid; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post-processing:</span></span><br><span class="line">  <span class="comment">// End Condition: left == right</span></span><br><span class="line">  <span class="keyword">if</span>(left != nums.<span class="built_in">size</span>() &amp;&amp; nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>例：寻找峰值 or 第一个错误的版本：</strong></em> 开区间二分：查找结束的<code>left = right</code>所在的位置就是第一个使查找条件<strong>转变</strong>的目标。</p>
<p><em><strong>例：寻找旋转排序数组中的最小值</strong></em></p>
<ul>
<li>查找空间：目标值存在于右半递增区间中<ul>
<li>二分空间：  中值位于左区间:<code>left = mid + 1</code> , 中值位于右区间：<code>right = mid</code>。</li>
<li>查找空间为递增区间，返回递增区间的第一个值</li>
<li>倒数第二次循环： <code>[left, left + 1]</code> 两个值是递增区间 or 递减。<code>mid = （i + j） / 2 = i</code>, </li>
<li>查找结束，<code>left = mid + 1 = right</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt; nums[right])</span><br><span class="line">                <span class="keyword">return</span> nums[left];</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="模板三："><a href="#模板三：" class="headerlink" title="模板三："></a><em><strong>模板三：</strong></em></h5><blockquote>
<p> &lt;–查找空间为[left.right]–&gt;</p>
<p>&lt;–每一步循环查找中至少包含三个元素–&gt;</p>
<p>&lt;–查找结束，区间为[left,right],需要判断是否存在目标值–&gt;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a><em>例题</em></h4><p><em><strong>例：寻找排序数组中目标值第一个和最后一个位置：</strong></em>	判断查找结束时左右指针的值</p>
<p><em><strong>例：</strong></em><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-k-closest-elements/"><em><strong>找到 K 个最接近的元素</strong></em></a>  <em>有序数组中找到最靠近 目标<code>x</code>的 <code>k</code> 个数</em></p>
<!--二分查找+双指针-->

<ul>
<li>目标值 <code>x</code> 小于等于有序数组的首元素： <code>x &lt;= nums[0]</code><ul>
<li>解为有序数组的前 <code>k</code> 个元素</li>
</ul>
</li>
<li>目标值 <code>x</code> 大于等于有序数组的最后一个元素： <code>x &gt;= nums[nums.size() - 1]</code><ul>
<li>解为有序数组的后 <code>k</code> 个元素</li>
</ul>
</li>
<li>其他：<ul>
<li>找出大于目标值最小的索引位置 <code>index</code>，解存在于 <code>[index- k-1, index + k -1]</code>之间 <em><u>二分查找<code>o(logn)</code></u></em></li>
<li>双指针缩小解的范围至k, 解 <code>[low = index-k-1, high = index + k-1]</code>， <em><u>判断区间范围的合法性</u></em><ul>
<li><code>low</code> 的元素比 <code>high</code> 靠近x, 缩小 <code>high</code></li>
<li><code>high &gt; size </code> or   <code>high</code> 的元素比 <code>low</code> 靠近x, 缩小 <code>low</code></li>
</ul>
</li>
<li>知道 <code>high - low = k - 1</code></li>
</ul>
</li>
</ul>
<!--做题时的问题-->

<ul>
<li><code>high = mid + k - 1 &gt; arr.size()-1 ? arr.size()-1: mid + k - 1;</code>  <em><u>取值写反</u></em></li>
<li><code>if(abs(arr[low] - x) &lt;= abs(arr[high] - x))</code> <em><u>条件判断 写成 <code>low == 0 || ……</code></u></em></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( x &lt;= arr.<span class="built_in">front</span>())   <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (arr.<span class="built_in">begin</span>(),arr.<span class="built_in">begin</span>()+ k);</span><br><span class="line">        <span class="keyword">if</span>( x &gt;= arr.<span class="built_in">back</span>()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (arr.<span class="built_in">end</span>() - k, arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = arr.<span class="built_in">size</span>(), mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( x &lt;= arr[mid])</span><br><span class="line">                high  = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = low;</span><br><span class="line">        low = <span class="built_in">max</span>(mid - k - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        high = mid + k - <span class="number">1</span> &gt; arr.<span class="built_in">size</span>()<span class="number">-1</span> ? arr.<span class="built_in">size</span>()<span class="number">-1</span>: mid + k - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(high - low &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[low] - x) &lt;= <span class="built_in">abs</span>(arr[high] - x))</span><br><span class="line">                high--; </span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (arr.<span class="built_in">begin</span>() + low, arr.<span class="built_in">begin</span>() + high + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>例：寻找重复数</strong></em></p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><em><strong>Dynamic programming</strong></em> DP </p>
<h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a><em><strong>基本思想</strong></em></h5><p>：原问题分解成子问题进行求解，也就是分治的思想。应用于<strong>子问题重叠</strong>的情况，求解最优化问题。</p>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a><em><strong>性质</strong></em></h5><ul>
<li><p>子问题重叠：具有公共的子问题</p>
</li>
<li><p>最优子结构：能够由子问题的最优解得到更大规模的问题的最优解   || <strong><u><em>子问题之间相互独立、互不干扰</em></u></strong></p>
<ul>
<li>最优解涉及几个子问题？</li>
<li>确定最优解适用哪些子问题，考虑子问题的选择</li>
</ul>
</li>
<li><p>无后效性：某个阶段的最优解一旦求出就不会再变化。</p>
</li>
<li><p>base case : 最简单的情况</p>
</li>
<li><p>问题 有什么“状态”</p>
</li>
<li><p>“状态” 通过什么 “选择” 发生改变 </p>
<ul>
<li>状态转移方程的遍历顺序 ：“ <strong>状态转移所依赖的状态必须被提前计算出来</strong> (<strong>根据 base case 和最终状态进行推导</strong>)</li>
</ul>
</li>
<li><p>如何定义dp 数组</p>
</li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><em><strong>步骤</strong></em></h5><ul>
<li>定义状态（子问题）,求解问题的自变量</li>
<li>状态转移方程（子问题之间的联系）</li>
<li>边界条件（初始值）</li>
<li>返回值</li>
</ul>
<h4 id="经典模型"><a href="#经典模型" class="headerlink" title="经典模型"></a><em><strong>经典模型</strong></em></h4><p><em>线性模型</em>、<em>区间模型</em>、背包模型</p>
<ul>
<li><p>线性模型</p>
<ul>
<li><p>输出最优解的路径&#x2F;编号</p>
</li>
<li><p>实例198. 打家劫舍： 金额向量M[n], 子问题结果DP[n]，路径IND[]</p>
</li>
</ul>
</li>
<li><p>区间模型</p>
</li>
<li><p>背包模型</p>
</li>
</ul>
<h5 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h5><ul>
<li><p>状态： 背包容量、可选择的物品</p>
</li>
<li><p><code>dp</code>数组的定义： <code>dp[i][j]</code>  ： 对于前 <code>i</code>个物品，背包容量为 j ，这种情况下的最大价值为 <code>dp[i][j]</code></p>
<ul>
<li>Base case ： <code>dp[i][0] = dp[0][j] = 0</code></li>
<li>转移：选择第 i 个物品与否<ul>
<li>不选 ： <code>dp[i][j] = dp[i - 1][j]</code>, 由前一个物品转移而来</li>
<li>选择：<code>dp[i][j] = dp[i - 1][j - w[i - 1]] + val[i]</code>,</li>
</ul>
</li>
<li>例题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
</ul>
</li>
</ul>
<h5 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h5><p>ssss</p>
<h5 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h5><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a><em>形式</em></h4><p><em><strong>带备忘的自顶向下法</strong></em>：按照递归形式编写，过程中保存子问题的解。</p>
<p><em><strong>自底向上</strong></em>：将子问题按由小到大顺序进行求解。</p>
<p><em><strong>状态压缩（空间优化）：</strong></em>滚动数组</p>
<p><em><strong>dp数组的遍历方向</strong></em> <strong>:</strong>  所需的状态必须是已经计算出来的 | 遍历的终点是存储结果的位置  </p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a><em>例题</em></h4><h5 id="例：-LIS"><a href="#例：-LIS" class="headerlink" title="例： LIS"></a><em><u>例： LIS</u></em></h5><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="例：最大子序和"><a href="#例：最大子序和" class="headerlink" title="例：最大子序和"></a><em><strong>例：</strong></em>最大子序和</h5><ul>
<li>定义状态：<code>dp[i]</code>为以<code>i</code>结尾的子数组的最优解：</li>
<li>状态转移：<ul>
<li><code>dp[i] &gt;= 0 : dp[i + 1]  = dp[i] + nums[i + 1]</code></li>
<li><code>dp[i] &lt; 0 : dp[i + 1]  = nums[i] </code><!--连续子数组，重头开始--></li>
<li><code>dp[i + 1] = max(dp[i] + nums[i + 1], dp[i])</code></li>
</ul>
</li>
<li>边界：<code>dp[0] = nums[0]</code></li>
</ul>
<h5 id="例：338-比特位计数"><a href="#例：338-比特位计数" class="headerlink" title="例：338. 比特位计数"></a><em><strong>例：</strong></em>338. 比特位计数</h5><p>最高有效位：对于正整数 x<em>x</em>，如果可以知道最大的正整数 y，使得 <code>y ≤ x</code> 且 y 是 2 的整数次幂。</p>
<ul>
<li>定义状态：<code>dp[i]</code> 表示正整数<code>i</code>的“一比特数”</li>
<li>状态转移：<ul>
<li><code>i</code>为偶数：<code>dp[i] = dp[i / 2]</code> or<code>dp[i] = dp[i &gt;&gt; 1]</code></li>
<li><code>i</code>为奇数：<code>dp[i] = dp[i / 2] + 1</code>  or<code>dp[i] = dp[i &gt;&gt; 1] + 1</code></li>
<li><code>dp[i] = dp[i &gt;&gt; 1] + (i &amp; 1)</code></li>
</ul>
</li>
<li>边界：<code>dp[0] = 0, dp[1] = 1</code></li>
</ul>
<h5 id="例：剑指-Offer-47-礼物的最大价值"><a href="#例：剑指-Offer-47-礼物的最大价值" class="headerlink" title="例：剑指 Offer 47. 礼物的最大价值"></a><em>例：</em>剑指 Offer 47. 礼物的最大价值</h5><p><em><strong>例：</strong></em> <strong>322.零钱兑换</strong></p>
<ul>
<li>定义状态：<code>dp[i] </code>表示总金额为<code>i</code>时所需最少的金币数</li>
<li>状态转移: <ul>
<li><code>i &gt; coint[i]</code>:<code>dp[i] = min(dp[i - coint[0]],……dp[i - coint[n]]) + 1</code></li>
<li><code>i = coint[i]</code>:<code>dp[i] = min(dp[i - coint[0]],……dp[i - coint[n]]) + 1 = 1</code></li>
<li><code>i &lt; coint[i]</code>: 表示没有硬币组合能组成总金额“-1”，用<code>INT_MAX -1</code>表示</li>
</ul>
</li>
<li>边界：<code>dp[0] = 0</code></li>
<li>改写为：<code>dp[i] = min(dp[i], dp[i - coint[0：n] + 1])</code></li>
</ul>
<p><em><strong>例：最长公共子序列 LCS与LIS</strong></em></p>
<h5 id="最长公共子序列问题-LCS"><a href="#最长公共子序列问题-LCS" class="headerlink" title="最长公共子序列问题 LCS"></a>最长公共子序列问题 LCS</h5><p>定义 <code>c[i][j]</code> 为序列 <code>Xi , Yi</code>的LCS的长度：<br>$$<br>\begin{cases} 0  \space\space\space\space\space\space\space<br>\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space<br>                    if \space i &#x3D; 0 \space or \space j &#x3D; 0<br>           \c[i-1][j-1] + 1 \space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space if \space xi &#x3D; yi\space and \space i,j &gt; 0<br>           \ max(c[i-1][j],c[i][j-1])\space\space if \space xi !&#x3D; yi<br>\end{cases}<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCS_base::lcslength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(size_X + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size_Y + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">	vector&lt;vector&lt;string&gt;&gt; <span class="built_in">subdp</span>(size_X + <span class="number">1</span>, <span class="built_in">vector</span>&lt;string&gt;(size_Y + <span class="number">1</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">	<span class="comment">//边界为零；</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= size_X; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= size_Y; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sequence_X[i - <span class="number">1</span>] == sequence_Y[j - <span class="number">1</span>]) &#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				subdp[i][j] = subdp[i - <span class="number">1</span>][j - <span class="number">1</span>] + sequence_X[i - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">				subdp[i][j] = subdp[i - <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">				subdp[i][j] = subdp[i][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> &amp; ii : dp[i]) &#123;</span><br><span class="line">			cout &lt;&lt; ii &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>-&gt;subsequence_Z = subdp[size_X][size_Y]; <span class="comment">// 子序列</span></span><br><span class="line">	<span class="keyword">return</span> dp[size_X][size_Y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h5><p><img src="/image-20211227195747538.png" alt="image-20211227195747538"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> row = word1.<span class="built_in">size</span>(), col = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(row + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col + <span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= row; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= col; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= col; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> left = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; </span><br><span class="line">                <span class="keyword">if</span>(word2[j - <span class="number">1</span>] != word1[i - <span class="number">1</span>])</span><br><span class="line">                   left += <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(left,dp[i][j - <span class="number">1</span>] + <span class="number">1</span>),dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul>
<li>思想：局部最优解构造全局最优解</li>
<li>算法设计步骤<ul>
<li>对于最优化问题： 转化位 对其做出一次选择之后，只剩下一个子问题</li>
<li>证明做出贪心选择后，原问题总是存在最优解</li>
<li>证明：剩余子问题的最优解的组合 能够 得到原问题的最优解</li>
</ul>
</li>
</ul>
<h5 id="例-：哈夫曼编码"><a href="#例-：哈夫曼编码" class="headerlink" title="例 ：哈夫曼编码"></a>例 ：哈夫曼编码</h5><p>思想：<img src="http://picgo.wangeyi.ink/image-20211228212326955.png" alt="image-20211228212326955"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><ul>
<li>解决 在数组中选择出第K大|小的数 的问题</li>
</ul>
<h4 id="快速选择算法"><a href="#快速选择算法" class="headerlink" title="快速选择算法"></a>快速选择算法</h4><ul>
<li><p>：基于快速排序:( 当标准值下标为 目标值时返回， 否则递归处理左右子数组)</p>
<ul>
<li>例：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/">数组中的第K个最大元素 </a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 第k大</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QuickSelect</span>(nums,k,<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">QuickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> k,<span class="type">int</span> left,<span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lp = left,rp = right;</span><br><span class="line">        <span class="type">int</span> standval = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(lp &lt; rp) &#123;</span><br><span class="line">            <span class="keyword">while</span>(lp &lt; rp &amp;&amp; nums[rp] &lt; standval) rp--; <span class="comment">// 前面是比nums[kindex] 小的</span></span><br><span class="line">            <span class="keyword">if</span>(rp &gt; lp) &#123;</span><br><span class="line">                nums[lp] = nums[rp];</span><br><span class="line">                lp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(lp &lt; rp &amp;&amp; nums[lp] &gt;= standval) lp++;</span><br><span class="line">            <span class="keyword">if</span>(lp &lt; rp) &#123;</span><br><span class="line">                nums[rp] = nums[lp];</span><br><span class="line">                rp--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[lp] = standval;</span><br><span class="line">        <span class="keyword">if</span>(lp == k - <span class="number">1</span>) &#123; <span class="comment">// 当前位置就是 第 k 大元素</span></span><br><span class="line">            <span class="keyword">return</span> standval;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(lp &lt; k - <span class="number">1</span>)&#123;  <span class="comment">// 当前位置比 第 k 大元素 小， </span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">QuickSelect</span>(nums,k,lp + <span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">QuickSelect</span>(nums,k,left,lp - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迭代</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="基于堆排序"><a href="#基于堆排序" class="headerlink" title="基于堆排序"></a>基于堆排序</h4><ul>
<li><p>建立一个大根堆，做 k - 1<em>k</em>−1 次删除操作后堆顶元素就是我们要找的答案</p>
</li>
<li><p>考察知识点 <em><strong>建堆</strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bulidheap</span>(nums);</span><br><span class="line">    <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>],nums[size - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums,<span class="number">0</span>,--size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bulidheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = nums.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums,i,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//维护堆的性质</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> i,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> left = [](<span class="type">const</span> <span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> right = [](<span class="type">const</span> <span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;&#125;;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">left</span>(i) &lt; size &amp;&amp; nums[<span class="built_in">left</span>(i)] &gt; nums[largest]) &#123;</span><br><span class="line">            largest = <span class="built_in">left</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">right</span>(i) &lt; size &amp;&amp; nums[<span class="built_in">right</span>(i)] &gt; nums[largest]) &#123;</span><br><span class="line">            largest = <span class="built_in">right</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(largest == i)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[largest]);</span><br><span class="line">        i = largest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul>
<li>AOV(Activity On Vertex Network) : 有向无环图 的线下序列</li>
<li>要点： 每次删除入度边数为0 的结点，并刷新其他点的入度边数</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串匹配算法</p>
<h5 id="例：-10-正则表达式匹配"><a href="#例：-10-正则表达式匹配" class="headerlink" title="例： 10. 正则表达式匹配 "></a><em><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">例： 10. 正则表达式匹配 </a></strong></em></h5><blockquote>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<ul>
<li>‘.’ 匹配任意单个字符</li>
<li>‘*’ 匹配零个或多个前面的那一个元、</li>
</ul>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p>&#x2F;&#x2F;动态规划？</p>
</blockquote>
<ul>
<li>每次从字符串 <code>p</code> 取出一个字符 或 字符 + <code>*</code>的组合<ul>
<li><code>p</code>中的一个字符 ： 匹配<code>s</code>中一个字符	</li>
<li><code>p</code>中的一个字符 + <code>*</code> 组合： 匹配 <code>s</code> 中任意个数的字符</li>
</ul>
<p>	</p>
</li>
<li>状态 <code>dp</code> ： <code>dp[i][j]</code> 表示 <code>s</code> 的前<code>i</code>个字符能够被 <code>p</code>的前 <code>j</code> 个字符匹配。</li>
<li>转移方程：  从 <code>s[i]、p[j]</code> 入手<ul>
<li><code>s[i]、p[j]</code> 能够匹配上，需要看前面 <code>s 的前 i - 1 字符 与 p 的前 j - 1个 字符是否匹配</code><ul>
<li><code>p[j] == s[i] || p[j] == &#39;.&#39;</code>   则   <code>dp[i][j] = dp[i - 1][j -1]</code></li>
</ul>
</li>
<li><code>p[j] == &#39;*&#39;</code>:   匹配任意自然数前一个字符 <code>p[j - 1]</code><ul>
<li><code>p[j - 1] != s[i]</code> ： 要看 <code>s[i]</code> 和  <code>p[j - 2] 是否匹配</code> ，  * 匹配零个字符，相当于去掉  <code>p[j]、p[j -1] 两个字符</code><ul>
<li><code>dp[i][j] = dp[i][j - 2]</code></li>
</ul>
</li>
<li><code>p[j - 1] == s[i] || p[j - 1] == &#39;.&#39;</code>：   <code>*</code> 前面一个字符能够匹配上  <code>###b  和 ###b*</code>  <ul>
<li><code>dp[i][j] = dp[i - 1][j] </code> :  看   <code>###</code>  和 <code>###b*</code> 能否匹配 </li>
<li>or <code>dp[i][j] = dp[i][j - 2] </code> :  看   <code>###b</code>  和 <code>###</code> 能否匹配, 去掉 b*</li>
</ul>
</li>
</ul>
</li>
<li>总结： 边界 ：<code>dp[0][0] = true; 空串能匹配上，dp[i][0] = false; </code></li>
</ul>
</li>
</ul>
<h4 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h4><blockquote>
<p>线性时间内求出以每个位置为<strong>回文</strong>中心的回文半径</p>
</blockquote>
<ul>
<li><p>奇数偶数子串：每个字符间插入**”#”**（<u>原串中不存在的字符</u>），并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 <u>“^” 和 “$”</u></p>
</li>
<li><p><img src="/image-20220404150637719.png" alt="image-20220404150637719"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="title function_">longestPalindrome</span><span class="params">(string s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty() || s.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对原始字符串做处理，将abc变成#a#b#c#</span></span><br><span class="line">        <span class="type">string</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s) &#123;</span><br><span class="line">            tmp += c;</span><br><span class="line">            tmp += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tmp.size();</span><br><span class="line">        <span class="comment">//right表示目前计算出的最右端范围，right和左边都是已探测过的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//center最右端位置的中心对称点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//p数组记录所有已探测过的回文半径，后面我们再计算i时，根据p[i_mirror]计算i</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="title function_">p</span><span class="params">(n, <span class="number">0</span>)</span>;</span><br><span class="line">        <span class="comment">//从左到右遍历处理过的字符串，求每个字符的回文半径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">//根据i和right的位置分为两种情况：</span></span><br><span class="line">            <span class="comment">//1、i&lt;=right利用已知的信息来计算i</span></span><br><span class="line">            <span class="comment">//2、i&gt;right，说明i的位置时未探测过的，只能用中心探测法</span></span><br><span class="line">            <span class="keyword">if</span>(right &gt;= i) &#123;</span><br><span class="line">                <span class="comment">//这句是关键，不用再像中心探测那样，一点点的往左/右扩散，根据已知信息</span></span><br><span class="line">                <span class="comment">//减少不必要的探测，必须选择两者中的较小者作为左右探测起点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">minArmLen</span> <span class="operator">=</span> min(right - i, p[<span class="number">2</span> * center - i]);</span><br><span class="line">                p[i] = expand(tmp, i - minArmLen, i + minArmLen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//i落在right右边，是没被探测过的，只能用中心探测法</span></span><br><span class="line">                p[i] = expand(tmp, i, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//大于right，说明可以更新最右端范围了，同时更新center</span></span><br><span class="line">            <span class="keyword">if</span>(i + p[i] &gt; right) &#123;</span><br><span class="line">                center = i;</span><br><span class="line">                right = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到了一个更长的回文半径，更新原始字符串的start位置</span></span><br><span class="line">            <span class="keyword">if</span>(p[i] &gt; maxLen) &#123;</span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                start = (i - p[i]) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据start和maxLen，从原始字符串中截取一段返回</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//以left和right为起点，计算回文半径，由于while循环退出后left和right各多走了一步</span></span><br><span class="line">    <span class="comment">//所以在返回的总长度时要减去2</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">expand</span><span class="params">(string s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right - left - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="LRU-最近最少使用"><a href="#LRU-最近最少使用" class="headerlink" title="LRU (最近最少使用)"></a>LRU (最近最少使用)</h3><ul>
<li>哈希链表实现，借助链表的有序性（一直在链表头部插入数据，维护数据按照时间排列的性质）</li>
<li>借助哈希表的常数访问时间，可以以o(1) 的时间复杂度访问链表的任意元素</li>
</ul>
<h3 id="LFU-最不经常使用"><a href="#LFU-最不经常使用" class="headerlink" title="LFU(最不经常使用)"></a>LFU(最不经常使用)</h3><ul>
<li><p>把数据按照访问频次进行排序，淘汰频次最少（最久未使用的）</p>
</li>
<li><p>基本数据结构:</p>
</li>
<li><pre><code class="c++">unordered_map&lt;int.int&gt; keyToval;   	// key、 val 的映射
unordered_map&lt;int.int&gt; keyTofreq; 	// key、 freq 的映射
int minfreq; 						// 最少的频数
unordered_map&lt;int,listedMap&lt;int&gt;&gt;	freaqTokeys;	// 频数对应的 键列表
listedMap&lt;int&gt;// 哈希链表
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 框架：</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  // get:</span><br><span class="line">  //	返回key对用的val。 增加key 对应的 freq</span><br><span class="line">  int get(int key) &#123;</span><br><span class="line">  	if(keyToval.find(key) == keyToval.end())</span><br><span class="line">          return -1;</span><br><span class="line">      increaseFreq(key);</span><br><span class="line">      return keyToval[key];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //put:</span><br><span class="line">  //	1.key 已存在： </span><br><span class="line">  //		修改key 对应的值、 增加key对用freq</span><br><span class="line">  //	2. key 不存在：</span><br><span class="line">  //		容量已满：</span><br><span class="line">  //			淘汰freq 最小的key； </span><br><span class="line">  //		容量为满：</span><br><span class="line">  //			插入键值对（key，val）。key 对应的freq = 1</span><br><span class="line">  void put(int key,int val) &#123;</span><br><span class="line">  	// 已存在：</span><br><span class="line">      if(keyToval.find(key) != keyToval.end()) &#123;</span><br><span class="line">  		keyToval[key] = val;</span><br><span class="line">          increaseFreq(key);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      // 不存在：</span><br><span class="line">      if(ketToval.size() &gt;= this-&gt;cap)&#123;</span><br><span class="line">  		removeMinFreq();</span><br><span class="line">      &#125;</span><br><span class="line">      // 插入新键值对</span><br><span class="line">      keyToval[key] = val;</span><br><span class="line">      keyToFreq[key] = 1;</span><br><span class="line">      // fk</span><br><span class="line">      if(freqTokeys.find(1) == freqTokeys.end())</span><br><span class="line">          freqTokeys[1] = new listedMap&lt;int&gt;();</span><br><span class="line">      freqTokeys[1].insert(key);</span><br><span class="line">      this-&gt;minfreq = 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>核心：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="算法技巧"><a href="#算法技巧" class="headerlink" title="算法技巧"></a>算法技巧</h3><h4 id="位运算。。"><a href="#位运算。。" class="headerlink" title="位运算。。"></a>位运算。。</h4><ul>
<li>二进制中最低的一位 ： <code>A &amp; -A</code></li>
<li>二的幂 ： <code>A &amp; (A - 1) == 0</code><ul>
<li>A 是 二的幂： 二进制只有一个 <code>1</code>位 <em><strong>例（1000）</strong></em>， A - 1 为 ：<em><strong>例(0111)</strong></em> , 逻辑与的结果为零</li>
</ul>
</li>
<li>迭代式： <code> x = x &amp; (x-1) 统计1的个数，x = x | (x + 1) 统计0的个数</code></li>
</ul>
<h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><p><em><strong>定义</strong></em> </p>
<p><em>数组的某个索引及这个索引前面的所有元素之和</em></p>
<p><em><strong>一维：</strong></em> </p>
<ul>
<li><p>一维数组 <code>x</code> 和*<u>一维前缀和数组</u>* <code>y</code> 满足： <code>y0 = x0, y1 = x0 + x1, y2 = x0 + x1 + x2, …… yn = x0 + x1 +x2 +…… +xn   </code></p>
</li>
<li><p>得到前缀和：	<code>yn = xn + yn-1</code>   <!--计算前缀和数组O(n)--></p>
</li>
</ul>
<h5 id="二维："><a href="#二维：" class="headerlink" title="二维："></a><em><strong>二维：</strong></em></h5><ul>
<li>二维数组 a 和 前缀和数组 <img src="/image-20210910142333574.png" alt="image-20210910142333574"></li>
<li>前缀和公式：<ul>
<li><code>0,0</code>： <code>b0,0 = a0,0</code></li>
<li><code>0,j </code>:   <code>b0,j = b0,j-1 + a0,j</code></li>
<li><code>i,0</code>:  <code>bi,0 = bi-1,0 + ai,0</code></li>
<li><code>i,j</code>: <code>bi,j = bi-1,j + bi-1,j - bi-1.j-1 +ai,j </code></li>
</ul>
</li>
</ul>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><em>作用</em></h5><p>前缀和是一种预处理，用于降低查询时的时间复杂度, [L,R] 之间的值为  ： <code>y[R] - y[L-1]</code></p>
<h5 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a><em>例题</em></h5><p><em><strong>例：</strong></em>209. 长度最小的子数组<!--前缀和 + 二分查找--></p>
<ul>
<li>正整数数组： 前缀和数组递增。对于每个下标，利用二分查找满足 <code>Y[j] - Y[i - 1] &gt;= target</code></li>
<li>维护 结果 <code>ret =min(ret,j - i + 1) </code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">yn</span><span class="params">(nums.size() + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; yn.<span class="built_in">size</span>(); i++)</span><br><span class="line">            yn[i] = yn[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; yn.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> start = i, end = yn.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">                m = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(yn[m] - yn[i - <span class="number">1</span>]  &lt; target)</span><br><span class="line">                    start = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    end = m; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start &lt; yn.<span class="built_in">size</span>())</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, start - i + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>例：</strong></em>238. 除自身以外数组的乘积	(<em>使用除法很简单</em>)</p>
<ul>
<li>数组<code>nums</code>，前缀乘积 <code>fnums</code>, 后缀乘积 <code>bnums</code>， 结果 <code>ans</code></li>
<li><code>fnums[i] = fnums[i - 1] * nums[i]</code>, </li>
<li><code>ans[i] = fnums[i - 1] * bnums[i + 1]</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fnums</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span>, <span class="title">bnums</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fnums[i + <span class="number">1</span>] = fnums[i] * nums[i];</span><br><span class="line">            bnums[n - i - <span class="number">1</span>] = bnums[n - i] * nums[n - i - <span class="number">1</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = fnums[i] * bnums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>例：</strong></em>304. 二维区域和检索 - 矩阵不可变</p>
<ul>
<li>计算二维数组的前缀和，<code>sums[R][C]</code></li>
<li>结果: <code>ans = sums[r2][c2] - sums[r2][c1 - 1] - sums[r1 - 1][c2] + nums[r1-1][c1-1]</code>  <!--注意数组越界 --></li>
</ul>
<h4 id="双指针与滑动窗口"><a href="#双指针与滑动窗口" class="headerlink" title="双指针与滑动窗口"></a>双指针与滑动窗口</h4><h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a><em><strong>快慢指针</strong></em></h5><ul>
<li>主要解决链表中的问题： 一般初始化指向链表的头节点，前进时快指针在前，慢指针在后。</li>
</ul>
<p><em><strong>例</strong></em>：141. 环形链表</p>
<ul>
<li>如果不含有环，跑得快的指针最终会指向null，</li>
<li>如果含有环，快指针会套圈与慢指针相遇</li>
</ul>
<p><em><strong>例：</strong></em>剑指 Offer II 022. 链表中环的入口节点</p>
<ul>
<li>快慢指针相遇时，慢指针走了<code>K</code>步，快指针走了<code>2k</code>步</li>
<li>相遇点到入环点的距离 <code>K-M</code> 与起点到入环点的距离相等。</li>
</ul>
<p><em><strong>例：</strong></em> 寻找链表的中点、链表的倒数第K个元素</p>
<p><em><strong>例： 相交链表</strong></em></p>
<h5 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a><em><strong>左右指针</strong></em></h5><ul>
<li>左右指针在数组中实际是指两个索引值，一般初始化为 <code>left = 0, right = nums.length - 1</code></li>
</ul>
<p><em><strong>例</strong></em>: 二分查找、两数之和、反转数组</p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><em><strong>滑动窗口</strong></em></h5><ul>
<li>解决子字符串的一大类问题。</li>
</ul>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h4><p><em><strong>例：</strong></em>剑指 Offer 58 - II. 左旋转字符串</p>
<ul>
<li>设 <code>x&#39;</code>表示<code>x</code>的反转则<code>（x&#39;+ y&#39;）&#39; = y + x</code></li>
</ul>
<h6 id="判断字符串包含字符，不考虑数量"><a href="#判断字符串包含字符，不考虑数量" class="headerlink" title="判断字符串包含字符，不考虑数量"></a>判断字符串包含字符，不考虑数量</h6><p>用整型 的0~26 二进制位 表示 a ~ z 的状态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    string word = words[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; word.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        temp[i] |= <span class="number">1</span> &lt;&lt; (word[j] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>$$<br>a^n &#x3D; \begin{cases}<br> a^{n-1} * a,  n 是奇数<br> \ a^{n&#x2F;2} *a^{n&#x2F;2}, n是偶数<br> \ 1 , n &#x3D; 0</p>
<p>\end{cases}<br>$$</p>
<h4 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h4><p><em><strong><code>Trie</code>树，即字典树，又称单词查找树</strong></em>: 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>实现<code>Trie</code>类 <a href="#trie">Trie类</a></p>
<p><strong>性质</strong></p>
<ul>
<li><p>特殊的多叉树、子节点有26个（输入仅为小写字母时） -<strong>[26叉树]</strong></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>&#x2F;&#x2F;前缀树的节点定义<br>class TrieNode {<br>public:<br>vector&lt;TrieNode*&gt; children;<br>bool isWord;<br>TrieNode() : isWord(false), children(26, nullptr) {<br>}<br>~TrieNode() {<br>    for (auto&amp; c : children)<br>        delete c;<br>}<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `TrieNode` 里面存储了两个信息：</span><br><span class="line"></span><br><span class="line">  - `children` 是该节点的所有子节点。</span><br><span class="line">  - `isWord` 表示从根节点到当前节点为止，该路径是否形成了一个有效的字符串。</span><br><span class="line"></span><br><span class="line">##### 构建字典树</span><br><span class="line"></span><br><span class="line">- 根节点不保存任何信息；</span><br><span class="line">- 关键词放到「前缀树」时，需要把它拆成各个字符，每个字符按照其在 &#x27;a&#x27; ~ &#x27;z&#x27; 的序号，放在 `chidren` 对应的位置里面。下一个字符是当前字符的子节点。</span><br><span class="line">- 一个输入字符串构建「前缀树」结束的时候，需要把该节点的 `isWord` 标记为 true，说明从根节点到当前节点的路径，构成了一个关键词。</span><br><span class="line"></span><br><span class="line">##### 查询</span><br><span class="line"></span><br><span class="line">- 在寻找径的过程中，发现到某个位置路径断了。不存在这样的关键词</span><br><span class="line">- 找到了这条路径，但是最后一个节点的 `isWord` 为 false。不存在这样的关键词</span><br><span class="line">- 找到了这条路径，并且最后一个节点的 `isWord` 为 true。这说明前缀树存储了这个关键词</span><br><span class="line"></span><br><span class="line">**例：**[211. 添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">struct TrieTree &#123;</span><br><span class="line">    vector&lt;TrieTree*&gt; childen;</span><br><span class="line">    bool isword;</span><br><span class="line">    TrieTree() :isword(false), childen(26,nullptr) &#123;&#125;</span><br><span class="line">    ~TrieTree() &#123;</span><br><span class="line">        for(auto &amp;c : childen)</span><br><span class="line">            delete c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class WordDictionary &#123;</span><br><span class="line">public:</span><br><span class="line">    TrieTree * root;</span><br><span class="line">    WordDictionary() &#123;</span><br><span class="line">        root = new TrieTree();</span><br><span class="line">    &#125;</span><br><span class="line">    ~WordDictionary() &#123;</span><br><span class="line">        delete root;</span><br><span class="line">    &#125;</span><br><span class="line">    void addWord(string word) &#123;</span><br><span class="line">        TrieTree* move = root;</span><br><span class="line">        for(char &amp; str : word) &#123;</span><br><span class="line">            if(move-&gt;childen[str - &#x27;a&#x27;] == nullptr)</span><br><span class="line">                move-&gt;childen[str - &#x27;a&#x27;] = new TrieTree();</span><br><span class="line">            move = move-&gt;childen[str - &#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        move-&gt;isword = true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool back(string &amp;word, TrieTree * root, int depth) &#123; //树的深度表示字符串的长度0开始</span><br><span class="line">        if(root == nullptr) return false;</span><br><span class="line">        if(depth == word.size()) return root-&gt;isword;</span><br><span class="line">        bool ans = false;</span><br><span class="line">        if(word[depth] != &#x27;.&#x27;)</span><br><span class="line">            return back(word,root-&gt;childen[word[depth] - &#x27;a&#x27;],depth + 1);</span><br><span class="line">        else &#123;</span><br><span class="line">            for(TrieTree *&amp; chi : root-&gt;childen)&#123;</span><br><span class="line">                ans |= back(word,chi,depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        return back(word,root,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your WordDictionary object will be instantiated and called as such:</span><br><span class="line"> * WordDictionary* obj = new WordDictionary();</span><br><span class="line"> * obj-&gt;addWord(word);</span><br><span class="line"> * bool param_2 = obj-&gt;search(word);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h4><p><em><strong>求众数</strong></em></p>
<p>Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：</p>
<ul>
<li>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</li>
<li>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：<ul>
<li>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</li>
<li>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</li>
</ul>
</li>
<li>在遍历完成后，candidate 即为整个数组的众数。</li>
</ul>
<h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p><a name = "单调栈"></a></p>
<ul>
<li>单调递增栈即栈内元素保持单调递增的栈，同理单调递减栈即栈内元素保持单调递减的栈<ul>
<li>可以以 O(1) 的时间复杂度得知某个位置左右两侧比他大（或小）的数的位置</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">  <span class="keyword">while</span>(! stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &gt; T[i])&#123;</span><br><span class="line">    stk.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  stk.<span class="built_in">push</span>(A[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p><a name ="单调队列"></a></p>
<ul>
<li>用单调队列来解决问题，一般都是需要得到当前的某个范围内的最小值或最大值。</li>
</ul>
<p><em><strong>例题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; sque; <span class="comment">// 存的是下标</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!sque.<span class="built_in">empty</span>() &amp;&amp; i - sque.<span class="built_in">front</span>() &gt;= k) &#123;  <span class="comment">//  超出窗口大小，将队头元素pop</span></span><br><span class="line">                sque.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!sque.<span class="built_in">empty</span>() &amp;&amp; nums[sque.<span class="built_in">back</span>()] &lt; nums[i]) &#123; <span class="comment">// 维护单调递减队列</span></span><br><span class="line">                sque.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            sque.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k <span class="number">-1</span>)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[sque.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h4><blockquote>
<p>N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉</p>
</blockquote>
<ul>
<li><p>模拟：链表实现，删除节点o(1)</p>
<ul>
<li>index 表示当前删除的位置，下次删除的位置为： index + m - 1， 从头取数： (index + m - 1) % n；</li>
</ul>
</li>
<li><p>动态规划：</p>
<ul>
<li>输入 n, mn,m ，记此约瑟夫环问题为 「n, mn,m 问题」 ，设解（即最后留下的数字）为 f(n)f(n) ，则有：<ul>
<li><code>「n, m 问题」</code>：数字环为 0, 1, 2, …, n - 10,1,2,…,n−1 ，解为 f(n)f(n) ；</li>
<li><code>「n-1, m 问题」</code>：数字环为 0, 1, 2, …, n - 20,1,2,…,n−2 ，解为 f(n-1)f(n−1) ； 以此类推…</li>
</ul>
</li>
<li><img src="image-20220402165432792.png" alt="image-20220402165432792" style="zoom: 80%;" /></li>
<li><strong>状态定义</strong>： 设<code>「i, m  问题」</code>的解为 <code>dp[i]</code> ；</li>
<li><strong>转移方程</strong>： 通过以下公式可从 <code>dp[i - 1]</code> 递推得到 <code>dp[i]</code> ；<ul>
<li><code>dp[i] = (dp[i - 1] + m) \% i</code></li>
<li><code>dp[i]=(dp[i−1]+m)%i</code></li>
</ul>
</li>
<li><strong>初始状态</strong>：「1, m 问题」的解恒为 00 ，即 <code>dp[1] = 0</code> ；</li>
<li><strong>返回值</strong>： 返回「n, m 问题」的解 <code>dp[n]</code> ；</li>
</ul>
</li>
</ul>
<h4 id="两数的最大公约数"><a href="#两数的最大公约数" class="headerlink" title="两数的最大公约数"></a>两数的最大公约数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123; <span class="comment">// z</span></span><br><span class="line">	<span class="type">int</span> rem;			<span class="comment">//余数，当余数为0的时候，最后的m即为最大公约数</span></span><br><span class="line">	<span class="comment">//先用较小的数对较大的数取余，再用余数对较小的数求余，直到余数为零 </span></span><br><span class="line">	<span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		rem = m % n;</span><br><span class="line">		m = n;</span><br><span class="line">		n = rem;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> m;			<span class="comment">//将结果返回			</span></span><br></pre></td></tr></table></figure>



<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="哈希表链接法"><a href="#哈希表链接法" class="headerlink" title="哈希表链接法"></a>哈希表链接法</h3><p><a name = "链接法"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HashSize 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	T val;</span><br><span class="line">	Node * next;</span><br><span class="line">	<span class="built_in">Node</span>() : <span class="built_in">val</span>(), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">	<span class="built_in">Node</span>(T v) : <span class="built_in">val</span>(v), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">	<span class="built_in">Node</span>(T v, Node* n) : <span class="built_in">val</span>(v), <span class="built_in">next</span>(n) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node&lt;T&gt; *node[HashSize];</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val % HashSize;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HashTable</span>();</span><br><span class="line">	~<span class="built_in">HashTable</span>();</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(T val)</span></span>; </span><br><span class="line">	<span class="function">Node&lt;T&gt;* <span class="title">Search</span><span class="params">(T val)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Detlete</span><span class="params">(T val)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printTable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;HashTable.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">HashTable&lt;T&gt;::<span class="built_in">HashTable</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; HashSize; ++i) &#123;</span><br><span class="line">		node[i] = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">HashTable&lt;T&gt;::~<span class="built_in">HashTable</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> HashTable&lt;T&gt;::<span class="built_in">Insert</span>(T val) </span><br><span class="line">&#123;</span><br><span class="line">	Node&lt;T&gt; * head = node[<span class="built_in">Hash</span>(val)];</span><br><span class="line">	Node&lt;T&gt; * newNode = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(val);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		head = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (val &lt; head-&gt;val) &#123;</span><br><span class="line">		newNode-&gt;next = head;</span><br><span class="line">		head = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Node&lt;T&gt; * p = head;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;next != <span class="literal">nullptr</span> &amp;&amp; p-&gt;val &lt; val) &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		newNode-&gt;next = p-&gt;next;</span><br><span class="line">		p-&gt;next = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	node[<span class="built_in">Hash</span>(val)] = head;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//搜索</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node&lt;T&gt;* HashTable&lt;T&gt;::<span class="built_in">Search</span>(T val)</span><br><span class="line">&#123;</span><br><span class="line">	Node&lt;T&gt; *head = node[<span class="built_in">Hash</span>(val)];</span><br><span class="line">	<span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val != val) &#123;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head ? head : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> HashTable&lt;T&gt;::<span class="built_in">Detlete</span>(T val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">Search</span>(val)) &#123;</span><br><span class="line">		Node&lt;T&gt; *head = node[<span class="built_in">Hash</span>(val)];</span><br><span class="line">		<span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;next != <span class="literal">nullptr</span> &amp;&amp; head-&gt;next-&gt;val != val) &#123;</span><br><span class="line">			head = head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			head = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> HashTable&lt;T&gt;::<span class="built_in">printTable</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; HashSize; ++i) &#123;</span><br><span class="line">		Node&lt;T&gt; *p = node[i];</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;N&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p><a name = "二叉树迭代"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        stack&lt;TreeNode*&gt; mstack;</span><br><span class="line">        <span class="keyword">while</span>(!mstack.<span class="built_in">empty</span>() || root) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                mstack.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = mstack.<span class="built_in">top</span>();</span><br><span class="line">            mstack.<span class="built_in">pop</span>();</span><br><span class="line">            root = root-&gt;right; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        stack&lt;TreeNode*&gt; stacks;</span><br><span class="line">        <span class="keyword">while</span>(!stacks.<span class="built_in">empty</span>() || root)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                stacks.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stacks.<span class="built_in">top</span>();</span><br><span class="line">            stacks.<span class="built_in">pop</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root -&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">		stack&lt;TreeNode*&gt; s;</span><br><span class="line">		TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (cur || !s.<span class="built_in">empty</span>()) &#123;<span class="comment">//同样是不断遍历左子树</span></span><br><span class="line">			<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">				s.<span class="built_in">push</span>(cur);</span><br><span class="line">				cur = cur-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = s.<span class="built_in">top</span>();</span><br><span class="line">			<span class="keyword">if</span> (!cur-&gt;right || pre == cur-&gt;right) &#123;<span class="comment">//当该节点的右子树为空或者该节点的右节点是上次遍历过的节点，则直接弹出</span></span><br><span class="line">				v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">				s.<span class="built_in">pop</span>();</span><br><span class="line">				pre = cur;</span><br><span class="line">				cur = <span class="literal">NULL</span>;<span class="comment">//当弹出一个节点时，说明该树已经遍历完了，那么就要把cur设置为NULL</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//否则就遍历右子树</span></span><br><span class="line">				cur = cur-&gt;right;</span><br><span class="line">				pre = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a name ="层序遍历"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; size; ++i)&#123;</span><br><span class="line">                TreeNode * newroot = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(newroot-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(newroot-&gt;left) que.<span class="built_in">push</span>(newroot-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(newroot-&gt;right) que.<span class="built_in">push</span>(newroot-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h3><ul>
<li>第⼀步：如果数组⼤⼩为零的话，说明是空节点了。</li>
<li>第⼆步：如果不为空，那么取后序数组最后⼀个元素作为节点元素。</li>
<li>第三步：找到后序数组最后⼀个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，⼀定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组？</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码 中序数组和后序数组的长度一样</span></span><br><span class="line"><span class="comment">//第一步</span></span><br><span class="line"><span class="keyword">if</span>(postorde.<span class="built_in">size</span>()== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line"><span class="comment">//第二步</span></span><br><span class="line">Treenode* root = <span class="keyword">new</span> <span class="built_in">Treenode</span>(postorder.<span class="built_in">back</span>());</span><br><span class="line"><span class="keyword">if</span>(postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root; <span class="comment">//叶子节点</span></span><br><span class="line"><span class="comment">//第三步</span></span><br><span class="line"><span class="type">int</span> Index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;Index &lt; inorder.<span class="built_in">size</span>(); ++Index)&#123;</span><br><span class="line">	<span class="keyword">if</span>(inorder[Index] == root-&gt;val) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第四步 左闭右开</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftinorder</span><span class="params">(inorder.begin(),inorder.begin() + Index)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightinorder</span><span class="params">(inorder.begin() + Index + <span class="number">1</span>,inorder.end())</span></span>;</span><br><span class="line"><span class="comment">//第五步</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftpostorder</span><span class="params">(postorder.begin(),postorder.begin() + leftinorder.size())</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightpostorder</span><span class="params">(postorder.begin() + leftinorder.size() + <span class="number">1</span>, postorder.end() - <span class="number">1</span>)</span></span>;  <span class="comment">// 舍弃尾部元素</span></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">root-&gt;left = <span class="built_in">dfs</span>(leftinorder,leftpostorder);</span><br><span class="line">root-&gt;right = <span class="built_in">dfs</span>(rightinorder,rightpostorder);</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><ul>
<li>如果找到⼀个节点，发现左⼦树出现结点p，右⼦树出现节点q，或者 左⼦树出现结点q，右⼦树出现节点p<ul>
<li>那么该节点就是节点p和q的最近公共祖先。</li>
</ul>
</li>
<li>自底向上- 后序遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q || root == <span class="literal">nullptr</span>)  <span class="keyword">return</span> root;    <span class="comment">//找到p，q结点或者空就回溯到上一层</span></span><br><span class="line">        TreeNode * left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode * right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="comment">//p,q 结点存在于root 的左右子树</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> right;                           <span class="comment">//最近的公共祖先存在右子树种</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> left;                            <span class="comment">//最近的公共祖先存在左子树种</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树-1"><a href="#二叉搜索树-1" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><a name = "binaryseachtree"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* move = root;</span><br><span class="line">        <span class="keyword">while</span>(move) &#123;</span><br><span class="line">            <span class="keyword">if</span>(move-&gt;val &gt; val) &#123;</span><br><span class="line">                <span class="keyword">if</span>(move-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    move-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                move = move-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(move-&gt;val &lt; val) &#123;</span><br><span class="line">                <span class="keyword">if</span>(move-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    move-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                move = move-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root ? root : <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="前缀树-1"><a href="#前缀树-1" class="headerlink" title="前缀树"></a>前缀树</h3><p><a name = "trie"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    vector&lt;TrieNode *&gt; childen;</span><br><span class="line">    <span class="built_in">TrieNode</span>(): <span class="built_in">isWord</span>(<span class="literal">false</span>), <span class="built_in">childen</span>(<span class="number">26</span>,<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(TrieNode *&amp; cha : childen)</span><br><span class="line">            <span class="keyword">delete</span> cha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode * move = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> &amp;alpha : word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(move-&gt;childen[alpha - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">                move-&gt;childen[alpha - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            move = move-&gt;childen[alpha - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        move-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word,root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string&amp; word, TrieNode *&amp; r,<span class="type">int</span> depth = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth == word.<span class="built_in">size</span>()) <span class="keyword">return</span> r-&gt;isWord;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word,r-&gt;childen[word[depth] - <span class="string">&#x27;a&#x27;</span>],depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">startsWith</span>(prefix,root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix,TrieNode *&amp; r,<span class="type">int</span> depth = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="literal">nullptr</span> &amp;&amp; depth &lt;= prefix.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt;= prefix.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">startsWith</span>(prefix,r-&gt;childen[prefix[depth] - <span class="string">&#x27;a&#x27;</span>],depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode * root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><ul>
<li><p>状态数组：<code>f[i][j] 表示“前 i 件物品总重量为 j 时能获得的最大价值”；</code></p>
</li>
<li><p>状态转移方程：<code>f[i][j] = max(f[i - 1][j], f[i - 1][j - c[i]] + v[i])。</code></p>
<ul>
<li><code>f[i][j] = f[i - 1][j]</code> : 第<code>i</code>件物品不装入</li>
<li><code>f[i][j] = f[i - 1][j - c[i]] + v[i]</code>： 装入第<code>i</code>件物品</li>
</ul>
</li>
<li><p>滚动数组空间优化：<code>f[i] 表示“总重量为 i 时能获得的最大价值”</code> </p>
<ul>
<li>滚动数组： <em><strong>把上一层的数据拷贝的到当前层</strong></em> （）</li>
</ul>
</li>
<li><pre><code class="c++">// 01背包问题伪代码(空间优化版)
for j = 1,...,N  //表示第j个物品： for依次表示第j件物品存入的情况
    for i = C,...,c[j] // 必须逆向枚举!!!
        f[i] = max(f[i], f[i−c[j]]+v[j]
</code></pre>
</li>
<li><p>先物品后容量： 保证上一层的数据是计算完的，</p>
</li>
<li><p>重量逆序遍历： 保证 f[i−c[j]]的值是上一层的（前一时刻的值）</p>
<ul>
<li>而正序的话，  f[i−c[j]] 的值已经被当前层覆盖</li>
<li></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://blog.wangeyi.ink">We_</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.wangeyi.ink/2022/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">http://blog.wangeyi.ink/2022/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.wangeyi.ink" target="_blank">We</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/pexels-balamurugan-anbazhagan-763103.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/20/%E6%8E%92%E5%BA%8F/"><img class="prev-cover" src="http://picgo.wangeyi.ink/pexels-daria-shevtsova-1580625.jpg" onerror="onerror=null;src='/img/pexels-wolfram-k-804166.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">学学排序</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/13/C-%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="http://picgo.wangeyi.ink/pexels-daria-shevtsova-1580625.jpg" onerror="onerror=null;src='/img/pexels-wolfram-k-804166.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ 基础</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/me.jpg'" alt="avatar"/></div><div class="author-info__name">We_</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lasrd"><i class="fab fa-github"></i><span>——</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/larsd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/18259572395@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哈哈哈</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">基本数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">2.1.1.</span> <span class="toc-text">栈和队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.3.</span> <span class="toc-text">二叉树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">解决冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">链接法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="toc-number">2.3.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.2.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.3.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.3.4.</span> <span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">动态集合的操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">查询-代码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">2.3.4.5.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="toc-number">2.3.4.6.</span> <span class="toc-text">例题：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.3.5.</span> <span class="toc-text">平衡二叉搜索树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%89%8D%E9%A9%B1%E5%92%8C%E5%90%8E%E7%BB%A7"><span class="toc-number">2.3.6.</span> <span class="toc-text">二叉搜索树的前驱和后继</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%89%8D%E9%A9%B1%EF%BC%9Ax%E7%BB%93%E7%82%B9%E7%9A%84%E5%89%8D%E9%A9%B1%EF%BC%8C-val%E5%80%BC%E5%B0%8F%E4%BA%8E-x-gt-val-%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E4%B8%80%E4%B8%AA"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">前驱：x结点的前驱， val值小于 x-&gt;val 的所有结点中最大的一个</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E7%BB%A7%EF%BC%9Ax%E7%BB%93%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%EF%BC%8C-val%E5%80%BC%E5%A4%A7%E4%BA%8E-x-gt-val-%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84%E4%B8%80%E4%B8%AA"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">后继：x结点的后继， val值大于 x-&gt;val 的所有结点中最小的一个</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">图算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.5.1.</span> <span class="toc-text">图的表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">2.5.2.</span> <span class="toc-text">广度优先搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%A0%86%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">维护堆的性质</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">3.3.</span> <span class="toc-text">基数排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">4.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-number">4.1.</span> <span class="toc-text">思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">4.3.</span> <span class="toc-text">递归算法的三要素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">5.</span> <span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">6.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.1.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-1%EF%BC%9A"><span class="toc-number">6.1.1.</span> <span class="toc-text">模板 1：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-2%EF%BC%9A"><span class="toc-number">6.1.2.</span> <span class="toc-text">模板 2：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%89%EF%BC%9A"><span class="toc-number">6.1.3.</span> <span class="toc-text">模板三：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">6.2.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">7.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA"><span class="toc-number">7.1.</span> <span class="toc-text">理论</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">7.1.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">7.1.2.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.1.3.</span> <span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">经典模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85"><span class="toc-number">7.2.1.</span> <span class="toc-text">0-1背包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">7.2.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2DP"><span class="toc-number">7.2.3.</span> <span class="toc-text">树形DP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">7.4.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%EF%BC%9A-LIS"><span class="toc-number">7.4.1.</span> <span class="toc-text">例： LIS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">7.4.2.</span> <span class="toc-text">例：最大子序和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%EF%BC%9A338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0"><span class="toc-number">7.4.3.</span> <span class="toc-text">例：338. 比特位计数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%EF%BC%9A%E5%89%91%E6%8C%87-Offer-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">7.4.4.</span> <span class="toc-text">例：剑指 Offer 47. 礼物的最大价值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98-LCS"><span class="toc-number">7.4.5.</span> <span class="toc-text">最长公共子序列问题 LCS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">7.4.6.</span> <span class="toc-text">编辑距离</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B-%EF%BC%9A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">8.0.1.</span> <span class="toc-text">例 ：哈夫曼编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">选择算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">快速选择算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">9.2.</span> <span class="toc-text">基于堆排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">11.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%EF%BC%9A-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">11.0.1.</span> <span class="toc-text">例： 10. 正则表达式匹配 </span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Manacher%E7%AE%97%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">Manacher算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8"><span class="toc-number">12.</span> <span class="toc-text">LRU (最近最少使用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LFU-%E6%9C%80%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8"><span class="toc-number">13.</span> <span class="toc-text">LFU(最不经常使用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7"><span class="toc-number">14.</span> <span class="toc-text">算法技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%82%E3%80%82"><span class="toc-number">14.1.</span> <span class="toc-text">位运算。。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">14.2.</span> <span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%EF%BC%9A"><span class="toc-number">14.2.1.</span> <span class="toc-text">二维：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">14.2.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">14.2.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">14.3.</span> <span class="toc-text">双指针与滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">14.3.1.</span> <span class="toc-text">快慢指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88"><span class="toc-number">14.3.2.</span> <span class="toc-text">左右指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">14.3.3.</span> <span class="toc-text">滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3"><span class="toc-number">14.4.</span> <span class="toc-text">字符串相关</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E5%AD%97%E7%AC%A6%EF%BC%8C%E4%B8%8D%E8%80%83%E8%99%91%E6%95%B0%E9%87%8F"><span class="toc-number">14.4.0.1.</span> <span class="toc-text">判断字符串包含字符，不考虑数量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">14.5.</span> <span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">14.6.</span> <span class="toc-text">前缀树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95"><span class="toc-number">14.7.</span> <span class="toc-text">摩尔投票法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">14.8.</span> <span class="toc-text">单调栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">14.9.</span> <span class="toc-text">单调队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">14.10.</span> <span class="toc-text">约瑟夫环问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">14.11.</span> <span class="toc-text">两数的最大公约数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">哈希表链接法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">二叉树遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">3.1.</span> <span class="toc-text">二叉树的最近公共祖先</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-1"><span class="toc-number">4.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91-1"><span class="toc-number">5.</span> <span class="toc-text">前缀树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-%E8%83%8C%E5%8C%85"><span class="toc-number">6.</span> <span class="toc-text">0-1 背包</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><img src="http://picgo.wangeyi.ink/pexels-messala-ciulla-1162643.jpg" onerror="this.onerror=null;this.src='/img/pexels-wolfram-k-804166.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/2022/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2022-08-30T07:46:29.000Z" title="发表于 2022-08-30 15:46:29">2022-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/25/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" title="计网笔记"><img src="http://picgo.wangeyi.ink/pexels-pixabay-262484.jpg" onerror="this.onerror=null;this.src='/img/pexels-wolfram-k-804166.jpg'" alt="计网笔记"/></a><div class="content"><a class="title" href="/2022/08/25/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" title="计网笔记">计网笔记</a><time datetime="2022-08-25T12:47:37.000Z" title="发表于 2022-08-25 20:47:37">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" title="计算机网络之性能指标"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/pexels-wolfram-k-804166.jpg'" alt="计算机网络之性能指标"/></a><div class="content"><a class="title" href="/2022/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" title="计算机网络之性能指标">计算机网络之性能指标</a><time datetime="2022-08-25T12:11:03.000Z" title="发表于 2022-08-25 20:11:03">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/22/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="文件管理"><img src="http://picgo.wangeyi.ink/老人.png" onerror="this.onerror=null;this.src='/img/pexels-wolfram-k-804166.jpg'" alt="文件管理"/></a><div class="content"><a class="title" href="/2022/08/22/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="文件管理">文件管理</a><time datetime="2022-08-22T08:02:10.000Z" title="发表于 2022-08-22 16:02:10">2022-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/21/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="智能指针"><img src="http://picgo.wangeyi.ink/老人.png" onerror="this.onerror=null;this.src='/img/pexels-wolfram-k-804166.jpg'" alt="智能指针"/></a><div class="content"><a class="title" href="/2022/08/21/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="智能指针">智能指针</a><time datetime="2022-08-21T12:11:27.000Z" title="发表于 2022-08-21 20:11:27">2022-08-21</time></div></div></div></div></div></div></main><footer id="footer" style="background: balck"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By We_</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>